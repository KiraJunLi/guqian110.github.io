<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Coding Life</title><link href="http://guqian110.github.io/" rel="alternate"></link><link href="http://guqian110.github.io/feeds/fpga.atom.xml" rel="self"></link><id>http://guqian110.github.io/</id><updated>2014-09-02T23:12:00+08:00</updated><entry><title>Xilinx FFT IP core 笔记</title><link href="http://guqian110.github.io/pages/2014/09/02/xilinx_fft_core_notes.html" rel="alternate"></link><updated>2014-09-02T23:12:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-09-02:pages/2014/09/02/xilinx_fft_core_notes.html</id><summary type="html">&lt;p&gt;关于 FFT 的背景介绍就不再赘述，通原书和网上的教程、课件很多；关于这个 IP 核的介绍也就不再粘贴复制了，原版的 datasheet 必然是最全面的，仅记录我的使用时遇到的问题和需要注意到细节。&lt;/p&gt;
&lt;p&gt;IP 核的接口示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="schematic symbol" src="/images/xilinx_fft_core_notes/symbol.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Timing&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;code&gt;START / RFD&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;datasheet 中没有专门描述 &lt;code&gt;start&lt;/code&gt; 信号和其他信号的时序关系，只是简单介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FFT start signal (Active High): START is asserted to begin the data loading and transform calculation (for the Burst I/O architectures). For Streaming I/O, START begins data loading, which proceeds directly to transform calculation and then data unloading.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我最开始的测试小程序中，是先判断 &lt;code&gt;rfd&lt;/code&gt; 信号，根据 rfd 来给 start 赋值。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;思路是：首先必须等 IP core 准备好接收新数据时，才能开始&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rfd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;busy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是仿真出来的结果显示 IP core 根本就没有工作，后来改了这两个信号的先后关系，&lt;/p&gt;
&lt;p&gt;&lt;em&gt;新思路：程序将输入 start 置有效，通知 IP core 需要调用，然后 IP core 根据自己的状态给出标识信号（rfd / busy），外部电路等到 rfd 有效时才输入需要变换的信号。&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;busy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样子程序就可以正常运行了。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;RFD / DV&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;在 datasheet 中给出的时序图如下所示（Burst I/O Solutions with Natural Order Output）&lt;/p&gt;
&lt;p&gt;&lt;img alt="Burst I/O Solution" src="/images/xilinx_fft_core_notes/burst_io_solution.png" /&gt;&lt;/p&gt;
&lt;p&gt;实际仿真图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rfd_dv_sim" src="/images/xilinx_fft_core_notes/rfd_dv.png" /&gt;&lt;/p&gt;
&lt;p&gt;实际仿真结果和示意图有一点点小差别：datasheet 中的时序图显示 rfd 必须在等 unload 阶段结束之后才能变有效，输入新的数据；但是实际的仿真图显示，在 unload 的后半段时间，rfd 已经变有效了，开始载入新的数据。&lt;/p&gt;
&lt;p&gt;从理论上分析，采用 Burst I/O with Natural Order Output 方案，总共需要 3N 个时钟周期，load 阶段需要 N 个周期载入数据，processing 阶段需要 N 个时钟变换，unload 阶段需要 N 个周期来输出数据。&lt;/p&gt;
&lt;p&gt;从仿真结果来看，unload 阶段和下一帧的 load 阶段有部分是重叠的，这样实际上的周期是少于 3N 个时钟的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然功能上是不影响下一帧的数据的，毕竟和预期的时序不同，不知道是否会影响时序设计，有待继续观察。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Port&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;code&gt;NFFT&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;这个 FFT core 是可以设置为 动态重配置的，可以在运行时改变做运算的点数，非常方便，不过有一点需要注意到是重配置的点数是有范围限制的，比如我测试时设置的最大点数为 4096 点，那么运行重配置时，最小的点数为 64。可以选择 64 ~ 4096 之间的任何一个 2 的指数。&lt;/p&gt;
&lt;p&gt;由于我一开始忽略了这一点，重配置为 16 点，迷糊了半天，重新打开 IP core 设置时才发现是自己看文档不够仔细 =.=&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;CP&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;这个 FFT core 专门提供了一个端口可以设置循环前缀的长度，循环前缀 (cyclic prefix) 在通信中（尤其是 OFDM）是很有用的。&lt;/p&gt;
&lt;p&gt;在向导中设置了 cyclic prefix insertion，并且在程序重配置时设置了 CP length = 10，但是仿真结果却没有出现 CP，和 CP = 0 时的结果相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仔细看了两遍程序和 datasheet，没有发现问题...待解决！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 09/03/2014&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又仔细看了两遍 datasheet，终于发现了原因所在。在关于 CP length 部分，最有一小段话一直被我匆匆忽略了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The initial value and reset value of CP_LEN is 0 (no cyclic prefix). The core uses the log2(point size) MSBs of CP_LEN for the cyclic prefix length. So, when the point size decreases, the leftover LSBs are ignored. This effectively scales the cyclic prefix length with the point size, keeping them in approximately constant proportion. However, all bits of CP_LEN are latched into the core on CP_LEN_WE and are used in later transforms if the point size increases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细读了一遍才明白，CP_LEN 起作用的是高位的数据 —— 从 MSB 起共 log2(point size) 位。比如我测试程序设置的最大点数为 4096，这是 CP_LEN 的位宽为 12 比特，但是在程序运行过程中，我重配置为 64 点，所以这时候应该从 CP_LEN 的最高位数起，共 log2(64) = 6 比特数据起作用。如果我想设置 CP 的长度为 8 点，则应该如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cp_len&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b001000_000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这时候，如下图所示，结果与预期相符。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cp" src="/images/xilinx_fft_core_notes/cp.png" /&gt;&lt;/p&gt;
&lt;h3&gt;FFT/ IFFT&lt;/h3&gt;
&lt;p&gt;在 FFT 的测试程序中，一切都正常工作，但是切换为 IFFT 模式，却出现了问题。&lt;/p&gt;
&lt;p&gt;datasheet 中介绍，控制正反变换的信号一共有两个：&lt;code&gt;fwd_inv&lt;/code&gt; 和 &lt;code&gt;fwd_inv_we&lt;/code&gt;。前者取 1 时为 FFT，取 0 为 IFFT；后者是前者的写使能信号。&lt;/p&gt;
&lt;p&gt;因为 FFT 的程序可以正常工作，说明程序逻辑是没有问题的。但是只配置这两个端口，就是有问题。自己研究无果，只能 Google，还真的找到以前有人也遇到同样的问题，并且给出了解决方法（不得不说，还是 Google 好，某度搜出来的结果都是广告和没有用的链接）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://forums.xilinx.com/t5/Digital-Signal-Processing-IP-and/IFFT-of-FFT-module-does-not-work/td-p/71555"&gt;IFFT of FFT module does not work&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://myfpgablog.blogspot.com/2009/11/ifft-in-system-generator.html"&gt;IFFT in System Generator (blogspot 需翻墙)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转原博客部分内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By default, the FFT block is configured to calculate DFT. The setup and timing of control/data signals for IDFT are the same as DFT except for two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The FFT block needs to be set up for IDFT by setting fwd_inv_we signal to 1 and fwd_inv signal to 0 before the start of the transform.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The FFT output needs to be manually scaled to account for the factor 1/N in Equation 2 above. The scaling can be done either by using the scaling schedule input or shifting the FFT output if the FFT block is set to "unscaled".&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题关键就在于第二条，需要手动设置数据缩放，给结果乘以 1/N。&lt;/p&gt;
&lt;p&gt;原因就是这个 IP core 在计算 FFT 和 IFFT 时，利用两者表达式上的相似点，使用相同的结构，但是却缺少给 IFFT 的结果乘以 1/N 的步骤，需要用户自己添加。&lt;/p&gt;
&lt;p&gt;在 datasheet 中介绍说&lt;/p&gt;
&lt;p&gt;&lt;img alt="theory" src="/images/xilinx_fft_core_notes/theory.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The inverse FFT (IFFT) is computed by conjugating the phase factors of the corresponding forward FFT.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是却没有提到这个额外的 1/N 需要用户自己手动设置，应该算是 Xilinx 的坑。修正这个倍数关系以后，结果就与预期相符了～&lt;/p&gt;
&lt;p&gt;（其实如果仔细分析对比 FPGA 和 Matlab 的结果，就能发现两者的差别就是这个 1/N 的倍数关系，只是自己对数字不敏感，又懒得仔细观察 =.=）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;P.S. Test program&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;FFT IP core&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;page1: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;channel = 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transform Length = 4096&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Radix-4, Burst I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;run time configurable transform length&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page2:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fix Point&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Input data width  = 24&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phase factor width = 24&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;block floating point&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;natural output&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cyclic prefix insertion&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;input data timing - no offset&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page3:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;use 3-multiplier structer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;use CLB logic to implement butterfly arithmetic&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;运行时重配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变换长度为 64 点，cp 长度为 10&lt;/p&gt;
&lt;h3&gt;Matlab&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;re&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;im&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;imag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;im&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;FFT IP core 仿真结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fft core sim" src="/images/xilinx_fft_core_notes/fft_core_sim.png" /&gt;&lt;/p&gt;
&lt;p&gt;对比 Matlab 中的结果，可以看到 IP core 的计算结果是正确的（除了 CP 的问题）。&lt;/p&gt;</summary><category term="FPGA"></category><category term="fft"></category></entry><entry><title>FPGA 时钟设计 1 —— 时钟资源总结</title><link href="http://guqian110.github.io/pages/2014/08/28/the_clock_design_in_fpga_1_summary_of_clock_resource.html" rel="alternate"></link><updated>2014-08-28T22:45:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-08-28:pages/2014/08/28/the_clock_design_in_fpga_1_summary_of_clock_resource.html</id><summary type="html">&lt;p&gt;关于一款芯片，最权威、最新的资料当然是厂家的官方文件。很多大牛都推荐直接阅读原厂的 datasheet 和 user guide。根据我的体验，这确实是最好的途径。原因有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，市面上的书一般都落后业界的步伐，我们看到的很多书上的资料都是过时的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，市面上书（尤其是国内）很多都是简单的翻译手册而来的，而且虽然作者标的是某某大学的教授，事实上都是教授手下的研究生替老师干活翻译的，不能保证翻译的正确性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实验室有的芯片是 Xilinx 的 Virtex-5 系列，Virtex-5 的 User Guide 是 &lt;a href="http://www.xilinx.com/support/documentation/user_guides/ug190.pdf"&gt;UG190&lt;/a&gt;，以下内容都是从中摘抄的笔记。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Three Types of clock resource&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Global Clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为了时钟目的，每个 Virtex-5 系列的器件内部都被分成不同的区域（regions），随着器件的尺寸不同，最小的有 8 个区域，最大的有 24 个区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟资源（Global I/O）和局部时钟资源可以完成所有的复杂的/简单的时钟要求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不推荐使用其他的非时钟资源（比如局部布线资源）来完成时钟功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 Virtex-5 系列的器件都有 32 条全局时钟线 （global clock line），可以驱动片上的所有时序资源（CLB、BRAM、CMTs、I/O），也可以驱动其他的逻辑信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些全局时钟线可以用在任何一个区域中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟线只能由全局时钟缓冲器（global clock buffer）驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器一般由时钟管理块（Clock Management Tile, CMT）驱动，以减少时钟布线延时或者调整和另外一个时钟的相对延时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟的个数比 CMTs 多，但是一个 CMT 可以驱动多个全局时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Regional Clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个区域（region）含有 2 个局部时钟缓冲器（regional clock buffer）和 4 个局部时钟树（regional clock tree）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了处于芯片中心列的组（bank）外，一个 Virtex -5 I/O bank 恰好横跨一个区域。大小和区域完全相同的每个组含有 4 个 clock-capable 的时钟输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个输入可以差分驱动或单端驱动同一组或区域中的四个 I/O 时
钟（I/O clocks）和两个区域时钟（regional clock）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;I/O clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第三种时钟资源是 I/O clocks，可以达到非常高的速度，用于局部的 I/O 串行器/解串器。
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Global Clocking Resources&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全局时钟（global clocks）是个专用网络，是专为覆盖对 FPGA 中各种资源的所有时钟输入设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟资源包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Global Clock Inputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Global Clock Buffers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Tree and Nets-GCLK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Regions&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Global Clock Inputs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 FPGA 包含专用的全局时钟输入位置，这些输入位置即使不用作时钟输入，也可用作常规用户 I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个器件有 20 个全局时钟输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟输入可以按任意 I/O 标准配置，包括差分 I/O 标准。每个时钟输入可以是单端输入，也可以是差分输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Global Clock Input Buffer Primitives&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IBUFG，单端输入全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IBUFGDS，差分输入全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Global Clock Buffers&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个 Virtex-5 器件有 32 个全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每半个晶片 （上半 / 下半）包含 16 个全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器允许各种时钟源 / 信号源接入全局时钟树和网。可以输入全局时钟缓冲器的源包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Global clock inputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Management Tile (CMT) outputs including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Digital Clock Managers (DCMs)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phase-Locked Loops (PLLs)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Other global clock buffer outputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;General interconnect&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器只能由同半个晶片 （上半 / 下半）中的源驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是，在一个时钟区域中仅能驱动十个不同的时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域 （20 个 CLB）是由上十个 CLB 行和下十个 CLB 行组成的时钟树的一个
枝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域仅横跨器件的一半。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Global Clock Buffer Primitives&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BUFGCTRL、BUFG、BUFGCE、BUFGCE_1、BUFGMUX、BUFGMUX_1、BUFGMUX_CTRL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他所有原语均出自 &lt;strong&gt;BUFGCTRL&lt;/strong&gt; 的软件预设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFG&lt;/strong&gt; 全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGCE&lt;/strong&gt; 带有时钟使能（CE）的全局缓冲（BUFG）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGMUX&lt;/strong&gt; 全局时钟选择缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGP&lt;/strong&gt; = IBUFG + BUFG&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGDLL&lt;/strong&gt; 全局缓冲延迟锁相环（舍，被 DCM 代替）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Clock Tree and Nets - GCLK&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 时钟树是为低歪斜和低功耗操作设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何未用分枝都不连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当所有逻辑资源都使用时，时钟树还管理负载 / 扇出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有全局时钟线和缓冲器都以差分形式实现，这有助于大大改善占空比和共模噪声抑制能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Virtex-5 架构中，全局时钟线的引脚接入不仅限于逻辑资源的时钟引脚。全局时钟线不用局部互连即可接入 CLB 中的其他引脚。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Clock Regions&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 器件通过使用时钟区域改善时钟控制分配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个时钟区域最多可有十个全局时钟域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这十个全局时钟可以由 32 个全局时钟缓冲器的任意组合驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;How to use global clock&lt;/h3&gt;
&lt;p&gt;Xilinx 芯片全局时钟资源的使用方法主要有 5 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFG + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最基本的全局时钟资源使用方法，也称为 “ BUFGP 法 ”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFGDS + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当时钟信号为差分形式时，需要用 IBUFGDS 代替 IBUFG&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFG + DCM + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最灵活的使用方法（一般外部提供的时钟都需要倍频、分频、移相等操作以后才可以使用，所以中间需要 DCM）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Logic + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BUFG 的输入可以是普通信号，当某个信号（时钟、使能、快速路径）的扇出非常大、要求抖动延迟最小时，可以使用 BUFG 来驱动这个信号，使这个信号利用全局时钟资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Logic + DCM + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DCM 的输入也可以是普通信号，所以上面的例子中的信号需要倍频、分频等操作时，需要在中间添加 DCM 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在具体使用这些组合方式时，有两种例化方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在设计中直接例化全局时钟资源&lt;/p&gt;
&lt;p&gt;比较简单，按照需求例化上面 5 种组合方式即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在综合阶段/实现阶段通过约束文件的方式实现&lt;/p&gt;
&lt;p&gt;随着综合工具/布局布线工具的不同而变化，大多数综合工具会自动分析时钟信号的扇出数目，在全局时钟资源富裕的情况下，使扇出数目最大的信号自动指定使用全局时钟资源。这时候我们必须保证满足下面的原则，否则会报错。如果不能满足，则必须在约束文件中明确声明该信号不使用全局时钟资源。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;NET&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;CLK&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;CLOCK_DEDICATED_ROUTE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Principle in Using global clock&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原则：&lt;/strong&gt; 使用 IBUFG / IBUFGDS 的必要条件是信号从全局时钟引脚输入。&lt;/p&gt;
&lt;p&gt;也就是说，如果某个信号从全局时钟引脚输入，不管它是否为时钟信号，必须使用 IBUFG/IBUFGDS；如果对某个信号使用了 IBUFG/IBUFGDS，则这个信号必须从全局时钟引脚输入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因：&lt;/strong&gt; 由 Xilinx FPGA 内部结构决定的，IBUFG/IBUFGDS 的输入端仅和芯片的全局时钟引脚有物理连接，与普通的 I/O 和其他内部 CLB 等没有物理连接。&lt;/p&gt;
&lt;h3&gt;P.S. 第二全局时钟资源&lt;/h3&gt;
&lt;p&gt;在看其他资料时，看到一种新的时钟资源 —— 第二全局时钟资源。官方的文档我还没有找到，所以就直接摘抄书上的笔记了 =.=&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第二全局时钟资源属于长线资源，长度和驱动能力仅次于全局时钟资源，也可以驱动芯片内部的任何一个逻辑，抖动和延时仅次于全局时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在设计中，一般将高频率、高扇出的时钟使能信号以及高速路径上的关键信号指定为全局第二时钟信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用全局时钟资源并不占用逻辑资源，也不影响其他布线资源；第二时钟资源占用的是芯片内部的资源，占用部分逻辑资源，各个部分的布线会相互影响，所以建议在设计中逻辑占用资源不超过70%时使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在约束编辑器中的专用约束Misc选项中，指定所选信号使用低抖动延迟资源“Low Skew”来指定，也可以在ucf文件中添加“USELOWSKEWLINES"约束命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;NET&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; USELOWSKEWLINES;&lt;/span&gt;
&lt;span class="n"&gt;NET&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; USELOWSKEWLINES;&lt;/span&gt;
&lt;span class="n"&gt;NET&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;s3&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; USELOWSKEWLINES;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Regional Clocking Resources&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;区域时钟网络是一组独立于全局时钟网络的时钟网络。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与全局时钟不同，区域时钟信号 (BUFR) 的跨度限于三个时钟区域，而 I/O 时钟信号只驱动一个区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 时钟控制资源和网络由以下通路和组件构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Clock Capable I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O Clock Buffer (BUFIO)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Regional Clock Buffer (BUFR)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Regional Clock Nets&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Clock Capable I/O&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;典型时钟区域中有四个 clock-capable I/O 引脚对 （中心列有例外）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有些全局时钟输入也是 clock capable I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个组中有四个专用 clock capable I/O 区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当用作时钟输入时，clock-capable 引脚可以驱动 BUFIO 和 BUFR。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些引脚不能直接连接到全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;I/O Clock Buffer - BUFIO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I/O 时钟缓冲器 (BUFIO) 是可以在 Virtex-5 器件中使用的一种时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 驱动 I/O 列内一个独立于全局时钟资源的专用时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 只能由位于同一时钟区域的 clock capable I/O 驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型的时钟区域中有四个 BUFIO。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 不能驱动逻辑资源 （CLB、Block RAM 等），因为 I/O 时钟网络只能覆盖同一组或时钟区域内的 I/O 列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFIO Primitive&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUFIO 其实就是一个时钟输入和时钟输出缓冲器。输入与输出之间有一个相位延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Regional Clock Buffer - BUFR&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;区域时钟缓冲器 (BUFR) 是可以在 Virtex-5 器件中使用的另一种时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFR 将时钟信号驱动到时钟区域内一个独立于全局时钟树的专用时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 BUFR 可以驱动其所在区域中的四个区域时钟和相邻区域 （最多三个时钟区域）中的四个时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与 BUFIO 不同，BUFR 不仅可以驱动其所在时钟区域和相邻时钟区域中的 I/O 逻辑，还可以驱动其中的逻辑资源 （CLB、Block RAM 等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型的时钟区域 （四个区域时钟网络）中有两个 BUFR。中心列没有 BUFR。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFR Primitive&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUFR 是一个具有输入时钟分频功能的时钟输入 / 时钟输出缓冲器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Regional Clock Nets&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;除了全局时钟树和网（global clock trees and nets），Virtex-5 器件还包含区域时钟网（Regional Clock Nets）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些时钟树也是为低歪斜和低功耗操作设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未用分枝都不连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当所有逻辑资源都使用时，时钟树还管理负载 / 扇出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区域时钟网的传播并非遍及整个 Virtex-5 器件，而是仅限于一个时钟区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域包含四个独立的区域时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要接入区域时钟网，BUFR 必须例化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 BUFR 最多可以驱动两个相邻时钟区域中的区域时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Clock Management Technology&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 系列的芯片内部含有的时钟管理模块（Clock Management Tiles，CMTs）可以提供灵活的、高性能的时钟信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 CMT 由 2 个 DCM 和 1 个 PLL 组成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DCM&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DCM 原语有两个：DCM_BASE、DCM_ADV&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCM_BASE 提供基本的功能，比如去歪斜、频率合成、固定相移；DCM_ADV 提供更高级的功能，比如动态重配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个原语都有各自的输入输出端口、属性设置和状态标识&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCM 可以连接到芯片上的其他时钟资源，包括专用时钟 I/O，时钟缓冲器和PLL&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;==================Update (09/12/2014) 看到一篇介绍 DCM 的&lt;a href="http://bbs.eeworld.com.cn/forum.php?mod=viewthread&amp;amp;tid=88967&amp;amp;page=1"&gt;文章&lt;/a&gt;，很有意思=================================&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;About DCM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DCM 的内部是 DLL (Delay Lock Loop) 结构，对时钟偏移量的调节是通过长达延时线形成的。&lt;/p&gt;
&lt;p&gt;DCM 会把输入时钟 &lt;code&gt;clkin&lt;/code&gt; 和 反馈时钟 &lt;code&gt;clkfb&lt;/code&gt; 相比较，调节 &lt;code&gt;clkin&lt;/code&gt; 和 &lt;code&gt;clk_1x&lt;/code&gt; 之间的延时线的数目，直到 &lt;code&gt;clkin&lt;/code&gt; 和 &lt;code&gt;clkfb&lt;/code&gt; 之间的相位差等于所设置的参数 &lt;code&gt;PHASESHIFT&lt;/code&gt;。如果 &lt;code&gt;clk_1x&lt;/code&gt; 和 &lt;code&gt;clkfb&lt;/code&gt; 不相关的话，那么就永远不能锁定了。&lt;/p&gt;
&lt;p&gt;这个从一开始的不等于到等于所花费的时间就是输出时钟锁定的时间，锁定之后，&lt;code&gt;locked&lt;/code&gt; 信号才会变高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DCM 的常用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="dcm_usage" src="/images/the-clock-design-in-fpga-1-summary-of-clock-resource/dcm_usage.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;将其输出 &lt;code&gt;clk_1x&lt;/code&gt; 连接到 &lt;code&gt;BUFG&lt;/code&gt; 的输入，通过 BUFG 之后的输出一条支路是反馈到 DCM 的反馈时钟引脚 &lt;code&gt;clkfb&lt;/code&gt; 上，另外一条支路则输出驱动其他单元。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DCM 消除 skew&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;DCM 的输出开始走线到达寄存器，这段路程导致的 skew 是永远存在的，DCM 为什么可以消除呢？&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为说明方便起见,我们将BUFG的输出引脚叫做 &lt;code&gt;clk_o&lt;/code&gt;,从 clk_o 走全局时钟布线到寄存器时叫做 &lt;code&gt;clk_o_reg&lt;/code&gt;,从 clk_o 走线到 DCM 的反馈引脚 CLKFB 上时叫 &lt;code&gt;clkfb&lt;/code&gt;,如上图所示。实际上 clk_o, clk_o_reg, clkfb 全部是用导线连在一起的。&lt;/p&gt;
&lt;p&gt;所谓时钟 skew,指的就是 clk_o 到 clk_o_reg 之间的延时。如果打开 FPGA_Editor 看底层的结构,就可以发现虽然 DCM 和 BUFG 离得很近,但是从 clk_o 到 clkfb 却绕了很长一段才走回来,从而导致从 clk_o 到 clk_o_reg 和 clkfb 的延时大致相等。&lt;/p&gt;
&lt;p&gt;总之就是 clk_o_reg 和 clkfb 的相位应该相等。所以当 DCM 调节 clkin 和 clkfb 的相位相等时,实际上就调节了 clkin 和 clk_o_reg 相等。而至于 clk_1x 和 clk_o 的相位必然是超前于 clkin, clkfb, clk_o_reg 的,而 clk_1x 和 clk_o 之间的延时就很明显,就是经过那个 BUFG 的延迟时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;对时钟 skew 的进一步讨论&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后,说一说时钟 skew 的概念。&lt;/p&gt;
&lt;p&gt;时钟 skew 实际上指的是时钟驱动不同的寄存器时,由于寄存器之间可能会隔得比较远,所以时钟到达不同的寄存器的时间可能会不一样,这个时间差称为 &lt;code&gt;时钟 skew&lt;/code&gt; 。这种时钟 skew 可以通过 &lt;code&gt;时钟树&lt;/code&gt; 来解决,也就是使时钟布线形成一种树状结构,使得时钟到每一个寄存器的距离是一样的。很多 FPGA 芯片里就布了这样的时钟树结构。也就是说,在这种芯片里,时钟 skew 基本上是不存在的。&lt;/p&gt;
&lt;p&gt;说到这里,似乎有了一个矛盾,既然时钟 skew 的问题用时钟树就解决了,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;那么为什么还需要 DCM + BUFG 来解决这个问题？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外,既然时钟skew指的时时钟驱动不同寄存器之间的延时,那么上面所说的 clk_o 到 clk_o_reg 岂非不能称为时钟 skew？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先说后一个问题。在一块 FPGA 内部,时钟 skew 问题确实已经被 FPGA 的时钟方案树解决,在这个前提下 clk_o 到 clk_o_reg 充其量只能叫做 &lt;code&gt;时钟延时 delay&lt;/code&gt;,而不能称之为时钟skew。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于第一个问题，个人不认同原博主的答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可惜的是FPGA的设计不可能永远只在内部做事情,它必然和外部交换数据。例如从外部传过来一个32位的数据以及随路时钟,数据和随路时钟之间满足建立保持时间关系(Setup Hold time),你如何将这32位的数据接收进来？如果你不使用DCM,直接将clkin接在BUFG的输入引脚上,那么从你的clk_o_reg就必然和clkin之间有个延时,那么你的clk_o_reg还能保持和进来的数据之间的建立保持关系吗？显然不能。相反,如果你采用了DCM,接上反馈时钟,那么clk_o_reg和clkin同相,就可以利用它去锁存进来的数据。可见,DCM
+ BUFG的方案就是为了解决这个问题。而这个时候clk_o到clk_o_reg的延时,我们可以看到做内部寄存器和其他芯片传过来的数据之间的时钟skew。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为这个答案有两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;外部数据和芯片不同源，算是异步问题，应该用同步化来解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随路失踪一般不驱动芯片的整个时钟网络。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，我认为答案应该是：&lt;/p&gt;
&lt;p&gt;要使用全局时钟网络，必须通过 BUFG 才行，所以才会用到 BUFG；而之所以用到 DCM 是因为它可以实现时钟的闭环控制，而且可以把时钟映射到 PCB 上，用于同步外部芯片，减少了对外部芯片的要求，将时钟控制一体化，利于系统设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果在一片 FPGA 中使用两个 DCM，需要注意两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置 DCM 使用的时钟输入 &lt;code&gt;clk_in&lt;/code&gt; 是源自 FPGA 内部的，此时不能直接连接引脚的信号，需要加入缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应该手动例化一个 IBUFG，然后把 IBUFG 的输出连接到两个 DCM 的输入端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果没有这么做，而是完全按照单个 DCM 的流程使用，那么因为时钟引脚和两个 DCM 的路径长短不同，无法做到输入时钟、两个 DCM 的输出信号的相位对齐，输入时钟只能和其中一个对其，如果对相位有要求，则必须手动调整 DCM 在芯片中的位置。&lt;/p&gt;
&lt;h3&gt;PLL&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 芯片最多包含了 6 个 CMT 模块，每个 CMT 模块包含一个 PLL，PLL 主要用来广谱频率的合成，并且与 DCM 配合最为外部/内部时钟的抖动滤波器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PLL 也有两个原语：PLL_BASE、PLL_ADV&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PLL_BASE 提供基本的功能，比如时钟去歪斜、频率合成、精确相移、占空比调整；PLL_ADV 提供更高级的功能，比如时钟切换、动态重配置等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MMCM&lt;/h3&gt;
&lt;p&gt;不同系列的芯片内部的时钟管理模块是不同的，比如在 Virtex-5 系列后的芯片就含有了 混合模式时钟管理器 MMCM 。&lt;/p&gt;
&lt;p&gt;具体实现时该如何选择 DCM、DLL、PLL、MMCM ？找到一篇介绍 Xilinx 时钟资源的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ednchina.com/ART_8800512846_18_20010_TA_25f01c24.HTM"&gt;如何正确使用FPGA的时钟资源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Other Tips&lt;/h2&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般来说，外部提供的时钟信号都需要进行倍频/分频才可以使用，这时候需要组合各种时钟缓冲器和 DCM、PLL 等模块，我们有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;代码中例化原语，手动组合各种时钟缓冲器和 DCM、PLL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 IP core 向导，创建时钟管理器（可以发现 IP core 生成的代码就是上面 5 种组合方式）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;个人感觉使用第二种方法应该更加简洁、方便，不容易出错吧。（如果在代码中没有明确声明使用buffer，ISE 综合属性、IP core 属性设置里面默认会给所有的输入输出自动加上缓冲器）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对 FPGA 设计而言，全局时钟是最简单最可预测的时钟，最好的时钟方案是：由专用的全局时钟输入引脚驱动单个全局时钟，并用后者去控制设计中的每个触发器。全局时钟资源是专用布线资源，存在与全铜布线层上，使用全局时钟资源不影响芯片的其他布线资源，因此在可以使用全局时钟的时候尽可能使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;虽然各个芯片都不尽相同，但是了解相关的基本知识有利于我们快速掌握芯片的时钟资源、快速上手。&lt;/p&gt;
&lt;p&gt;Xilinx 的所有器件上的时钟资源可以分为前面说的 3 类：全局时钟（global clock）、局部时钟（regional clock）、I/O 时钟（I/O clock），但是不同的器件内部含有的时钟管理模块是不同的，具体到每一款芯片，应该以对应的 User Guide 为准。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.xilinx.com/support/documentation/user_guides/ug190.pdf"&gt;Virtex 5 User Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发使用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ednchina.com/ART_8800512846_18_20010_TA_25f01c24.HTM"&gt;如何正确使用FPGA的时钟资源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.eeworld.com.cn/forum.php?mod=viewthread&amp;amp;tid=88967&amp;amp;page=1"&gt;FPGA DCM时钟管理单元的理解&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="clock resource"></category></entry><entry><title>Verilog 中的参数化建模</title><link href="http://guqian110.github.io/pages/2014/07/09/parameterization_modeling_in_veriog.html" rel="alternate"></link><updated>2014-07-09T23:03:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-07-09:pages/2014/07/09/parameterization_modeling_in_veriog.html</id><summary type="html">&lt;p&gt;和写软件程序一样，我们也希望 Verilog 的模块也可以重利用。要使模块可以重复利用，关键就在于避免硬编码(hard literal)，使模块参数化。&lt;/p&gt;
&lt;p&gt;参数化建模的好处是可以使代码清晰，便于后续维护和修改。&lt;/p&gt;
&lt;p&gt;Verilog 的参数化建模是有一定限制的，它的参数值是编译时计算的，不会引入任何实际的硬件电路。参数必须在编译时确定值。也就是说只能达到动态编译，固态运行，而非软件的动态编译，动态运行。&lt;/p&gt;
&lt;p&gt;这主要是因为它是描述(Description)硬件的语言，而非软件设计(Design)语言。&lt;/p&gt;
&lt;p&gt;比如一个计数器，我们可以设置一个参数来指定它的计数周期(动态编译)，但是这个计数周期在综合之后就是固定值了(固态运行)，不能在运行的时候动态地改为另外一个值(除非电路综合时同时产生了多个计数器，这种情况不算真正意义上的动态运行，而且也达不到真正意义上的动态运行，因为不可能把所有可能的计数器都实现了备用，耗费资源而且没有实际意义)。&lt;/p&gt;
&lt;p&gt;参数化建模的主要目的是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提高模块的通用性，只需要修改参数，不用修改其他代码就可以适用于不同的环境中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下我找到的资料，具体的参数化建模方法一共就 3 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;`define&lt;/code&gt; 宏定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;parameter&lt;/code&gt; 模块参数化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;`ifdef&lt;/code&gt; 等 条件编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面详细说明&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Define Macro Substitution&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;`define&lt;/code&gt; 是编译器指令，功能是全局宏定义的文本代替。它类似于 C 语言中的 &lt;code&gt;#define&lt;/code&gt;，用法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// define&lt;/span&gt;
&lt;span class="cp"&gt;`define     WORD_REG    reg     [31:0]&lt;/span&gt;

&lt;span class="c1"&gt;// using&lt;/span&gt;
&lt;span class="no"&gt;`WORD_REG&lt;/span&gt;   &lt;span class="n"&gt;reg32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;`define 定义的宏的作用域是全局的，这种机制会导致两个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可能会有在不同文件中发生重定义的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译顺序有要求 file-order dependent，必须确保使用前，宏定义有效，所以每个使用到宏定义的源文件必须包含这个头文件，这会导致多重包含的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于第一个问题，尽可能把所有的宏定义放在同一个头文件中，比如 "global_define.vh"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于第二个问题，和 C++ 类似，头文件应该使用头文件保护符。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// global_define.vh head file&lt;/span&gt;
&lt;span class="no"&gt;`ifndef&lt;/span&gt; &lt;span class="no"&gt;GLOBAL_DEFINE_VH&lt;/span&gt;
&lt;span class="cp"&gt;    `define     MAX = 8&lt;/span&gt;
&lt;span class="cp"&gt;    `define     SIZE = 4&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="no"&gt;`enif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Guideline&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于那些只限于模块内的常量，不要使用 define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 &lt;code&gt;`undef&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Parameter&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Parameter&lt;/h3&gt;
&lt;p&gt;应该避免硬编码设计 &lt;code&gt;hard literal&lt;/code&gt;，使用参数 &lt;code&gt;parameter&lt;/code&gt; 来代替。举个例子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// use parameter&lt;/span&gt;
&lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="no"&gt;MAX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;      &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// DO NOT use hard literal&lt;/span&gt;
&lt;span class="k"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;     &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Localparam&lt;/h3&gt;
&lt;p&gt;Verilog-2001 中添加了一个新的关键字 &lt;code&gt;localparam&lt;/code&gt;，用来定义模块内部的、不能被其他模块修改的局部常量，概念类似于 C++ 中 class 的 protect 成员。&lt;/p&gt;
&lt;p&gt;虽然 localparam 不能被外部模块修改，但是它可以用 parameter 来初始化。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;  &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;localparam&lt;/span&gt; &lt;span class="n"&gt;N1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Parameter Redefinition&lt;/h3&gt;
&lt;p&gt;在 Verilog-2001 出现之前，Verilog-1995 中只有两种方法实现参数重定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 # 符号，顺序列表重定义&lt;/li&gt;
&lt;li&gt;使用 defparam&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;逐个讨论&lt;/p&gt;
&lt;h4&gt;1. Uisng &lt;code&gt;#&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个栗子，模块 myreg&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;myreg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;Trst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;Tclk&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在上一层的模块中传递参数例化这个模块&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt;  &lt;span class="nf"&gt;bad_warpper&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;// legal parameter passing&lt;/span&gt;
    &lt;span class="n"&gt;myreg&lt;/span&gt;   &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// illegal parameter passing&lt;/span&gt;
    &lt;span class="c1"&gt;// myreg #(,,8) r1(.q(q), .d(d), .clk(clk), .rst(rst) );&lt;/span&gt;
&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然每次例化都要说明所有的参数值，但是比第二种方法好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次例化都要说明所有的参数值。&lt;/p&gt;
&lt;h4&gt;2. Using &lt;code&gt;defparam&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;defparam&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比如在上面的例子中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;defparam&lt;/span&gt;    &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以放在任何文件的任何地方，不用再重复没有修改的参数值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 defparam 有这么 "强" 的功能，反而会导致一系列的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Hierarchical deparam. &lt;/p&gt;
&lt;p&gt;比如顶层模块使用 defparam 修改子模块的参数，子模块中又使用 defparam 修改顶层模块要传递进来的参数，形成一个环，这样子可能导致综合时不提示错误，但是结果与预期不符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multiple defparams&lt;/p&gt;
&lt;p&gt;在 单个文件 / 多个文件 中重复定义 defparam，会有微妙的问题，Verilog-1995 中没有定义这种现象，实际结果依赖于使用的综合工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为 defparam 有这么多缺点，所以在 2001 年之前，Synopsys 是不支持 defparam 的，网上很多转载的博客都说 defparam 是不可综合的，实际上在后来，Synopsys 在压力之下添加了对其的支持。而我用 XST 也证明是支持 defparam 可综合。&lt;/p&gt;
&lt;p&gt;综上原因，Verilog Standards Group (VSG) 倡议大家抵制使用 defparam，大神 Clifford E. Cummings 在论文中建议综合工具如果用户坚持使用 defparam 语句，必须添加以一个参数 &lt;code&gt;+Iamstupid&lt;/code&gt;...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"The Verilog compiler found a defparam statement in the source code at
(file_name/line#).
To use defparam statements in the Verilog source code, you must include the switch
+Iamstupid on the command line which will degrade compiler performance and introduce
potential problems but is bug-compatible with Verilog-1995 implementations.
Defparam statements can be replaced with named parameter redefinition as define by
the IEEE Verilog-2001 standard."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;总结一下，可以发现 Verilog-1995 中的两种方法都不怎么好，显然 VSG 也发现了这个问题，所以在 Verilog-2001 中，出现了第三种方法，并且墙裂推荐使用这种新方法。&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;3. Using named parameter redefinition&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似于模块例化时端口连接的方式，比如上例中只想改变 SIZE 的值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;myreg&lt;/span&gt;   &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合了前两种方法的有点，既显示说明了哪个参数值改变了，也将参数传递放在了实例化的语句中。这种方法是最干净的 (cleanest) 方法，不依赖于任何综合工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;貌似没有～&lt;/p&gt;
&lt;h3&gt;Guideline&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;不要使用 defparam，应该使用 named parameter redefinition。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;clock cycle definition&lt;/p&gt;
&lt;p&gt;因为时钟是一个设计中最基本的常量，它不会在随着模块变化，所以应该用 &lt;code&gt;`define&lt;/code&gt; 来定义，并且将它放在顶层的头文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FSM&lt;/p&gt;
&lt;p&gt;在一个设计中可能有不止一个 FSM，而通常 FSM 有一些共同的状态名字，比如 IDLE、READY、READ、WRITE、ERROR、DONE 等，所以应该用 &lt;code&gt;localparam&lt;/code&gt; 来定义这些常量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Conditional Compilation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Verilog 的条件编译和 C 也十分类似。前面介绍 define 时，已经用到了条件编译中的 &lt;code&gt;`ifdef&lt;/code&gt;。条件编译一共有 5 个关键字，分别是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;ifdef&lt;/span&gt;  &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;   &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;elsif&lt;/span&gt;  &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;endif&lt;/span&gt;  &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;ifndef&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;条件编译一般在以下情况中使用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择一个模块的不同部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择不同的时序和结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择不同的仿真激励&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// example1&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example2&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example3&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`elsif&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example4&lt;/span&gt;
&lt;span class="no"&gt;`ifndef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;条件编译是一个非常好的技术，它可以帮助我们更好的管理代码。&lt;/p&gt;
&lt;p&gt;举个栗子，比如我们写了一个程序，在 debug 阶段，在程序中添加了很多显示中间变量的语句，到最后 release 时，当然要去掉这些语句。最差的方法当然是删掉这些代码，但是如果以后我们还想 debug 时，又得手动写，而且时间长了，我们自己都记不清该加哪些语句了。稍微好点的方法是把它们注释起来，但是同样，时间长了，哪些该注释，那些不该注释又混淆了。最好的方法就是用条件编译。我们可以定义一个宏 DEBUG&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;DEBUG&lt;/span&gt;

&lt;span class="c1"&gt;// conditional compilation&lt;/span&gt;
&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;ifdef&lt;/span&gt; &lt;span class="n"&gt;DEBUG&lt;/span&gt;
    &lt;span class="c1"&gt;// debug&lt;/span&gt;
&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="c1"&gt;// release&lt;/span&gt;
&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，我们只需要选择是否注释第一行的宏定义就可快速在 debug 和 release 之间切换。&lt;/p&gt;
&lt;p&gt;再比如在 Verilog 的模块中，针对不同的应用环境，我们要实现不同的模块，这时候也可以使用条件编译选择具体综合哪段代码。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;总结一下，就是一下几点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于那些只限于模块内的常量，不要使用 define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 &lt;code&gt;`undef&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 defparam，应该使用 named parameter redefinition。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要时使用条件编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;IEEE Std 1364-1995&lt;/p&gt;
&lt;p&gt;IEEE Std 1364-2001&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsHDLCON2002_Parameters_rev1_2.pdf"&gt;New Verilog-2001 Techniques for Creating Parameterized Models&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/oomusou/archive/2008/07/09/verilog_parameter.html"&gt;(原创) 如何使用参数式模组? (SOC) (Verilog) (C/C++) (template)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.chinaaet.com/detail/14875"&gt;艾米电子 - 参数与常量，Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eefocus.com/ilove314/blog/2012-03/231583_52a1d.html"&gt;Verilog代码可移植性设计&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="parameterization"></category></entry><entry><title>FPGA 数字处理基础 (2)</title><link href="http://guqian110.github.io/pages/2014/07/07/fpga_digital_processing_basic_2.html" rel="alternate"></link><updated>2014-07-07T23:28:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-07-07:pages/2014/07/07/fpga_digital_processing_basic_2.html</id><summary type="html">&lt;p&gt;讨论 FPGA 中无符号数 unsigned 和有符号数 signed 的问题。&lt;/p&gt;
&lt;h2&gt;Basic Knowledge&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;整数的分类：&lt;/strong&gt; 无符号数 &lt;code&gt;unsigned&lt;/code&gt; 和 有符号数 &lt;code&gt;signed&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数制：&lt;/strong&gt; 10、2、8、16 进制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器数：&lt;/strong&gt; 机器数的意思是数字在机器中的表示方式。主要有 3 种&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原码 sign-magnitude&lt;/code&gt;、&lt;code&gt;反码 one's complement&lt;/code&gt;、&lt;code&gt;补码 two's complement&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以前写过的一篇总结： &lt;a href="http://guqian110.github.io/pages/2014/03/19/signed_number_representations.html"&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机系统：&lt;/strong&gt; 采用二进制、补码系统。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;FPGA 中是如何表示数字的呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以前写过一篇总结，&lt;a href="http://guqian110.github.io/pages/2014/05/14/fpga_digital_processing_basic_1.html"&gt;FPGA 数字处理基础 (1)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文算是上面文章的续吧。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;(un)signed in Verilog&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Integer&lt;/h3&gt;
&lt;p&gt;在 Verilog 中表示一个整数可以有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;简单的数字&lt;/p&gt;
&lt;p&gt;即只有简单的数字，默认为有符号数。比如 8, -10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数表示法 &lt;code&gt;&amp;lt;size&amp;gt;'&amp;lt;s&amp;gt;&amp;lt;base&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中，size 指定需要多少位表示这个数字，有 s 表示这个数为有符号数，没有则表示这个数是无符号数，base 指定后面的 value 是使用哪种基数来描述，value 制定这个数字的大小。默认为无符号数，除非声明 s 字段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在 FPGA 也采用补码系统&lt;/strong&gt;，即在综合时，综合工具会将有符号数翻译为补码，在硬件中存储起来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d5&lt;/span&gt;   &lt;span class="c1"&gt;// 这个数为无符号数，理解为 5, 占用 8 bit，存储的值为 0101&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd5&lt;/span&gt;  &lt;span class="c1"&gt;// 这个数为有符号数，理解为 5, 占用 8 bit，存储的值为 0101&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d5&lt;/span&gt;  &lt;span class="c1"&gt;// 这个数为无符号数，理解为 -5, 占用 8 bit，存储的值为 1011&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="n"&gt;sd5&lt;/span&gt; &lt;span class="c1"&gt;// 这个数为有符号数，理解为 -5, 占用 8 bit，存储的值为 1011&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Register&lt;/h3&gt;
&lt;p&gt;Verilog 中数据的基本类型： &lt;code&gt;wire&lt;/code&gt;、&lt;code&gt;reg&lt;/code&gt;、&lt;code&gt;integer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 Verilog-1995 中，规定所有的 wire、reg 都是 unsigned 类型，只有 integer 是 signed 类型。但是 integer 的宽度是固定的(与宿主机的字是一样的，最小为 32 位)，这样子，造成了很大的不方便和浪费。&lt;/p&gt;
&lt;p&gt;在 Verilog-2001 中，添加了 wire、reg 也可以是 signed 类型了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据可以是 signed 和 unsigned，寄存器也可以是 signed 和 unsigned，那么综合时，是以哪个为准呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题一开始自己没有搞清楚，迷惑了一下午，后来写了几个小测试程序，最后发现这个结论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;以变量类型为准&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;即 reg/wire 为哪种，那么综合时就以这个为标准进行综合。比如当 reg 为 unsigned 类型，当我们给它赋值为 signed 类型的数据 &lt;code&gt;-5&lt;/code&gt;(&lt;code&gt;-4’d5&lt;/code&gt;) 时，综合出来的结果为 reg 存储的是 &lt;code&gt;-5&lt;/code&gt; 的补码 &lt;code&gt;1011&lt;/code&gt;,但是解释为 unsigned 类型的 &lt;code&gt;+11&lt;/code&gt;。这时候就结果和我们的预期是不一样的，出现了误差，一定要注意！另一种情况类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果参与运算的变量混合有 signed 和 unsigned 类型，那么会将 signed 转换为 unsigned 类型。(应该避免这种情况)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;=========================================以下为详细的分类讨论==================================&lt;/p&gt;
&lt;p&gt;编写一个简单的测试程序，查看综合结果和仿真波形，就可以知道综合时的策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;module: &lt;a href="http://guqian110.github.io/files/test_signed.v"&gt;test_signed.v&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;testbench: &lt;a href="http://guqian110.github.io/files/tb_test_signed.v"&gt;tb_test_signed.v&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;1. unsigned reg &amp;amp; unsigned value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 unsigned 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;赋值为 unsigned 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么可以从 RTL Schematic 中看到，综合出来的比较器是 unsigned 类型。&lt;/p&gt;
&lt;h4&gt;2. unsigned reg &amp;amp; signed value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 unsigned 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;赋值为 signed 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么综合出来的比较器是 unsigned 类型。&lt;/p&gt;
&lt;h4&gt;3. signed reg &amp;amp; signed value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 signed 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;赋值为 signed 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么综合出来的比较器是 signed 类型。&lt;/p&gt;
&lt;h4&gt;4. signed reg &amp;amp; unsigned value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 signed 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;赋值为 unsigned 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么综合出来的比较器是 signed 类型。&lt;/p&gt;
&lt;h4&gt;5. signed reg &amp;amp; unsigned reg&lt;/h4&gt;
&lt;p&gt;如果参与运算的两个变量一个是 signed，另一个是 unsigned。（注意这种现象应该避免，一般我们是不会将两种不同类型的数据混在一起进行计算的）&lt;/p&gt;
&lt;p&gt;定义 i 为 unsigned 类型，flag 为 signed 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;给 flag 赋值为 signed 的 -5&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// sigend&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;综合出来的比较器为 unsigned 类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 变量 integer 也是也可综合的。在上例中，如果将 flag 的类型改为 integer 也是可综合的，但是，因为只用到了低 8 位，所以在综合时会提示高 24 位是未连接 unconnected，但是因为 integer 是一个整体，所以即使未连接也不能优化掉，这就是在 Verilog-1995 中 integer 不够灵活的体现，好在 Verilog-2001 中已经添加了支持 reg/wire 为 signed 的类型，而且综合工具(XST)也是支持的。&lt;/p&gt;
&lt;p&gt;=======================================分割线结束==========================================&lt;/p&gt;
&lt;p&gt;以前只知道硬件上最基本的一些运算单元，比如加法器(adder)、减法器(subtractor)、比较器(comparator) 等，完成的功能是固定的，电路是不会检查输入数据的类型的。涉及到 signed 和 unsigned 类型，就出现一个问题：对于基本运算单元(比如加法器)，运算单元并不知道输入的数据是哪种数据，对于 unsigned 和 signed 类型，必然出现适合一种时不适合另外一种的问题。&lt;/p&gt;
&lt;p&gt;所以可以推断出 &lt;strong&gt;对于不同的数据类型，同样是个加法器，底层的硬件电路是不一样的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果我在程序中定义了 signed 和 unsigned 类型的数据，那么综合工具是否足够智能，能够根据数据的类型综合出正确适合的电路？&lt;/p&gt;
&lt;p&gt;答案是肯定的，即&lt;strong&gt;综合器足够智能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上面的程序证明了这一点，从 RTL 图中可以看到综合出的比较器是 signed 还是 unsigned 类型，仿真波形也可以看到，最终下载到板子上测试也符合预期。这些都证明 综合器足够智能。后来看到 &lt;a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/xst.pdf"&gt;UG627(v14.5): XST User Guide&lt;/a&gt;，才发现里面已经非常清楚地写着&lt;/p&gt;
&lt;p&gt;Chapter 3: Signed and Unsigned Support in XST&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When using Verilog or VHDL in XST, some macros, such as adders or counters, can be
implemented for signed and unsigned values.
To enable support for signed and unsigned values in Verilog, enable Verilog-2001
as follows:
+ ISE® Design Suite
  Select Verilog 2001 as instructed in the Synthesis Options topic of ISE Design Suite
Help
+ XST Command Line
  Set -verilog2001 to yes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;花费了大量时间上网找资料，在论坛里问别人无果，最后自己动手写程序测试，最后才发现原来官方资料里面早就写的清清楚楚 =.=&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;说了这么多，总结下来就是下面这几句话：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经验：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;遇到问题，先不要急着上网求助，上网求助这个方法虽然简单，但是是最不好的，一方面别人的话不一定可靠，另一方面，放弃思考直接上网求助对学习无益。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找资料的技巧很重要。虽然我大概能够猜测到 Xilinx 官方的文档中肯定有说明，但是就是懒得去下载文档，再去找。认为网上肯定有人也有相同的困惑，所以直接 Google。结果找到一堆没有帮助的网页，浪费了时间，最后还是要看文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实践是检验真理的唯一标准，到底行不行，写测试程序，在板子上跑跑，验证一下是最有力的证明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Verilog-2001 已经支持 signed 类型的 wire 和 reg，所以我们代码中如果涉及到有符号数，那么像 C 语言一样直接定义、赋值、使用即可，综合工具会综合出正确的有符号数的运算电路。不必再像以前一样手动进行补码转换，自己来处理有符号数的补码计算的细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合时的原则是按照寄存器的类型进行综合(即上面的分类讨论的结论)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仔细对比 signed 和 unsigned 类型的综合结果，可以发现 Technology Schematic 是一样的，之所以和 “理论上硬件电路是应该不一样” 矛盾，我认为原因在于 FPGA 的实现是基于查找表的。以上面的例子来说明，这个比较器的功能最终是在一个 LUT6 的查找表上实现的，所以，ASIC 上硬件电路的不同映射到 FPGA 中就是 LUT 的内容不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="FPGA"></category><category term="digital processing"></category></entry><entry><title>Sublime Text 2 和 Verilog HDL</title><link href="http://guqian110.github.io/pages/2014/07/04/sublime_text_2_and_verilog.html" rel="alternate"></link><updated>2014-07-04T23:31:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-07-04:pages/2014/07/04/sublime_text_2_and_verilog.html</id><summary type="html">&lt;h2&gt;Sublime Text&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;代码编辑器之于程序员，就如同剑之于战士。程序员关于代码编辑器的争论从来就没有停止过，每个程序员都有自己熟悉的编辑器，他们热爱自己的 “武器”，甚至可以形成 “宗教”，比如 Vim 和 Emac 的战争。&lt;/p&gt;
&lt;p&gt;如今，这个无休止的争论中要加入一个新成员了，她就是 &lt;a href="http://www.sublimetext.com/"&gt;Sublime Text&lt;/a&gt; 。其实她也不是 “新” 成员了，早在 2011 年她就诞生了，不过经过不断的改进，终于人们不得不正视这个新人，不仅仅因为漂亮的外在美，还有强大的内在美 :-P&lt;/p&gt;
&lt;p&gt;个人感觉，ST 的出现恰到好处，她兼具了 Vim 的强大功能和普通编辑器的易用性。虽然 Vim 轻巧、强大，但是 Vim 的门槛比较高，要想用好 Vim 是需要长期练习的，而 ST 可以说是老少皆宜，你是小白，不会用 Vim？没关系，她可以像普通的编辑器一样，即使你 0 基础也可以使用；你是老手，习惯 Vim？也没关系，她可以 &lt;strong&gt;开启 Vim 模式&lt;/strong&gt;，还是原来的配方，还是熟悉的味道～&lt;/p&gt;
&lt;p&gt;虽然她不是开源项目，有收费，但是我们有免费无限制无限期的试用权，而且她绿色小巧，不用安装，解压即可使用，跨平台，支持各种编程语言的代码补全和语法高亮。如果对现有的插件不满意，我们甚至可以自己定制插件。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;简单说一下我在使用过程中的一些问题，更加详细的使用官方和非官方的网站上都有详细的说明，还有别人总结的技巧请自行 Google。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.sublimetext.com/docs/2/index.html"&gt;Official docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/sublime-text-2/"&gt;Unofficial docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.iplaysoft.com/sublimetext.html"&gt;Others: Sublime Text 2 - 性感无比的代码编辑器！程序员必备神器！跨平台支持Win/Mac/Linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P.S. 我使用的是 Sublime Text 2，虽然已经有 3 了，但是 3 还在 Beta 阶段，大家貌似对 3 不是很满意&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Vim Mode&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;ST 是自带 Vim 模式的（Vintage Mode），但是这个模式默认是没有开启的，毕竟对于大多数普通人来说， Vim 实在是不太友好...&lt;/p&gt;
&lt;p&gt;打开 ST 的 &lt;code&gt;Preferences/Setting - Defalut&lt;/code&gt;，在最后一行有句&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;&amp;quot;ignored_packages&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Vintage&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只需要将方括号中的 Vintage 去掉就可以了。推荐在 Setting - User 中修改。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.sublimetext.com/docs/2/vintage.html"&gt;官方说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Package Control&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;ST 的一个强大之处就在于可以安装各种插件，要安装插件有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;手动下载，解压到指定目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 &lt;code&gt;Package Control&lt;/code&gt; 插件，自动管理安装插件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一种方法虽然麻烦，但是在没有网络的环境下，我们可以从别人那拷贝过来即可；第二种方法最方便了，不过要求有网络。&lt;/p&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;ST 默认是没有安装 Package Control 的，需要我们手动安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl ~&lt;/code&gt; 调出控制台&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在控制台中粘贴以下命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Package&lt;/span&gt; &lt;span class="n"&gt;Control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sublime&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sublime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;installed_packages_path&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;makedirs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;None&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;install_opener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build_opener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ProxyHandler&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;wb&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//sublime.wbond.net/&amp;#39;+pf.replace(&amp;#39; &amp;#39;,&amp;#39;%20&amp;#39;)).read()); print &amp;#39;Please restart Sublime Text to finish installation&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装完成之后，重启 ST 即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Using&lt;/h3&gt;
&lt;p&gt;按下 &lt;code&gt;Ctrl + Shift + P&lt;/code&gt;，在弹出的命令面板，输入 &lt;code&gt;package&lt;/code&gt;，就会自动弹出相关的命令，可以选择 &lt;code&gt;Install&lt;/code&gt;、&lt;code&gt;Remove&lt;/code&gt;、&lt;code&gt;Disable&lt;/code&gt;、&lt;code&gt;Enable&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Update&lt;/code&gt; 等命令。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sublime.wbond.net/"&gt;sublime wbond&lt;/a&gt; 上列出了 Package Control 可以找到的所有的插件，有详细的安装和使用说明。&lt;/p&gt;
&lt;p&gt;网上也有很多文章介绍了大量的常用插件，我们可以按照需求自己挑选需要的插件进行安装。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Verilog HDL&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;常用的插件，比如括号匹配、智能补全、自动对齐、Tags、注释生成、Terminal、Build、Git 等插件就不再赘述了，说一下网上介绍的比较少，但我自己使用比较多的关于 Verilog 的插件。&lt;/p&gt;
&lt;p&gt;可以通过 Package 下载到两个插件，&lt;code&gt;Verilog&lt;/code&gt; 和&lt;code&gt;Verilog-Automatic&lt;/code&gt;。第一个插件主要功能是支持 Verilog 的代码高亮和补全，第二个插件可以帮助我们自动生成模块例化、端口添加连接等功能。&lt;/p&gt;
&lt;p&gt;其中，第一个插件的 Snippet 并不太让人满意，在原 Snippet 的基础上，我添加了一些我常用到的 Snippets。&lt;/p&gt;
&lt;h3&gt;always&lt;/h3&gt;
&lt;p&gt;因为插件作者只添加了异步高有效复位方式的 &lt;code&gt;always&lt;/code&gt; 块，而我们同步和异步两种方式都可能会用到，所以，我添加同步复位的 Snippet&lt;/p&gt;
&lt;p&gt;ST 2 的 Package 都存放在 &lt;code&gt;/home/.config/sublime-text-2/Packages&lt;/code&gt; 目录下面，我们需要修改的就是这个目录下的 &lt;code&gt;Verilog/Snippets&lt;/code&gt; 下的 &lt;code&gt;.tmSnippet&lt;/code&gt; 文件。修改后的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;always_async.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always @(posedge clk or ${1:posedge} ${2:rst}) begin
    if ($2) begin
        // reset
        $3
    end
    else if ($4) begin
        $0
    end
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_async&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_async&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;always_sync.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always @(posedge clk) begin
    if (${1:rst}) begin
        // reset
        $2
    end
    else begin
        $0
    end
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_sync&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_sync&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改之后的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="always" src="/images/sublime-text-2-and-verilog/always.gif" /&gt;&lt;/p&gt;
&lt;h3&gt;if-else&lt;/h3&gt;
&lt;p&gt;原来的 if snippet 没有 else 分支，所以，添加了一个有 else 分支的 if 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if ($1) begin
    $0
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;if-else.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if ($1) begin
    $2
end
else begin
    $0
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if_else&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if_else&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改后的结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="if-else" src="/images/sublime-text-2-and-verilog/if-else.gif" /&gt;&lt;/p&gt;
&lt;h3&gt;parameter&lt;/h3&gt;
&lt;p&gt;原来是没有 parameter 的snippets 的，拷贝一份其他的 snippet，修改其中的一些设置，即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parameter.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter   $1 = $2,
            $3 = $0
&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改后的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="parameter" src="/images/sublime-text-2-and-verilog/parameter.gif" /&gt;&lt;/p&gt;
&lt;h3&gt;case&lt;/h3&gt;
&lt;p&gt;原来是没有 case 的 snippet，方法同上，可以修改出我们想要的 case snippet&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;case.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case ($1)
    $2: begin
        $3
    end
    $4: begin
        $5
    end
    $6: begin
        $7
    end
    $8: begin
        $9
    end
    default: begin
        $10
    end
endcase&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改后的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="case" src="/images/sublime-text-2-and-verilog/case.gif" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上面仅仅说了非常基本的几个设置，和我在写 Verilog 时自己添加的几个 snippet，其他的 ST 的使用技巧官方和非官方的 ref 有非常详细的介绍，另外其他人也有很多文章介绍～&lt;/p&gt;</summary><category term="FPGA"></category><category term="Sublime Text"></category></entry><entry><title>FPGA 中的复位设计</title><link href="http://guqian110.github.io/pages/2014/06/20/the_art_of_reset_design_in_fpga.html" rel="alternate"></link><updated>2014-06-20T00:22:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-06-20:pages/2014/06/20/the_art_of_reset_design_in_fpga.html</id><summary type="html">&lt;p&gt;复位信号在系统中的地位和时钟信号几乎同等重要，我们想尽量把系统设计为可控，那么最基本的控制信号就是复位信号了。&lt;/p&gt;
&lt;p&gt;复位信号的设计需要考虑的因素，各种书刊、论文、白皮书、网上论坛都有相关讨论，但是至今对于给定 FPGA 设计中使用哪种复位方案仍然没有明确答案。本文总结了一些大神的经典论文和网上的许多博客，尽可能用简单的图说明选择某种设计方案及其理由，涉及的更深入的原理请自行 Google :-P&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Think Local or Think Global&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Xilinx 有个 White Paper，&lt;a href="http://www.xilinx.com/support/documentation/white_papers/wp272.pdf"&gt;Get Smart About Reset: Think Local, Not Global&lt;/a&gt;，提出一种新的复位思路： 能不用全局复位时，尽量不要使用。&lt;/p&gt;
&lt;p&gt;这个原则和我们平时的理解和习惯是相反的，不使用全局复位的原因主要有三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;随着时钟速率的提高，GSR 逐渐变为时序关键路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果电路中没有反馈环路，那么上电初始化已经足够了，很多设计中的 reset 信号都可以省去&lt;/p&gt;
&lt;p&gt;如果没有反馈环路，比如移位寄存器，即使开始状态是错误的，当数据流进入到一段时间，错误数据将被冲刷出去，所以没有必要保留 reset 信号。如果系统中有反馈环路，比如状态机，当初始状态不对或者状态跑飞时，无法回到正常状态，那么 reset 信号是有必要保留的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码中简单的添加一个 reset 端口，在底层实现时要消耗很多我们想不到的资源。&lt;/p&gt;
&lt;p&gt;全局复位会和设计中的其他单元竞争布线资源，全局复位一般来说肯定有非常高的扇出，因为它需要连接到设计中的每一个 FF。这样，它会消耗大量的布线资源，使芯片利用率下降，同时也会影响时序性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，有必要使用其他的不依靠全局复位的方法。&lt;/p&gt;
&lt;p&gt;如图所示，Xilinx FPGA 在配置/重配置的时候，每个 FF 和 BRAM 都会被初始化一个预先设定的值(大部分器件的默认值是 0, 也有例外)，所以，上电配置和全局复位有着类似的功能，将每个存储单元配置为一个已知的状态。&lt;/p&gt;
&lt;p&gt;&lt;img alt="configuration" src="/images/the-art-of-reset-design-in-fpga/configuration.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;系统在上电配置时，内部有个信号叫 &lt;code&gt;GSR&lt;/code&gt; (Global Set/Reset)，它是一种特殊的预布线的复位信号，能够在 FPGA 配置的过程中让设计保持初始状态。在配置完成后，GSR 会被释放，所有的触发器及其它资源都加载的是 INIT 值。除了在配置进程中运行 GSR，用户设计还可以通过实例化 STARTUP 模块并连接到 GSR 端口的方法来访问 GSR 网。使用该端口，设计可以重新断言 GSR 网，相应地 FPGA 中的所有存储元件将返回到它们的 INIT 属性所规定的状态。&lt;/p&gt;
&lt;p&gt;设定初值的语法很简单，只需要在定义变量时给它初始值就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和 reg 类似，BRAM 也可以在配置的时候初始化，随着嵌入式系统的 BRAM 逐渐增大，BRAM 初始化非常有用：因为预先定义 RAM 的值可以使仿真更容易，而且无需使用引导顺序为嵌入式设计清空内存。&lt;/p&gt;
&lt;p&gt;使用 GSR 的好处是 可以解决复位信号高扇出的问题，因为 GSR 是预布线的资源，它不占用每个 FF 和 Latch 的 set/reset 端口，如下图所示。很多资料都推荐将设计中的 reset 按钮连接到 GSR，以利用它比较低的 skew。&lt;/p&gt;
&lt;p&gt;&lt;img alt="gsr rset" src="/images/the-art-of-reset-design-in-fpga/gsr_reset.gif" /&gt;&lt;/p&gt;
&lt;p&gt;既然 GSR 这么好，那么是不是只使用 GSR 就可以了，不必再用 FF 和 Latch 的 set/reset 端口了呢？&lt;/p&gt;
&lt;p&gt;答案当然是否定的。由于 GSR 的释放是异步方式，所以，如果我们只使用 GSR 作为系统的唯一复位机制，那么可能导致系统不可靠。所以还是需要显示的使用同步复位信号来复位状态机、计数器等能自动改变状态的逻辑。&lt;/p&gt;
&lt;p&gt;所以，应该使用 &lt;strong&gt;GSR + explict reset&lt;/strong&gt; 的解决方案&lt;/p&gt;
&lt;p&gt;给系统中的 reg 赋初值，对于没有环路的电路节省 reset，利用 GSR 实现复位的功能；对于有环路的电路，使用显示的复位信号。&lt;/p&gt;
&lt;h3&gt;Upate: 07/01/2014&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关于 initialize 代替 reset&lt;/p&gt;
&lt;p&gt;这几天看 resest 相关问题时，又在 &lt;code&gt;stackoverflow&lt;/code&gt; 上发现一个关于&lt;a href="http://stackoverflow.com/questions/6363130/is-there-a-reason-to-initialize-not-reset-signals-in-vhdl-and-verilog"&gt;是否应该使用 initialize 代替 reset 的问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;支持用 initialize 代替 reset 的人提出的方案是尽量不要使用全局复位信号，使用初始化值代替复位，对于一些必须要求复位的模块，使用 &lt;em&gt;local&lt;/em&gt; 的复位信号。&lt;/p&gt;
&lt;p&gt;反对者认为，用 initialize 代替 reset 的想法只是学院派的不切实际的想法。一般只有基于 SRAM 的 FPGA 才会使用到初始化。而这样做的目的只是为了节省布线资源，降低时序要求，但是现代 FPGA 有很多布线资源和没有使用的全局网络，所以，复位信号一般不是时序关键路径。即使遇到问题，可以通过手动例化一个时钟 BUF 来解决。使用这种无复位的设计虽然在某些情况是可行的，但是当你把你的设计和其他系统连接起来时，通常会感到非常痛苦，因为大多数系统都会要求有个复位信号。在由 FPGA 转 ASIC 时也比较方便，因为只有基于 SRAM 的 FPGA 才可以使用这种 initialize 代替 reset 的技术，而 ASIC 不行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于 GSR&lt;/p&gt;
&lt;p&gt;网上有很多人都推荐将我们用户定义的复位信号连接到 GSR 信号上，以便利用 GSR 提供的低抖动性，包括下面提到的一篇文章 &lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 也推荐使用 GSR 信号。但是在 Xilinx 的另一份文档 &lt;a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/sim.pdf"&gt;UG626: Synthesis and Simulation Design Guide&lt;/a&gt; 中说不推荐使用 GSR 来作为系统的复位&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although you can access the GSR net after configuration, Xilinx does not recommend using the GSR circuitry in place of a manual reset. This is because the FPGA devices offer high-speed backbone routing for high fanout signals such as a system reset. This backbone route is faster than the dedicated GSR circuitry, and is easier to analyze than the dedicated global routing that transports the GSR signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而这个矛盾早就有人在 Xilinx Forum 上提问了 &lt;a href="http://forums.xilinx.com/t5/Virtex-Family-FPGAs/What-does-GSR-signal-really-mean-and-how-should-I-handle-the/td-p/35610"&gt;What does GSR signal really mean and how should I handle the reset signal properly&lt;/a&gt;，还有 &lt;a href="http://forums.xilinx.com/t5/Archived-ISE-issues/FPGA-Power-On-Reset/m-p/7027?query.id=134602#M2035"&gt;FPGA Power On Reset!&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt; Conclustion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下，应该优先选择有全局复位的设计方案，并且这个全局复位信号是用户定义的，不要使用 GSR 。&lt;/p&gt;
&lt;p&gt;P.S. 事实上没有一个通用的、适合所有器件的复位方案，我们应该首先了解所使用的器件和工具，针对它们的特点进行复位方案的设计。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Shift Register Reset&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;并不是每一个设计，器件中的每一个寄存器都需要复位的。最好的做法是只将复位连接到那些需要复位的寄存器。&lt;/p&gt;
&lt;p&gt;如果一个模块内部含有一组触发器(移位寄存器)，这些寄存器可以分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;resetable flip-flops&lt;/p&gt;
&lt;p&gt;第一个 ff，它是需要复位信号的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;follower flip-flops&lt;/p&gt;
&lt;p&gt;后续的 ff，仅作为简单的数据移位寄存器，不含复位端&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么在设计时应该只复位第一个触发器，后续的触发器仅作为数据寄存器使用，不能对它们进行复位。
这里体现出来的一个原则就是：能节省 reset 时，尽量节省。&lt;/p&gt;
&lt;p&gt;原因就是 reset 作为一个实际存在的物理信号，需要占用 FPGA 内部的 route 资源，往往 reset 的fanout 又多得吓人。这就很容易造成 route 难度上升，性能下降，编译时间增加。因此，在 FPGA 设计中能省略的复位应尽量省略。&lt;/p&gt;
&lt;h3&gt;Principle&lt;/h3&gt;
&lt;p&gt;每个 &lt;code&gt;always&lt;/code&gt; 模块只对一种 FF 建模。也就是说，不要把这两种 FF 写在同一个 always 块中。&lt;/p&gt;
&lt;h3&gt;Code&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Bad Style:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;BADSTYLE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如图，复位信号 &lt;code&gt;rst&lt;/code&gt; 对于第二个 ff 来说，是一个片选信号 &lt;code&gt;ce&lt;/code&gt;，这样的设计产生额外的逻辑，是不好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="bad style" src="/images/the-art-of-reset-design-in-fpga/bad_style.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Good Style:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;GOODSTYLE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如图，复位信号 &lt;code&gt;rst&lt;/code&gt; 对于两个 ff 来说，都是复位信号，不需要额外的逻辑，这样的设计是比较好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="good style" src="/images/the-art-of-reset-design-in-fpga/good_style.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reset Distribution Tree&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;复位信号的 &lt;code&gt;reset distribution tree&lt;/code&gt; 和 时钟信号的 &lt;code&gt;clock distribution tree&lt;/code&gt; 差不多同等重要，因为在设计中，几乎每个器件都有时钟端口和复位端口(同步/异步)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reset distribution tree&lt;/code&gt; 和 &lt;code&gt;clock distribution tree&lt;/code&gt; 最大的区别就是它们对 &lt;code&gt;skew&lt;/code&gt; 的要求不同。不像时钟信号的要求那么严格，复位信号之间的 skew 不需要那么严格，只要复位信号的延迟足够小，满足能在一个时钟周期内到达所有的复位负载端，并且满足各个寄存器和触发器的 &lt;code&gt;recovery time&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下图所示的方案是使用 时钟树 的一个叶子分支来驱动 &lt;code&gt;Reset Synchronizer&lt;/code&gt;。但是，大多数情况下，时钟频率都比较高，叶子分支的时钟无法在一个时钟周期内，既要穿过时钟树，还要驱动 &lt;code&gt;Reset synchroinzer&lt;/code&gt;，然后再将得到的复位信号穿过 复位树，输入到负载端口。&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree driven delayed clock" src="/images/the-art-of-reset-design-in-fpga/reset_tree_delayed_clock.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了加速 reset 信号到达触发器，触发器使用的时钟与 reset 信号是并行的。如图所示。但是，这时候 reset 和 clock 是异步的，所以必须在 &lt;code&gt;PAR&lt;/code&gt; 之后进行 &lt;code&gt;STA&lt;/code&gt;，保证异步复位信号释放(release)和使能(enable)时满足 &lt;code&gt;建立时间(setuo time)&lt;/code&gt; 和 &lt;code&gt;保持时间(hold time)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree driven delayed clock" src="/images/the-art-of-reset-design-in-fpga/reset_tree_parallel_clock.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reset Glitch Filtering&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;使用异步复位信号时，考虑到异步复位信号对毛次比较敏感，所以在一些系统中需要处理毛次，下图显示了一种简单但是比较丑陋的方法(时延不是固定的，会随温度、电压变化)&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset glitch filtering" src="/images/the-art-of-reset-design-in-fpga/reset_glitch_filtering.png" /&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;毛刺 Glitch&lt;/code&gt; 是一个很重要的问题，不论是对于时钟、复位信号还是其他信号，详细讨论待续&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不是所有的系统都需要过滤毛次，设计者要先研究需求，再觉得是否使用延时来过滤毛次&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Multi-clock Reset&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;在一个系统中，往往有多个时钟，这时候有必要为每个时钟域分配一个复位信号。&lt;/p&gt;
&lt;p&gt;因为只有一个全局复位的话，它与系统的时钟都没有关系，是异步复位信号，要求这个信号满足所有时钟域的 recovery 和 removal 时序不是一件容易的事情，因为为每个时钟域分配复位是有必要的。&lt;/p&gt;
&lt;p&gt;根据实际情况的不同，有两种方案可以采用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-coordinated reset removal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于多时钟域的设计，很多时候不同时钟域之间复位信号的先后顺序没有要求，尤其是在有 &lt;code&gt;request-acknowledge&lt;/code&gt; 这样握手信号的系统中，不会引起硬件上的错误操作，这时候下图所示的方法就足够了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="non coordinated reset" src="/images/the-art-of-reset-design-in-fpga/non_coordination.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sequenced coordination of reset removal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一些设计，要求复位信号的释放顺序有一定顺序，这时候应该使用下图所示的方法&lt;/p&gt;
&lt;p&gt;&lt;img alt="sequenced rcoordination" src="/images/the-art-of-reset-design-in-fpga/sequenced_coordination.png" /&gt;&lt;/p&gt;
&lt;p&gt;Xilinx 的杂志上的一篇文章，&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt;，作者 Srikanth Erusla-gandi 是 Xilinx 的员工和培训人员。他在文中提供了一张图来说明典型的系统复位方案，图中 &lt;code&gt;MMCM&lt;/code&gt; 的 &lt;code&gt;lock&lt;/code&gt; 和外部输入的复位信号相与，目的是为了保证提供给后面的同步器的时钟信号是稳定的；每个时钟域都有一个同步器来同步复位信号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="typical reset implementation in FPGA" src="/images/the-art-of-reset-design-in-fpga/typical_reset.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Understanding the flip-flop reset behavior&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;在开始详细讨论之前，首先得理解 FPGA 的基本单元 Slice 中的 FF 的复位方式。Xilinx 的 Virtex 5 系列的芯片中的 FF 的类型都是 DFF (D-type flip flop)，这些 DFF 的控制端口包括一个时钟 CLK，一个高有效的使能 CE，一个高有效的置位/复位 SR。这个 SR 端口可以配置为同步的置位/复位，也可以配置为异步方式的置位/复位。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="dff" src="/images/the-art-of-reset-design-in-fpga/dff.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;我们写的 RTL 代码也会影响最终综合出来的 FF 类型。&lt;/p&gt;
&lt;p&gt;如果代码的敏感列表中包含了复位信号，那么就会综合出一个异步复位的 DFF，SR 端口将被配置为置位或者复位端口(FDPE &amp;amp; FDCE primitive)。当 SR 变高时，FF 的输出值立即变为代码中的复位时设定的值 SRVAL。&lt;/p&gt;
&lt;p&gt;同理，如果代码的敏感列表中不包含复位信号，那么就会综合出一个同步复位的 DFF，SR 端口将被配置为置位/复位端口(FDSE &amp;amp; FDRE primitive)。当 SR 变高时，FF 的输出值在下一个时钟的上升沿变为 SRVAL。&lt;/p&gt;
&lt;p&gt;如果我们在定义 reg 变量时给它一个初始值，那么 FPGA 在上电配置(GSR 变高)时，载入这个值。&lt;/p&gt;
&lt;p&gt;虽然 FPGA 的 FF 可以配额为 preset/clear/set/reset，但是一个单独的 FF 每次只能配置为其中的一种，如果在代码中多于一个 preset/clear/set/reset，那么就会产生其他的逻辑，消耗 FPGA 资源。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Active low  V.S.  Active high&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;大多数书籍和博客都推荐使用 “异步复位，低电平有效” 的复位方案，却没有明确说明为什么使用 “低电平有效”。&lt;/p&gt;
&lt;p&gt;目前大多数书籍中都使用 低电平复位，网上给出的理由是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ASIC 设计大多数是低电平复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大多数厂商使用低电平复位多一些 (Xilinx 基本全是高电平复位，这也叫大多数？)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低电平复位方式，在上电时系统就处于复位状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是从我找到的资料来看， Xilinx 的器件全部是高电平复位端口，他们的 white paper 中的例子也都是高电平复位方式。而且，从综合结果来看，如果非要使用低电平复位，那么就会额外添加一个反相器，然后将反向得到的高电平连接到 FF 的复位端口，从而导致复位信号的传输时延增加，芯片的利用率下降，同时会影响到时序和功耗。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 中也证实了这一点，文中提到对于 Xilinx 器件，尽可能使用高有效复位，如果实在没有办法控制系统的复位极性，那么最好在系统的顶层模块中将输入的低有效复位翻转极性，这样做的好处是反向器将被吸收到 IO logic 中，不会消耗 FPGA 内的逻辑和布线资源。&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;应该参考器件决定使用那种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 Xilinx 器件，应该使用高电平复位方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Synchronous V.S. Asynchronous&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Synchronous Reset&lt;/h3&gt;
&lt;p&gt;模块的 &lt;code&gt;sensitivity list&lt;/code&gt; 中不包含 &lt;code&gt;rst&lt;/code&gt; 信号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sync reset" src="/images/the-art-of-reset-design-in-fpga/sync_reset.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;fdr&lt;/code&gt; 是 Xilinx 的原语，表示 &lt;code&gt;Singal Data Rate D Flip-Flop with Synchronous Reset and Clock Enable (posedge clk)&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and&lt;/span&gt;
&lt;span class="c1"&gt;//       Clock Enable (posedge clk).&lt;/span&gt;
&lt;span class="c1"&gt;//       All families.&lt;/span&gt;
&lt;span class="c1"&gt;// Xilinx HDL Language Template, version 13.3&lt;/span&gt;

&lt;span class="no"&gt;FDRE&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Initial value of register (1&amp;#39;b0 or 1&amp;#39;b1)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;FDRE_inst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Data output&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Clock input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;    &lt;span class="c1"&gt;// 1-bit Clock enable input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;R&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;R&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Synchronous reset input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 1-bit Data input&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// End of FDRE_inst instantiation&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有时候，有些器件不带同步复位专用端口，这时候一般会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。&lt;/p&gt;
&lt;h4&gt;Advantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保证设计是 100% 同步，有利于时序分析，也利于仿真&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降低亚稳态出现的几率，时钟起到过滤毛刺的作用(如果毛刺发生在时钟沿附近，那么仍然会出现亚稳态的问题)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在某些设计中，复位信号是由内部逻辑产生的，推荐使用同步复位，因为这样可以避免逻辑产生的毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Disadvantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;同步复位需要保证复位信号具有一定的脉冲宽度(脉冲延展器)，使其能被时钟沿采样到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在仿真过程中，同步复位信号可能被X态掩盖(?不懂...)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果设计中含有三态总线，为了防止三态总线的竞争，同步复位的芯片必须有一个上电异步复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果逻辑器件的目标库内的 FF 只有异步复位端口，那么使用同步复位的话，综合器会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。&lt;/p&gt;
&lt;p&gt;有很多教材和博客都直接说 “同步复位会产生额外的逻辑资源”，可能他们是基于 Altera 的 FPGA 这么做的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="extra logic" src="/images/the-art-of-reset-design-in-fpga/extra_logic.png" /&gt;&lt;/p&gt;
&lt;p&gt;但是根据我实际的测试结果，对于 Virtex 5 系列的芯片，它的原语里面已经含有各种带同步、异步复位端口的 FF，ISE 自带的 XST 也已经很智能了，它会根据代码分析，自动选择合适的 FF。所以上面同步复位综合出来的 RTL Schematic 中没有所谓的 “多余的逻辑资源”。&lt;/p&gt;
&lt;p&gt;所以，是否占用多余的资源，还得针对具体的板子分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Asynchronous&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="aync reset" src="/images/the-art-of-reset-design-in-fpga/async_reset.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;fdc&lt;/code&gt; 是 Xilinx 的原语，表示 &lt;code&gt;Single Data Rate D Flip-Flop with Asynchronous Clear and Clock Enable (posedge clk)&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and&lt;/span&gt;
&lt;span class="c1"&gt;//       Clock Enable (posedge clk).&lt;/span&gt;
&lt;span class="c1"&gt;//       All families.&lt;/span&gt;
&lt;span class="c1"&gt;// Xilinx HDL Language Template, version 13.3&lt;/span&gt;

&lt;span class="no"&gt;FDCE&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Initial value of register (1&amp;#39;b0 or 1&amp;#39;b1)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;FDCE_inst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Data output&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Clock input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;    &lt;span class="c1"&gt;// 1-bit Clock enable input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;CLR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CLR&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  &lt;span class="c1"&gt;// 1-bit Asynchronous clear input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 1-bit Data input&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// End of FDCE_inst instantiation&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;异步复位的优缺点和同步复位是相对应的：&lt;/p&gt;
&lt;h4&gt;Advantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;脉冲宽度没有限制，可以快速复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EDA 工具 route 起来更容易，对于大型设计，能显著减少编译时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有时钟的时候也可以将电路复位 (比如省电模式下，同步复位无法工作，而异步复位是可以的)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无需额外的组合逻辑 (同上，具体分析)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Disadvantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不是同步电路，不利于时序分析，设计者要正确约束异步复位信号比同步复位复杂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复位信号容易收到毛刺的干扰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容易在复位信号撤销的时候(release)不满足 &lt;code&gt;removal time&lt;/code&gt; 时序要求，从而产生亚稳态 (关于亚稳态，网上有很多论文、博客都有详细说明)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Reset Synchronizer&lt;/h3&gt;
&lt;p&gt;两种复位方式各有优缺点，设计者应该根据实际情况选择合适的复位方法。目前，很多文献书籍中都推荐一种 “异步复位，同步释放” 的方法。这种方法可以将两者结合起来，取长补短。&lt;/p&gt;
&lt;p&gt;它的原理如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset synchronizer" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer.png" /&gt;&lt;/p&gt;
&lt;p&gt;针对 Xilinx 器件，用代码具体实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;SYSRST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sys_rst&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;rst_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;rst_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;sys_rst&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;sys_rst&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset synchronizer" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_rtl.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;rst_pb&lt;/code&gt; 是系统的复位按钮，&lt;code&gt;sys_rst&lt;/code&gt; 是同步化的结果。前面的原理图是按照低有效复位说明的，而 Xilnx 的 FPGA 都是高有效复位，所以综合出的 RTL 图则正好相反，复位按钮接到了 FF 的置位端，第一级 FF 的输入也由 &lt;code&gt;Vcc&lt;/code&gt; 变为 &lt;code&gt;GND&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 也证实了前面的 RTL Schematic 没有错：&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset_synchronizer_xilinx" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_xilinx.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Simulation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="simulation" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_simulation.png" /&gt;&lt;/p&gt;
&lt;p&gt;所谓 “异步复位”，如上图(由于连接到了置位端，叫 “异步置位” 更合适)，一旦复位信号 &lt;code&gt;rst_pb&lt;/code&gt; 有效，那么输出端口 &lt;code&gt;sys_rst&lt;/code&gt; 立即被置为 &lt;code&gt;1&lt;/code&gt;，否则输出为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所谓 “同步释放”。如上图，当复位信号 &lt;code&gt;rst_pb&lt;/code&gt; 释放时(从有效变为无效)，输出端口 &lt;code&gt;sys_rst&lt;/code&gt; 不是立即变化，而是被 FF 延迟了一个时钟输出，从而使其和时钟同步化。这个和时钟同步化的复位信号可以有效的驱动后面的逻辑，避免亚稳态。&lt;/p&gt;
&lt;p&gt;可以看到，所谓的这种 “异步复位，同步释放” 的方法，其本质就是要 &lt;strong&gt;利用异步复位来产生一个同步复位的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么不直接使用异步复位呢？因为异步复位容易产生亚稳态的问题。&lt;/p&gt;
&lt;p&gt;为什么不直接使用同步复位呢？因为很多器件只有异步复位端口，不支持同步复位端口，如果要使用同步复位，就会产生额外的逻辑，消耗资源。&lt;/p&gt;
&lt;p&gt;所以，这种方法的根本思想就是 &lt;strong&gt;异步信号同步化&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;知道了这点，选择复位信号的策略就很明显了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尽可能使用同步复位，保持设计 “同步化”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果器件本身是带有同步复位端口的，那么在写代码时就直接使用同步复位就可以了(CummingsSNUG2002SJ 也说了如果如果生产商提供同步复位端口，那么使用异步复位是毫无有点的。Xilinx 就是个例子，它所有的芯片都带有同步/异步复位端口)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不带有同步复位端口，那么就需要使用这种异步复位同步化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_Resets.pdf"&gt;Synchronous Resets? Asynchronous Resets? I am so confused! How will I ever know which to use?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2003Boston_Resets.pdf"&gt;Asynchronous &amp;amp; Synchronous Reset Design Techniques - Part Deux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.xilinx.com/support/documentation/white_papers/wp272.pdf"&gt;Get Smart About Reset: Think Local, Not Global&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I rest my FPGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eefocus.com/coyoo/blog/13-12/301045_9c39f.html"&gt;FPGA复位电路的实现及其时序分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4893454/"&gt;深入浅出玩转 FPGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://item.jd.com/11337565.html"&gt;100 Power Tips for FPGA Designers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379"&gt;Advanced FPGA Design by Steve Kilts&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="reset"></category></entry><entry><title>有限状态机设计</title><link href="http://guqian110.github.io/pages/2014/06/05/fsm_design.html" rel="alternate"></link><updated>2014-06-05T17:55:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-06-05:pages/2014/06/05/fsm_design.html</id><summary type="html">&lt;p&gt;有限状态机是数字电路中经常出现、非常重要的电路，设计一个安全、高效的状态机有一套程序化的方法，我们在数字电路课中就学习过了。搬运以前写的博客，总结一下相关知识，温故而知新～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面的废话：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇博客是在我以前在 CSDN 上写的两篇博客的基础上，参考了其他各位大神、博主的文章，写的总结。欢迎批评、讨论，毕竟写博客的意义就在于给自己一个总结知识的机会、并且在和别人讨论的过程中进步 :-D&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;What is FSM&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Finite-state_machine"&gt;FSM on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有限状态机 (Finite State Machine, FSM)&lt;/strong&gt; 有时候也简称为&lt;strong&gt;状态机 (state machine)&lt;/strong&gt;，它是一种数学模型，通常用来设计电脑程序或者时序电路。它被构思设计为一个抽象的机器，并且某个时刻只能处于一个有限数字代表的状态之下。&lt;/p&gt;
&lt;p&gt;有限状态自动机在很多不同领域中是重要的，包括电子工程、语言学、计算机科学、哲学、生物学、数学和逻辑学。有限状态机是在自动机理论和计算理论中研究的一类自动机。在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。(这里讨论的只限于电子工程里的状态机)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组成元素：&lt;/strong&gt;输入、状态、状态转移条件、输出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态转移图&lt;/li&gt;
&lt;li&gt;状态转移表&lt;/li&gt;
&lt;li&gt;HDL 描述&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;分类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照输出的产生方式，可以将状态机分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Moore_machine"&gt;Moore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="moore diagram" src="/images/fsm-design/moore.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;(&lt;a href="http://homepages.ius.edu/JFDOYLE/c421/html/Chapter8.htm"&gt;图片来源&lt;/a&gt;，homepages.ius.edu)&lt;/p&gt;
&lt;p&gt;一种状态机，它的输出只取决于当前状态，而与输入无关。Moore 状态机最重要的特点就是将输入与输出信号隔离开来，而且输出与时钟信号同步的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Mealy_machine"&gt;Mealy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mealy diagram" src="/images/fsm-design/mealy.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;(&lt;a href="http://homepages.ius.edu/JFDOYLE/c421/html/Chapter8.htm"&gt;图片来源&lt;/a&gt;，homepages.ius.edu)&lt;/p&gt;
&lt;p&gt;另外一种状态机，它的输出不仅和当前状态有关，而且和输入也有关。Mealy 有限状态机对输入的响应发生在当前时钟周期，比 Moore 有限状态机对输入信号的响应要早一个周期。因此，输入信号的噪声可能影响在输出的信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;How to Design a FSM&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;关于如何设计一个状态机，这在数字电路和逻辑设计的书里有详细介绍。简单地总结一下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逻辑抽象，建立原始状态转移图：确定输入、输出、状态变量、画状态转移图&lt;/li&gt;
&lt;li&gt;状态简化，得到最简的状态转移图(卡诺图)&lt;/li&gt;
&lt;li&gt;状态分配，选择编码方案(Binary、Gray、One-Hot)&lt;/li&gt;
&lt;li&gt;画逻辑图，检查能否自启动，得到了最终的状态机模型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;How to implement a FSM&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;当设计好之后，就要使用 HDL 语言来实现这个 FSM 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语言：&lt;/strong&gt; Verilog HDL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综合工具：&lt;/strong&gt; XST (Xilinx Synthesis Tools)&lt;/p&gt;
&lt;p&gt;下面讨论了一些 FSM 实现时需要注意的问题&lt;/p&gt;
&lt;h3&gt;Coding Style&lt;/h3&gt;
&lt;p&gt;状态机一般有三种写法，他们在速度、面积、代码可维护性等各个方面互有优劣。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一段式：&lt;/strong&gt;只有一个always block，把所有的逻辑（输入、输出、状态）都在一个always block中实现；这种写法 &lt;em&gt;看起来很简洁&lt;/em&gt;，但是 &lt;em&gt;不利于维护&lt;/em&gt;。如果状态复杂一些就很容易出错。不推荐这种方法，但是在简单的状态机可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二段式：&lt;/strong&gt;有两个always block，把时序逻辑和组合逻辑分隔开来。时序逻辑里进行当前状态和下一状态的切换，组合逻辑实现各个输入、输出以及状态判断。这种写法 &lt;em&gt;不仅便于阅读、理解、维护，而且利于综合器优化代码，利于用户添加合适的时序约束条件，利于布局布线器实现设计。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在两段式描述中，当前状态的输出用组合逻辑实现，可能存在竞争和冒险，产生毛刺。则要求对状态机的输出用寄存器打一拍，但很多情况不允许插入寄存器节拍，此时使用三段式描述。其优势在于能够根据状态转移规律，在上一状态根据输入条件判断出当前状态的输出，从而不需要额外插入时钟节拍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三段式：&lt;/strong&gt;有三个always block，一个时序逻辑采用同步时序的方式描述状态转移，一个采用组合逻辑的方式判断状态转移条件、描述状态转移规律，第三个模块使用同步时序的方式描述每个状态的输出。&lt;em&gt;代码容易维护，时序逻辑的输出解决了两段式组合逻辑的毛刺问题&lt;/em&gt;，但是从资源消耗的角度上看，&lt;em&gt;三段式的资源消耗多一些，且输出比另外两种会延时一个时钟周期。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;三段式代码模板&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;IDLE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0000_0001&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;WAIT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0000_0010&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;STRT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0000_0100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;  &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;//初始化寄存器，避免生成latch&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="nl"&gt;S1:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
       &lt;span class="nl"&gt;default:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 注意&lt;/span&gt;
       &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// ...          //初始化一组值，避免latch&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;           &lt;span class="c1"&gt;//注意为NS&lt;/span&gt;
            &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;S1:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;default:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="n"&gt;endcase&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;一段 or 三段？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说，三段式的效果更好，唯一的缺点是占用的资源稍微多一点(对于拥有丰富的触发器资源的 FPGA 来说，这个缺点可以忽略吧)。所以除非是非常简单的状态机用一段式实现，其他情况下三段式更简单。&lt;/p&gt;
&lt;p&gt;对于上面的三段式模板，按代码顺序解释一下相关的注意事项&lt;/p&gt;
&lt;h3&gt;参数使用 parameter&lt;/h3&gt;
&lt;p&gt;尽量使用 &lt;code&gt;parameter&lt;/code&gt; 而不是 &lt;code&gt;define&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个原则不仅仅限于 FSM，其他模块也应该遵守。因为使用 &lt;code&gt;define&lt;/code&gt; 定义的参数是全局变量，而 &lt;code&gt;parameter&lt;/code&gt; 定义的是局部变量。如果设计中包含多个 FSM，包含多个同名的变量，显然使用 &lt;code&gt;parameter&lt;/code&gt; 是更好的选择。&lt;/p&gt;
&lt;h3&gt;FSM 复位&lt;/h3&gt;
&lt;p&gt;FPGA 上电时，GSR(Global Set/Reset) 拉高，对所有 寄存器/RAM 进行复位，此时配置于 FPGA 的逻辑并未生效，所以不能保证 FSM 进入正确的初始化状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般，FSM 使用其他的复位(同步 or 异步)。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Synchronous Reset&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有一种方法，是将初始状态编码为全 0 (带 0 的 One-Hot 编码方式)，这样当 GSR 复位后，状态机自动进入初始状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;编码方式&lt;/h3&gt;
&lt;p&gt;状态机的状态的编码，通常有 &lt;code&gt;Binary&lt;/code&gt;、&lt;code&gt;One-Hot&lt;/code&gt;、&lt;code&gt;Gray&lt;/code&gt; 码等几种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Binary 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用最简单的递增的编码方式对状态进行编码，对于 n 个状态的状态机，共需要 log2(n) 个触发器表示所有的状态。&lt;/p&gt;
&lt;p&gt;优点：在状态很多的情况下，可以大大减少触发器的数量，对设计的面积有积极的作用。&lt;/p&gt;
&lt;p&gt;缺点：但是在状态跳转过程中，很可能出现多位同时变化的情况，容易在 next state 的生成逻辑上产生毛刺。同时，输出也是所有状态位的译码，译码逻辑多数很复杂，往往成为整个设计的关键路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gray 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似 Binary，但是采用了格雷码的编码方式，每两个相邻的状态只有一位信号变化。&lt;/p&gt;
&lt;p&gt;有点：避免了 next state 上毛刺的产生。同时两个相邻状态的输出译码变得简单了，避免了复杂组合逻辑的产生。&lt;/p&gt;
&lt;p&gt;缺点；格雷码的这些优点都是建立在状态跳转是顺序执行的基础上的。如果状态机有很多随机跳转和分支，格雷码的实际效果和二进制码相差无几，优势荡然无存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;One-Hot 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前设计中最常用的状态机编码方式。One-Hot 编码在一组 0 中只有一个 1，对一个 n 个状态的 FSM 设计，需要 n 个触发器。&lt;/p&gt;
&lt;p&gt;优点：在任意两个状态之间跳转都只有两位状态位变化，不会产生非常复杂的组合逻辑。各个状态之间的译码也相对简单。&lt;/p&gt;
&lt;p&gt;缺点：对状态编码需要的寄存器比其他方式多，不过这个缺点基本可以忽略吧 :-P&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Binary、Gray 编码使用最少的触发器，较多的组合逻辑。而 One-Hot  编码反之。由于 CPLD 更多的提供组合逻辑资源，而 FPGA 更多的提供触发器资源，所以 CPLD 多使用 Gray，而 FPGA  多使用 One-Hot 编码。另一方面，对于小型设计使用 Gray 和 Binary 编码更有效，而大型状态机使用 One-Hot 更高效。&lt;/p&gt;
&lt;p&gt;(XST 的选项 &lt;code&gt;FSM encoding algorithm&lt;/code&gt; 值默认为 &lt;code&gt;auto&lt;/code&gt;，编写程序测试发现，它会根据代码中状态的多少，FSM 的复杂度，自动选择合适的编码方式对状态进行编码。)&lt;/p&gt;
&lt;h3&gt;安全的 FSM&lt;/h3&gt;
&lt;p&gt;所谓 “安全” 的状态机，就是说即使因为某些意外原因，状态机跑飞了，仍然可以自动回复到正常状态。&lt;/p&gt;
&lt;p&gt;如果我们对状态向量的所有取值情况都显式地进行了说明，那么这个状态机就是安全的，否则就是不安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可能出现的不安全情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，我们在 One-Hot 方式中，对于 8 个状态，总共使用了 8 bit 的寄存器，那么这个状态寄存器向量可以取到的值一共有 &lt;code&gt;2^8 = 256&lt;/code&gt; 种。如果我们只对需要的 8 种状态进行了说明，而忽略了剩余的 248 种，此时综合工具(Synplify、XST)会对设计进行 “优化”，将没有用到的状态去掉。但是，有时候这种 “优化” 反而不好，如果状态机进入未定义的全 0 状态，那么它就会卡在这个未定义的状态，无法自动回复正常工作状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;书写完备的 &lt;code&gt;case&lt;/code&gt; 语句。在代码中对每一种可能的取值对进行描述，对于不使用的状态编码，一定要有 &lt;code&gt;default&lt;/code&gt; 分支进行说明。&lt;/p&gt;
&lt;p&gt;在第二段 &lt;code&gt;always&lt;/code&gt; 中，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;begian&lt;/span&gt;
    &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里应该赋值 &lt;code&gt;8'bx&lt;/code&gt; 更合理，因为状态机上电时处于未知状态，所以应该赋值 &lt;code&gt;x&lt;/code&gt; 更符合实际，但是这样赋值必须有个条件，就是必须所有的状态编码都全部被使用了，不然就会出现锁死现象，FSM 无法返回工作状态。我们前面使用的是 One-Hot 编码方式，有大量无效状态，所以这里不能赋值为 &lt;code&gt;x&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XST支持状态机编码的完备属性 —— &lt;code&gt;case implementation style&lt;/code&gt;，虽然可以打开这个设置，但是一般我们应该在代码中满足条件，而不是依靠综合工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使使用第一种方法，似乎我们的状态机已经是 perfect 了，但是真的是这样么？考虑这种情况：一个状态机有 8 个状态，采用 One-Hot 编码方式，代码含有 &lt;code&gt;default&lt;/code&gt; 分支处理未定义的状态向量可能取到的值。现在把这个状态机放在卫星中，接受宇宙射线的辐射，导致状态向量的值发生了变化，进入了无效状态，然后状态机自动恢复到正常状态(Good Job)，但是！状态机的外围电路并没有随着状态机恢复，它还在等 FSM 输出某个信号呢。所以，仅仅是回到正常状态并不够，最好的设计应该有个错误状态专门来与外围电路通信，当 FSM 自动恢复时，它会通知外围电路 reset 。&lt;/p&gt;
&lt;p&gt;(XST 的选项 &lt;code&gt;safe implementation&lt;/code&gt; 值默认为 &lt;code&gt;None&lt;/code&gt;，如果应用环境要求 FSM 必须能恢复任何错误，比如航天、医疗、汽车等，这时我们可以打开这个设置，这时综合工具会添加额外的逻辑，保证 FSM 可以从无效状态恢复过来。)&lt;/p&gt;
&lt;h3&gt;检查状态完备性&lt;/h3&gt;
&lt;p&gt;在第二个 &lt;code&gt;always block&lt;/code&gt; 中，第一句是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是个很有用的小技巧，它可以帮助我们在综合前发现状态是否完备：如果状态完备，则在下面的 &lt;code&gt;case&lt;/code&gt; 中会给 &lt;code&gt;NS&lt;/code&gt; 合适的值；如果状态不完备，则状态机会进入错误状态，输出不定，仿真时可以很快的发现。而且，综合工具对于 &lt;code&gt;x&lt;/code&gt; 采取的态度是 &lt;code&gt;don't care&lt;/code&gt;，综合时会自动将其忽略，生成的电路最简洁。&lt;/p&gt;
&lt;h3&gt;避免 Latch&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在第三个 &lt;code&gt;always&lt;/code&gt; 中，在 &lt;code&gt;case&lt;/code&gt; 前，所有的输出都有默认的值，这样做的好处是可以消除 &lt;code&gt;Latch&lt;/code&gt; 的出现，而且，可以减少在后面每种状态下重复相同的赋值，而且强调显示了 case 内哪个输出发生了变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;书写完备的 &lt;code&gt;if-else&lt;/code&gt; 和 &lt;code&gt;case&lt;/code&gt; 语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;消除输出毛刺&lt;/h3&gt;
&lt;p&gt;对于三段式，因为输出是寄存器输出，所以解决了输出毛次。&lt;/p&gt;
&lt;p&gt;讨论一下采用寄存器输出的方式对设计的影响&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输出采用寄存器驱动可以优化 FSM 的时序性能&lt;/p&gt;
&lt;p&gt;影响一个时序电路运行速度的主要因素是两个寄存器之间的组合逻辑路径的长度，越长的组合逻辑路径，其时序性能越差。一个电路中的最长组合逻辑路径决定了这个电路最高运行速率，该路径就是这个电路的关键路径（&lt;code&gt;critical path&lt;/code&gt;）。所以，切断最长的组合逻辑路径可以提高局部电路的运行速度，切断多个较长的组合逻辑路径可以提高整体电路的运行速度。切断组合逻辑路径的工具就是寄存器。所以，添加寄存器可以提高电路的性能，但是会增加资源的消耗，这也是速度（speed）和面积（area）互为矛盾的原因。&lt;/p&gt;
&lt;p&gt;在考虑FSM的时序问题时，不能独立的考虑FSM本身，需要综合考虑FSM模块和下游模块构成的电路。在FSM不采用输出寄存时，在FSM模块和下游模块的接口处，是两部分组合逻辑直接相连。关键路径由两部分组合逻辑构成；在FSM采用输出寄存时，两个模块的组合逻辑被分隔成两部分，可能的关键路径被切断了。同步寄存器输出和组合逻辑输出就是采用资源优化还是速度优化的问题。组合逻辑表面上会提高电路的速度，看似节省了资源而且提高了速度，其实不然（对FPGA结构来说，节省寄存器不等于节省LE；对同步设计来说，异步输出速度上的优势是可以忽略的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出采用寄存器驱动会降低输出队输入信号变化的响应速度？&lt;/p&gt;
&lt;p&gt;到底应不应该采用FSM输出寄存器？是否必须在时序性能和响应速度之间做出取舍？在同步设计中，答案是必须牺牲一定的响应速度以换取更佳的时序性能，只考虑响应速度会带来潜在的时序性能损失。&lt;/p&gt;
&lt;p&gt;在考虑FSM的响应速度时，不能独立的考虑FSM本身，需要综合考虑FSM模块和上、下游模块构成的电路。采用输出寄存器的电路可以运行在更高的时钟频率下，所引入的响应时延与更高的运行频率相比是可以牺牲的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;case (NS) vs case (CS)&lt;/h3&gt;
&lt;p&gt;采用二段式实现状态机，它的输出是组合逻辑，可能存在竞争和冒险，产生毛刺，要消除毛刺就要对输出用寄存器打一拍，但是很多时候，是不允许插入寄存器节拍的。&lt;/p&gt;
&lt;p&gt;这时候可以采用三段式实现，三段式的输出是寄存器输出，所以消除了毛次；同时，如果三段式的第三段判断输出采用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// ....&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="nl"&gt;default:&lt;/span&gt; &lt;span class="n"&gt;begian&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就可以提前判断下一状态的输出，节省了一个节拍，使输出和状态变化同步。&lt;/p&gt;
&lt;p&gt;设计一个简单的 FSM，测试使用 &lt;code&gt;case(CS)&lt;/code&gt; 和 &lt;code&gt;case(NS)&lt;/code&gt; 的结果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FSM 设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一共有 4 个状态(IDLE、S1、S2、S3)，只有一个输入(&lt;code&gt;jump&lt;/code&gt; 信号)，两个输出(&lt;code&gt;dout_p&lt;/code&gt;、&lt;code&gt;dout_q&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跳转规律&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态机开始处于 IDLE 状态，当 jump 变高时，从 IDLE 跳转到 S1 状态，同时内部的一个 4 bit 计数器开始计数，当计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时，跳转到 S2，当再次计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时跳转到 S3，当再次计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时，跳转到 IDLE，等待 jump 再次变高。状态转移图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="diagram" src="/images/fsm-design/diagram.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态机源文件&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/fsm.v"&gt;fsm.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试平台 testbench&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/tb_fsm.v"&gt;tb_fsm.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;NS&lt;/code&gt; 判断，结果如下图，可以看到，当 &lt;code&gt;CS&lt;/code&gt; 发生变化时，输出同时改变。&lt;/p&gt;
&lt;p&gt;&lt;img alt="case ns" src="/images/fsm-design/case_ns.png" /&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;CS&lt;/code&gt; 判断，结果如下图，可以看到，当 &lt;code&gt;CS&lt;/code&gt; 发生变化时，输出变化相对于状态变化延时一个时钟周期。&lt;/p&gt;
&lt;p&gt;&lt;img alt="case ns" src="/images/fsm-design/case_cs.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG1998SJ_FSM.pdf"&gt;Clifford E. Cumming     State Machine Coding Styles for Synthesis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsICU2002_FSMFundamentals.pdf"&gt;Clifford E. Cumming     The Fundamentals of Efficient Synthesizable Finite State Machine
Design using NC-Verilog and BuildGates&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.trilobyte.com/pdf/golson_snug94.pdf"&gt;Steve Golson                State machine design techniques for Verilog and VHDL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/freeny/archive/2012/04/14/2447612.html"&gt;Verilog HDL学习心得&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;foreveryoung 《状态机设计》&lt;/p&gt;
&lt;p&gt;云创工作室     《Verilog HDL程序设计与实践》&lt;/p&gt;</summary><category term="FPGA"></category><category term="FSM"></category><category term="Verilog"></category></entry><entry><title>BUPT MITC lab Verilog HDL coding style guide</title><link href="http://guqian110.github.io/pages/2014/05/19/bupt_mitc_lab_verilog_hdl_coding_style_guide.html" rel="alternate"></link><updated>2014-05-19T10:12:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-05-19:pages/2014/05/19/bupt_mitc_lab_verilog_hdl_coding_style_guide.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Version&lt;/strong&gt; : 1.1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Date&lt;/strong&gt; : 2014-5-24&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Author&lt;/strong&gt; : Chien Gu (guqian110@gmail.com)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt; : This is a brief Verilog HDL coding style guide for BUPT MITC lab to design circuits on FPGA. This guide is only concerned about code format and dose not involve principles for writing synthesisable codes.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;总则&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码模块化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;顶层模块只有子模块的例化，不包含任何逻辑 ；常用、通用功能模块化，避免在多个模块中重复实现多次；模块内容过多时考虑分解为多个模块；模块按照功能、信号传递流程原则划分 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块结构化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分节书写，合理使用空格、括号，使代码更容易查看 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用缩写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;约定命名规则、大小写规则、常用单词缩写规则，避免过长的信号名 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;分述&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;head of file&lt;/h3&gt;
&lt;p&gt;Xilinx ISE 自动生成的标准文件头部，添加 &lt;code&gt;Email&lt;/code&gt;、&lt;code&gt;File Name&lt;/code&gt; 两个信息，最终结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Company: &lt;/span&gt;
&lt;span class="c1"&gt;// Engineer: &lt;/span&gt;
&lt;span class="c1"&gt;// Email:&lt;/span&gt;
&lt;span class="c1"&gt;// &lt;/span&gt;
&lt;span class="c1"&gt;// Create Date:    20:43:36 11/12/2013 &lt;/span&gt;
&lt;span class="c1"&gt;// Design Name: &lt;/span&gt;
&lt;span class="c1"&gt;// Module Name:    CLKMGN&lt;/span&gt;
&lt;span class="c1"&gt;// File Name:      clkmgn.v&lt;/span&gt;
&lt;span class="c1"&gt;// Project Name: &lt;/span&gt;
&lt;span class="c1"&gt;// Target Devices: &lt;/span&gt;
&lt;span class="c1"&gt;// Tool versions: &lt;/span&gt;
&lt;span class="c1"&gt;// Description: &lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// Dependencies: &lt;/span&gt;
&lt;span class="c1"&gt;// &lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// Revision: &lt;/span&gt;
&lt;span class="c1"&gt;// Revision 0.01 - File Created&lt;/span&gt;
&lt;span class="c1"&gt;// Additional Comments: &lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;module&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;模块命名大小写：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件名：xxx.v (小写)&lt;/li&gt;
&lt;li&gt;模块名：XXX (大写)&lt;/li&gt;
&lt;li&gt;例化名：U_XXX (大写)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;模块端口定义顺序：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入&lt;/li&gt;
&lt;li&gt;输出&lt;/li&gt;
&lt;li&gt;双向&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;模块调用规范：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;em&gt;信号映射法&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;举例说明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Module Declaration                                                            //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="no"&gt;MODULE_NAME&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="c1"&gt;// input ports&lt;/span&gt;
    &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;port_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="c1"&gt;// output ports&lt;/span&gt;
    &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;port_m&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;////////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Port Declarations                                                              //&lt;/span&gt;
&lt;span class="c1"&gt;////////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//input ports&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// comments&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;port_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//output ports&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// comments&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="n"&gt;port_m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Parameter Declarations                                                        //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;DIN&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTA&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTE&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTCTR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Wire &amp;amp; Reg Declarations                                                       //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="k"&gt;wire&lt;/span&gt;    &lt;span class="n"&gt;wire_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;wire&lt;/span&gt;    &lt;span class="n"&gt;wire_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;wire&lt;/span&gt;    &lt;span class="n"&gt;wire_x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;reg_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;reg_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;reg_y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Main Body of Code                                                             //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;

    &lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;// Instantiate sub module                                //&lt;/span&gt;
    &lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="no"&gt;MODULE_NAMW_A&lt;/span&gt; &lt;span class="no"&gt;U_MODULE_NAMW_A&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;posdge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// do something&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;wire_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wire_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;FSM&lt;/h3&gt;
&lt;p&gt;有限状态机(Finite State Machine) 使用三段式格式。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// FSM-1&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// next state&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// FSM-2&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="no"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="nl"&gt;S1:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="no"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// FSM-3&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;posdge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;

    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// default output&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;defaut:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;endcase&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;always&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个 &lt;code&gt;always&lt;/code&gt; 中不要同时含有 &lt;em&gt;组合逻辑&lt;/em&gt; 和 &lt;em&gt;时序逻辑&lt;/em&gt;，分开写在不同的 &lt;code&gt;always&lt;/code&gt; 块中。&lt;/li&gt;
&lt;li&gt;组合逻辑使用 &lt;em&gt;阻塞赋值(=)&lt;/em&gt;，时序逻辑使用 &lt;em&gt;非阻塞赋值(&amp;lt;=)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;不要在多个 &lt;code&gt;always&lt;/code&gt; 中对同一信号赋值，也不要在一个 &lt;code&gt;always&lt;/code&gt; 中对一个信号进行多次赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;标准 &lt;code&gt;always&lt;/code&gt; 格式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;

    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// do somethig&lt;/span&gt;

    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;parameter&lt;/h3&gt;
&lt;p&gt;parameter 全部大写，用 parameter 定义有实际意义的常数，比如 LED 亮灯状态、状态机状态等，避免 "magic number"。举例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Parameter Declarations                                                        //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;DIN&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTA&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTE&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTCTR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;if-else&lt;/h3&gt;
&lt;p&gt;标准 &lt;code&gt;if-else&lt;/code&gt; 格式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;

&lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;

&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;case-default&lt;/h3&gt;
&lt;p&gt;标准 &lt;code&gt;case&lt;/code&gt; 格式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;variable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nl"&gt;vaule1:&lt;/span&gt; &lt;span class="n"&gt;begian&lt;/span&gt;
        &lt;span class="c1"&gt;// do something&lt;/span&gt;

    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="nl"&gt;value2:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// do something&lt;/span&gt;

    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="nl"&gt;default:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// do something&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;naming&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单词首字母缩写，大写。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DMI&lt;/span&gt;     &lt;span class="c1"&gt;// Data Memory Interface&lt;/span&gt;
&lt;span class="n"&gt;DEC&lt;/span&gt;     &lt;span class="c1"&gt;// Decoder&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块间信号名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分为两部分，第一部分表示信号方向，大写，第二部分表示信号意义，小写，下划线连接。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;CPUMMU_wr_req&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// write request form CPU to MMU&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块内命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单词缩写，下划线连接，小写。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;sdram_wr_en&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// SDRAM write enable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统级命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时钟信号、置位信号、复位信号等需要输送到各个模块的全局信号，以 &lt;code&gt;SYS_&lt;/code&gt; 前缀开头。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_clk_100MHz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// system clock&lt;/span&gt;
&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_set_cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// system counter set&lt;/span&gt;
&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_rst_cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// system counter reset&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;低电平有效信号命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;低电平有效信号加后缀 &lt;code&gt;_n&lt;/code&gt;，举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// low valid reset&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;经过锁存器的信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过锁存器的信号加后缀 &lt;code&gt;_r&lt;/code&gt;，以和锁存前区别。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// latch input data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际意义缩写，大写。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;IDLE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;WAIT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;常用信号名缩写：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;acknowledge&lt;/td&gt;
&lt;td&gt;ack&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;err&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;ready&lt;/td&gt;
&lt;td&gt;rdy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;adress&lt;/td&gt;
&lt;td&gt;addr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;enable&lt;/td&gt;
&lt;td&gt;en&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;receive&lt;/td&gt;
&lt;td&gt;rx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arbiter&lt;/td&gt;
&lt;td&gt;arb&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;frame&lt;/td&gt;
&lt;td&gt;frm&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;request&lt;/td&gt;
&lt;td&gt;req&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;check&lt;/td&gt;
&lt;td&gt;chk&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;generate&lt;/td&gt;
&lt;td&gt;gen&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;resest&lt;/td&gt;
&lt;td&gt;rst&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clock&lt;/td&gt;
&lt;td&gt;clk&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;grant&lt;/td&gt;
&lt;td&gt;gnt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;segment&lt;/td&gt;
&lt;td&gt;seg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;td&gt;cfg&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;increase&lt;/td&gt;
&lt;td&gt;inc&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;source&lt;/td&gt;
&lt;td&gt;src&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;control&lt;/td&gt;
&lt;td&gt;ctrl&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;statistic&lt;/td&gt;
&lt;td&gt;stat&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;counter&lt;/td&gt;
&lt;td&gt;cnt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;length&lt;/td&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;switcher&lt;/td&gt;
&lt;td&gt;sf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data in&lt;/td&gt;
&lt;td&gt;din&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;out&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;timer&lt;/td&gt;
&lt;td&gt;tmr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data out&lt;/td&gt;
&lt;td&gt;dout&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;packet&lt;/td&gt;
&lt;td&gt;pkt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;tmporary&lt;/td&gt;
&lt;td&gt;tmp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decode&lt;/td&gt;
&lt;td&gt;de&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;priority&lt;/td&gt;
&lt;td&gt;pri&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;transmit&lt;/td&gt;
&lt;td&gt;tx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decrease&lt;/td&gt;
&lt;td&gt;dec&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;ptr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;valid&lt;/td&gt;
&lt;td&gt;vld&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delay&lt;/td&gt;
&lt;td&gt;dly&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;read&lt;/td&gt;
&lt;td&gt;rd&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;write enable&lt;/td&gt;
&lt;td&gt;wr_en&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disable&lt;/td&gt;
&lt;td&gt;dis&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;read enbale&lt;/td&gt;
&lt;td&gt;rd_en&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;write&lt;/td&gt;
&lt;td&gt;wr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;incedent&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;tab&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的 &lt;code&gt;tab&lt;/code&gt; 全部用 &lt;em&gt;4 个 &lt;code&gt;space&lt;/code&gt;&lt;/em&gt; 代替！不同层次之间用 &lt;code&gt;tab(4 sapce)&lt;/code&gt; 缩进 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;space&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;信号端口定义，关键字、宽度说明、信号名之间对齐。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;input&lt;/span&gt;          &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;input&lt;/span&gt;          &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;input&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二元运算符用 &lt;code&gt;space&lt;/code&gt; 隔开&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dout_en&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;comments&lt;/h3&gt;
&lt;p&gt;采用英文，合理注释。修改代码一定要注释，添加 Revision 信息 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;建议&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;开发工具：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理工程： Xilinx ISE&lt;/li&gt;
&lt;li&gt;综合工具： Xilinx Synthsis Tools&lt;/li&gt;
&lt;li&gt;仿真平台： ModelSim SE&lt;/li&gt;
&lt;li&gt;代码编辑： Sublime Text 2 + Verilog 插件&lt;/li&gt;
&lt;/ul&gt;</summary><category term="FPGA"></category><category term="Verilog"></category><category term="coding style"></category></entry><entry><title>FPGA 数字处理基础 (1)</title><link href="http://guqian110.github.io/pages/2014/05/14/fpga_digital_processing_basic_1.html" rel="alternate"></link><updated>2014-05-14T23:25:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-05-14:pages/2014/05/14/fpga_digital_processing_basic_1.html</id><summary type="html">&lt;h2&gt;数字处理基础&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;数字处理基础&lt;/strong&gt;主要包括两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数的表示&lt;/li&gt;
&lt;li&gt;常用算术运算的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分别讨论&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;数的表示&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;这部分讨论对于计算机(PC)、数字信号处理器件(DSP)、数字芯片(包括 FPGA) 都是成立的。&lt;/p&gt;
&lt;h3&gt;人类如何计数&lt;/h3&gt;
&lt;p&gt;最早我们的祖先采用的是结绳计数，经过几千年的发展，现在我们使用的 10 进制位置计数法 。那么我们为什么偏偏选择 10 这个数字呢？&lt;/p&gt;
&lt;p&gt;大名鼎鼎的 &lt;a href="http://en.wikipedia.org/wiki/Charles_Petzold"&gt;Charles Petzold&lt;/a&gt; 在他的著作 &lt;a href="http://book.douban.com/subject/4822685/"&gt;code&lt;/a&gt; 中分析了我们的计数进制现象 。原因其实很简单，10 这个数字对于我们如此特别只是因为我们有 10 个手指(脚趾)，于是我们采用了 10 进制，并且逐渐习惯了它 。他在书中模拟了一下进制系统的演化过程，让我们逐渐从人类的 10 进制思维逐渐转化到计算机的 2 进制系统中：&lt;/p&gt;
&lt;p&gt;假设我们是卡通动画中的人物，比如米老鼠 Mickey，仔细观察它就会发现，他的每个手只有 4 个手指，理所当然，他采用 8 进制来计数。如果更进一步，假设我们是龙虾，那么我们的每一只钳子上有两个 “手指”，一共有 4 个手指，所以，我们会采取 4 进制计数系统。最后，假设我们是海豚，那么我们只有两个鳍来计数了，这时候的计数系统就是 2 进制数字系统了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;r 进制 to 10 进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需要按权值展开就可以了，比如： &lt;/p&gt;
&lt;p&gt;2 进制数 &lt;code&gt;110101&lt;/code&gt; 对应的 10 进制数为 &lt;code&gt;32 + 16 + 4 + 1 = 53&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;8 进制数 &lt;code&gt;B65F&lt;/code&gt; 对应的 10 进制数为 &lt;code&gt;11 × 16^3 + 6 × 16^2 + 5 × 16 + 15 × 1 = 46687&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10 进制 to r 进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整数部分：基数连除，逆序取余&lt;/p&gt;
&lt;p&gt;小数部分：基数连乘，顺序取余&lt;/p&gt;
&lt;h3&gt;计算机如何计数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;正数 &amp;amp; 负数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人类和计算机的计数原理是完全不同的，所以采用的方法也是完全不同的。对于人来说，区分正负数只需要在数字绝对值前添加一个符号 &lt;code&gt;+&lt;/code&gt; 或者 &lt;code&gt;-&lt;/code&gt; 即可，但是计算机只有 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 这两个符号可以使用；对于人来说，减法借位很容易，但是对于计算机硬件电路来说这是一件很麻烦的事。&lt;/p&gt;
&lt;p&gt;常用的表示方法有 3 种：&lt;strong&gt;原码&lt;/strong&gt;、&lt;strong&gt;反码&lt;/strong&gt;、&lt;strong&gt;补码&lt;/strong&gt; 。对于计算机而言，硬件上最容易实现的是补码，这也是大多数计算机采用补码系统的原因 。&lt;/p&gt;
&lt;p&gt;以前总结过一篇博客，&lt;a href="http://guqian110.github.io/pages/2014/03/19/signed_number_representations.html"&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整数 &amp;amp; 小数&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;整数&lt;/p&gt;
&lt;p&gt;对于整数而言，不存在小数点的问题，所以自然地将我们人类所熟悉的 10 进制数转化为计算机熟悉的 2 进制数，分配足够的空间存储起来就 ok 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小数&lt;/p&gt;
&lt;p&gt;在计算机中，整数和小数之间并不是很容易转换的的，而且小数的存储和处理要比整数复杂。对于小数，可以有两种方法来表示：&lt;strong&gt;定点数&lt;/strong&gt; &amp;amp; &lt;strong&gt;浮点数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定点数的意思是小数点在数中的位置是固定不变的。整数可以看作是一种特殊的定点数，小数点在数的末尾。值得注意的是小数点的位置信息并没有和数字存储在一起，所以，使用定点数的程序必须知道小数点的位置。&lt;/p&gt;
&lt;p&gt;浮点数的意思是小数点在数中的位置是变化的。当代大部分计算机处理浮点数的标准是 IEEE 在 1985 年制定的 ANSI/IEEE Std 754-1985 。&lt;/p&gt;
&lt;p&gt;==============================跑题分割线========================&lt;/p&gt;
&lt;p&gt;在计算机出现不久的年代，计算机处理浮点数是一件很重要但也让人头疼的事。最早，还没有专门处理浮点数的硬件，所以程序猿必须编写软件来完成浮点数的计算。浮点数在科学运算和工程类程序中极为重要，因此常常被赋予很高的优先级，在计算机发展的早期，为新制造的计算机做的第一项工作就是为其编写浮点数运算程序。&lt;/p&gt;
&lt;p&gt;如果可以直接利用计算机机器码指令来实现浮点数的计算，类似于 16 位处理器上进行乘法和除法运输，那么这台机器上所有的浮点数运算都会变得更快。IBM 公司在 1954 年发布了 IBM 704，它是第一台将浮点数运算硬件作为可选配件的商用计算机。该机器的浮点运算硬件可以直接进行加法、减法、乘法和除法，其他的浮点运算必须通过软件来实现。&lt;/p&gt;
&lt;p&gt;从 1980 年开始，浮点运算硬件开始应用于桌面计算机，这起始于 Intel 当年发布的 8087 数字协同处理(Numberic Data Coprocessor)芯片，当时这种集成电路被称为 &lt;strong&gt;数学协同处理器(math coprocessor)&lt;/strong&gt; 或者 &lt;strong&gt;浮点运算单元(floating-point,FPU)&lt;/strong&gt;。8087 不能独立工作，必须和 8086 或者 8088 一起工作，所以被称为 “&lt;strong&gt;协处理器&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;在最初版本的 IBM PC 主板上，位于 8080 芯片的右边有一个 40 个管脚的插槽供 8087 芯片接入，但是，这个插槽是空的，如果用户需要浮点运算则必须单独购买一块 8087 芯片。数字协处理器并不能加速所有的程序的运行速度，比如文字处理程序几乎用不到浮点运算，而电子表格处理程序对浮点数运算依赖程度很高。&lt;/p&gt;
&lt;p&gt;安装了数学协处理器，程序员必须使用协处理器的机器码指令来编写特定的程序，因为数学协处理器不是标准硬件。最后就出现了这样的局面：如果机器上安装了数学协处理器，程序员就要学会编写相应的应用程序以支持它的运行；如果没有安装，程序员必须通过编程来模拟它进行浮点数的运算。&lt;/p&gt;
&lt;p&gt;在 1989 年发布的 486DX 芯片中，FPU 已经内建在 CPU 的结构里，但是在 1991 年发布的 486SX 中，又没有内建 FPU，到了 1993 年发布的奔腾芯片中，CPU 内置 FPU 再次成为标准，并且是永远的标准。在 1990 年发布的 68040 芯片中，摩托罗拉首次将 FPU 集成到 CPU 中，在此之前是使用 68881 和 68882 数学协处理器来支持 68000 家族的微处理器。PowerPC 芯片同样使用了内置 FPU 的技术。&lt;/p&gt;
&lt;p&gt;==============================跑题分割线结束========================&lt;/p&gt;
&lt;p&gt;FPGA 不同于微处理器，它内部没有内置 FPU(不包括硬核)，对于FPGA，浮点数可以克服定点数动态范围小的缺点，但是在运算时，实现浮点数的硬件实时成本高，处理速度慢，所以在非实时运算中有广泛的应用。对于通信系统中的信号，一般都是实时处理的，所以在 FPGA 开发中，一般只使用定点数 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;常用算术运算的 FPGA 实现&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;加法&lt;/h3&gt;
&lt;p&gt;在 Verilog HDL 中，直接使用运算符 &lt;code&gt;+&lt;/code&gt;，其本质上是一种并行加法器，应该保证两边的数位宽是一致的。举个栗子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;add_4&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;output&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;output&lt;/span&gt;          &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;乘法&lt;/h3&gt;
&lt;p&gt;第一种方法，最简单，直接使用运算符 &lt;code&gt;*&lt;/code&gt;，如下所示 。但是这种方法写出来的代码效率很低，甚至有时候是不可综合的，实际应用中基本不会采用这种方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二种方法是自己写代码实现乘法运算，或者是使用 IP COre。一般 FPGA 中都集成了硬核的乘法器，所以可以有两种方案来实现乘法器，DSP48 硬核 或者是 Slice 搭建 。&lt;/p&gt;
&lt;h3&gt;除法&lt;/h3&gt;
&lt;p&gt;除法是四则基本运算中最复杂的，也是最难实现的。除法可以看作是乘法的逆运算，但除法要复杂的多，最大的区别是乘法中的一些操作可以并行支持，通过流水线提高计算速度，但是除法必须顺序执行，运算最耗时间。&lt;/p&gt;
&lt;p&gt;Verilog 提供了除法运算符 &lt;code&gt;/&lt;/code&gt;，如下所示。但是只有在除数为 2 或者 2 的整幂次时才是可综合的，其余情况都不可综合 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;常用的方法是采用 IP Core，可以完成定点数和浮点数两类算法。&lt;/p&gt;
&lt;h3&gt;Cordic 算法&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/CORDIC"&gt;Cordic 算法&lt;/a&gt; 算法即坐标旋转数字计算方法，是J.D.Volder1于1959年首次提出，主要用于三角函数、双曲线、指数、对数的计算。该算法通过基本的加和移位运算代替乘法运算，使得矢量的旋转和定向的计算不再需要三角函数、乘法、开方、反三角、指数等函数。&lt;/p&gt;
&lt;p&gt;它通常应用在没有硬件乘法器的应用中，比如微控制器、FPGA 中，进行的所有操作只有加法、移位和查表 。&lt;/p&gt;
&lt;p&gt;Coridc 算法可以自己编写代码实现，也可以使用 IP Core 。(事实上，所有的 IP 软核理论上都可以自己写，因为这些软核实际上就是别人写好的代码和文档，类似于C语言中的库函数)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3795386/"&gt;《无线通信的 Matlab 和 FPGA 实现》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4822685/"&gt;code&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="digital processing"></category></entry><entry><title>学习 OFDM 及其 FPGA 实现 1 —— OFDM Basic</title><link href="http://guqian110.github.io/pages/2014/05/13/learning_ofdm_on_fpga_1_ofdm_basic.html" rel="alternate"></link><updated>2014-05-13T23:16:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-05-13:pages/2014/05/13/learning_ofdm_on_fpga_1_ofdm_basic.html</id><summary type="html">&lt;h2&gt;Why OFDM&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;移动通信的信道模型一般建立为 &lt;strong&gt;时变多径信道模型&lt;/strong&gt;，描述信道多径时延特性的一个重要统计参量是 &lt;strong&gt;均方根时延扩展&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;经过无线信道的时变多径传输，接收到的信号幅度会有起伏变化（瑞利分布 or 莱斯分布），这种现象称为 &lt;strong&gt;信号衰落&lt;/strong&gt; 。按照已调信号的带宽可以将衰落分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;窄带信号受到 &lt;strong&gt;平坦性衰落&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;宽带信号受到 &lt;strong&gt;频率选择性衰落&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;判断信号受到何种衰落：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义信道的 &lt;strong&gt;相干带宽&lt;/strong&gt; 。当数字信号的带宽越小于信道的相干带宽，则经过时变多经信道后，在信号带宽内的不同频率分量的幅度的相关性越大，不同的频率分量近似经历相同的衰落，即平坦性衰落，平坦性衰落对接收信号的波形无明显影响，码间干扰可以忽略，该系统称为 &lt;strong&gt;窄带系统&lt;/strong&gt; 。当数字信号的带宽相对于信道的相干带宽越大时，信号带宽内的不同频率分量通过信道传输时会受到不同的衰落，即频率选择性衰落，频率选择性衰落使信号中的不同频率分量产生不同的幅度变化，造成接收信号的严重失真，引起吗见干扰，产生误码，该系统称为 &lt;strong&gt;宽带系统&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3&gt;Problem&lt;/h3&gt;
&lt;h4&gt;需求&lt;/h4&gt;
&lt;p&gt;无线信道的频率资源是有限的，要求数字通信系统有效利用信道频带。希望数据传输速率越高越好。&lt;/p&gt;
&lt;h4&gt;瓶颈&lt;/h4&gt;
&lt;p&gt;在系统设计选择数字调制方式时，必须兼顾 &lt;strong&gt;频带利用率&lt;/strong&gt; 和 &lt;strong&gt;误码性能&lt;/strong&gt; 。在 AWGN 信道下，在满足误码性能的前提下，应该尽可能采用频带利用率高的数字调制方式。&lt;/p&gt;
&lt;p&gt;然而，在以衰落为特征的移动通信系统中，影响误码性能的不仅仅是 &lt;strong&gt;加性噪声&lt;/strong&gt;，还包括 &lt;strong&gt;衰落&lt;/strong&gt; 和 &lt;strong&gt;码间干扰&lt;/strong&gt; 。实现高速无线通信并非易事。&lt;/p&gt;
&lt;p&gt;为避免码间干扰，数字调制信号的最大符号速率受到很大的限制 。&lt;/p&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;信道均衡&lt;/strong&gt; 是一种经典的对抗码间干扰的技术，许多移动通信系统都采用信道均衡技术消除码间干扰。但是如果数据速率非常高，采用单载波传输数据，需要设计几十审计上百个抽头的均衡器，这简直是硬件设计的噩梦 。&lt;/p&gt;
&lt;p&gt;既要对抗码间干扰，又要满足低复杂度且高效的手段传输高速数据业务，我们可以采用另外一种技术 —— &lt;strong&gt;OFDM&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;OFDM History&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;多载波调制技术早在 20 世纪 50年代末至 60 年代初就已经应用于军事高频无线通信中，由于实现复杂，没有被广泛应用 。OFDM 就是一种多载波调制，其子载波间隔是子载波符号间隔的倒数，各子载波的频谱是重叠的，这种重叠可以使频谱效率显著提高 。&lt;/p&gt;
&lt;p&gt;20 世纪 70 年代，Weinstein 和 Ebert 提出用 &lt;strong&gt;离傅里叶变换(DFT)&lt;/strong&gt; 及其 &lt;strong&gt;逆变换(IDFT)&lt;/strong&gt; 进行 OFDM 多载波调制方式的运算。&lt;/p&gt;
&lt;p&gt;DFT 和 IDFT 的快速计算方法：FFT 和 IFFT 使 OFDM 能够以低成本的数字方式实现 。&lt;/p&gt;
&lt;p&gt;在 20 世纪 80 年代，随着 OFDM 理论的不断完善、数字信号处理及微电子技术的不断快速发展，OFDM 技术也逐步走向实用化 。&lt;/p&gt;
&lt;p&gt;大约从 20 世纪 90 年代起，OFDM 技术开始应用于各种有线及无线通信中，包括：DSL、DAB、DVB、WLAN等。OFDM 已经成为下一代蜂窝移动通信空中接口的候选技术 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;OFDM Theory&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Orthogonal frequency-division multiplexing (OFDM) 的基本原理是将高速的数据流分解为多路并行的低速数据流，在多个载波上同时进行传输。&lt;/p&gt;
&lt;p&gt;通过将高速数据分解为多个并行低速速率，克服了信道时延扩展对数据速率的限制，其中各个子载波之间是相互正交的关系，如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="carrier wave" src="/images/learning-ofdm-basic/carriers.png" /&gt;&lt;/p&gt;
&lt;p&gt;OFDM 每个子载波的调制方式可以相互不同，比如 BPSK、QPSK、QAM 等方式 。&lt;/p&gt;
&lt;p&gt;(OFDM 系统的内容可以写一本书了，简单写写 :-P )&lt;/p&gt;
&lt;h3&gt;OFDM 基带数字实现&lt;/h3&gt;
&lt;h4&gt;发送端 Transmitter&lt;/h4&gt;
&lt;p&gt;基带系统发送端要实现的功能是将待发送序列 {A1,A2,A3...} 变换，得到复包络的采样值 {a1,a2,a3...} 。&lt;/p&gt;
&lt;p&gt;为了实现 OFDM 调制的基带数字实现，首先要将 OFDM 信号的复包络进行采样，成为离散时间信号 。根据公式(《通信原理》)，采样结果正好是对发送序列进行离散傅里叶反变换(IDFT)的结果，所以，我们可以 &lt;em&gt;借助 IDFT 即可得到 OFDM 复包络的时间采样 。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;发送端框图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="transmitter" src="/images/learning-ofdm-basic/transmitter.png" /&gt;&lt;/p&gt;
&lt;h4&gt;接收端 Receiver&lt;/h4&gt;
&lt;p&gt;基带系统接收端要实现的功能是对采样序列 {a1,a2,a3...} 进行变换，得到发送端发送过来的信息序列 {A1,A2,A3...} 。&lt;/p&gt;
&lt;p&gt;接收端通过 I/Q 正交解调可以恢复 OFDM 信号的复包络，将其采样得到的时间序列 。因为发送端采用的 IDFT 是可逆变换，所以对采样结果进行 DFT 就可以得到发送序列 。&lt;/p&gt;
&lt;p&gt;当序列的点数为 2 的整幂次时，DFT 和 IDFT 存在快速算法： FFT 和 IFFT 。&lt;/p&gt;
&lt;p&gt;接收端框图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="receiver" src="/images/learning-ofdm-basic/receiver.png" /&gt;&lt;/p&gt;
&lt;h3&gt;循环前缀 cyclic prefix&lt;/h3&gt;
&lt;p&gt;为了有效对抗多径信道的时延扩展，OFDM 系统由多个子载波构成，只要子载波的取值可以满足符号周期远大于信道的时延扩展，就可以达到目标。在此基础上，还需要采取措施消除前后两个 OFDM 符号之间的 &lt;strong&gt;码间干扰 ISI&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;一种方法是在每个 OFDM 符号之间插入 &lt;strong&gt;保护间隔 Guard Interval&lt;/strong&gt; 。为了对抗信号因信道延迟的影响，Gurad interval(Tg) 长度要大于最大的 Delay spread，即 Tg &amp;gt; delay spread time。&lt;/p&gt;
&lt;p&gt;在保护区间未放信号的 OFDM 系统称 ZP-OFDM(zero padding)。ZP-OFDM 有比较低的传输功率，但在接收端接收于 zero padding 区域信号时，会破坏载波的正交性造成 “&lt;strong&gt;载波间的干扰（ICI）&lt;/strong&gt;”，所以复制 OFDM symbol 后半段信号并摆放于保护区间内，称之为 &lt;strong&gt;循环字首(cyclic prefix)&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3&gt;加窗技术&lt;/h3&gt;
&lt;p&gt;前面介绍了 OFDM 符号的生成、循环前缀消除码间干扰，但是此时符号边界有尖锐的相位跳变，由此可知，OFDM 的带外衰减是比较慢的 。虽然随着载波数目的增大，OFDM 信号的带外衰减会增加，但是仍然不够快 。&lt;/p&gt;
&lt;p&gt;为了使 OFDM 信号的带外衰减更快，可以采用对单个 OFDM 符号加窗的方法 。OFDM 的窗函数可以使信号的幅度在u符号边界更平滑地过渡到 0 。常用的窗函数是 &lt;strong&gt;升余弦滚降窗&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;增大滚降因子虽然能够使带外衰减更快，但降低了 OFDM 系统对多经实验的容忍能力，所以 &lt;em&gt;在实际系统设计中，应当选择较小的滚降因子 。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;OFDM 系统设计&lt;/h3&gt;
&lt;p&gt;OFDM 系统框图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ofdm-system" src="/images/learning-ofdm-basic/ofdm_system.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;交织&lt;/strong&gt; 是为了克服深衰落发生突发差错的影响，如果交织器的长度足够大，解交织后可将突发差错改造为独立差错，再通过纠错译码来纠正 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在发送端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;二进制数据&lt;/em&gt; 通过纠错编码、交织后映射到 QAM 星座得到 &lt;em&gt;一个 QAM 复数符号序列&lt;/em&gt;，再经过并串转换，得到 &lt;em&gt;N个并行 QAM 符号&lt;/em&gt;，每个符号进行 IFFT，将 OFDM 复包络的频域样值变换为 &lt;em&gt;时域样值&lt;/em&gt;，进行并串转换，将时域样值变换为按时间顺序排列的 &lt;em&gt;时域样值&lt;/em&gt;，然后在每个 OFDM 符号前插入前缀，通过 D/A，将离散的复包络变成 &lt;em&gt;连续时间的复包络&lt;/em&gt; 。再将复包络的 I(t) 和 Q(t) 正交调制得到 &lt;em&gt;OFDM信号&lt;/em&gt;，将基带信号上变频到射频，经过功放，发送出去 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在接收端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收端于发送端进行相反的变换，恢复出原数据 .&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1446684/"&gt;《通信原理》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4130536/"&gt;《移动通信原理》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Orthogonal_frequency-division_multiplexing"&gt;OFDM wikipedia&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="OFDM"></category></entry><entry><title>脉冲边沿检测</title><link href="http://guqian110.github.io/pages/2014/04/08/pulse_edge_detection.html" rel="alternate"></link><updated>2014-04-08T18:33:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-08:pages/2014/04/08/pulse_edge_detection.html</id><summary type="html">&lt;p&gt;脉冲边沿检测是 FPGA 设计中经常用到的方法，本文总结一下其原理和实现代码，可以将其加入我们自己的代码库中，以备以后使用 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测原理&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="pulse" src="/images/learning-fpga-pulse-edge-detection/pulse.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;如图，任何一个脉冲既有上升沿也有下降沿，系统的时钟周期一定要比脉冲宽度小，而且越小越好，即频率越高越好 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脉冲边沿的特点就是：边沿两侧的电平发生了变化 。&lt;/strong&gt; 利用这一点，我们就可以设计出检测边沿的方法 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作方法：&lt;/strong&gt; 建立 2 个寄存器，形成二级寄存器，在时钟触发中，首先把数据送入第一个寄存器中，然后在下一个时钟上沿到来时，将第一个寄存器中的数据存入第二个寄存器，也就是说第二个寄存器中的数据始终比第一个寄存器晚一个周期，即晚一个数据 。根据系统时钟检测，如果前后进来的信号发生了变化，可以用异或运算，异或结果为1，说明电平发生了变化，有边沿产生。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测方法&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;检测是否有边沿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
        &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_edge&lt;/span&gt;  
        &lt;span class="p"&gt;);&lt;/span&gt; 

        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trigedge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
        &lt;span class="n"&gt;end&lt;/span&gt;  

        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trigEdge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

    &lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl1" src="/images/learning-fpga-pulse-edge-detection/rtl1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim1" src="/images/learning-fpga-pulse-edge-detection/sim1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;检测 上/下 边沿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;下降沿检测原理：&lt;/strong&gt; 将第一个寄存器中的数据取反与第二个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 1 变为 0 时，就会在新的寄存器里产生一个高电平，并维持一个周期 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上升沿检测原理：&lt;/strong&gt; 将第二个寄存器中的数据取反与第一个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 0 变为 1 时（上升沿，此时 r1 变为 1，但 r2 仍保持前一周期的 0），就会在新的寄存器里产生一个高电平，并维持一个周期 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
        &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;  
        &lt;span class="p"&gt;);&lt;/span&gt;  

        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
        &lt;span class="n"&gt;end&lt;/span&gt;  

        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// Detect posedge  &lt;/span&gt;
        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// Detect negedge  &lt;/span&gt;

    &lt;span class="n"&gt;endmodule&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl2" src="/images/learning-fpga-pulse-edge-detection/rtl2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim2" src="/images/learning-fpga-pulse-edge-detection/sim2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外一种写法：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
        &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tirg_pos_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;  
        &lt;span class="p"&gt;);&lt;/span&gt;  

        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="k"&gt;else&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
        &lt;span class="n"&gt;end&lt;/span&gt;  

        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  

    &lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl3" src="/images/learning-fpga-pulse-edge-detection/rtl3.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim3" src="/images/learning-fpga-pulse-edge-detection/sim3.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测应用&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;理想的键盘输入特性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keyboard1" src="/images/learning-fpga-pulse-edge-detection/keyboard1.png" /&gt;&lt;/p&gt;
&lt;p&gt;然而实际的键盘受制造工艺等影响，其输入特性不可能如上图完美 。当按键按下时，在触点即将接触到完全接触这段时间里，键盘的通断状态很可能已经改变了多次 。即在这段时间里，键盘输入了多次逻辑 0 和 1，也就是输入处于失控状态 。如果这些输入被系统响应，则系统暂时也将处于失控状态，这是我们要尽量避免的 。在触点即将分离到完全分离这段时间也是一样的 。&lt;/p&gt;
&lt;p&gt;实际的键盘输入特性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keyboard2" src="/images/learning-fpga-pulse-edge-detection/keyboard2.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件消抖&lt;/strong&gt; 要占用系统资源，在系统资源充足的情况下使用软件消抖更加简单 。软件消抖的实质在于降低键盘输入端口的采样频率，将高频抖动略去 。实际应用中通常采用延时跳过高频抖动区间，然后再检测输入做出相应处理。一般程序代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="c1"&gt;//一旦检测到键值&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Delay&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;//延时20ms，有效滤除按键的抖动&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;//再次确定键值是否有效&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt;    &lt;span class="c1"&gt;//执行相应处理&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段软消抖程序从机理上看不会有什么问题，通常在软件程序不太 "繁忙" 的情况下也能够很好的消抖并做相应处理 。但是如果在延时期间产生了中断，则此中断可能无法得到响应 。&lt;/p&gt;
&lt;p&gt;对于硬件资源丰富的 FPGA 系统，可以使用硬件来减轻软件工作量，通常称之为 &lt;strong&gt;"硬件加速"&lt;/strong&gt; 。在按键信号输入到软件系统前用逻辑对其进行一下简单的处理即可实现所谓的"硬件消抖"，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;//对输入信号inpio硬件滤波，每20ms采样一次当前值&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//20ms计数器&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_25m&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d500000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; 
            &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//当前inpio信号锁存，每20ms锁存一拍&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_25m&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;h7ffff&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;inpio_swin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//前后20ms两次锁存值都为0时才为0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该程序中设置了一个 20 ms 计数器，通过间隔 20 ms 对输入信号 inpio 采样两次，两次相同则认为键盘输入稳定，得到用硬件逻辑处理后的 inpio_swin 信号则是消抖处理过的信号 。程序不再需要 delay() 来滤波了，也不会出现使用纯软件处理出现的 "中断失去响应" 的情况了，这就是 "硬件加速" 的效果 。&lt;/p&gt;
&lt;p&gt;我们可以看到，传统单片机等系统大多是串行处理，即顺序执行，只能并行处理一些中断程序 。对于这样的系统，只能采用单纯软件或硬件电路消抖，但都不那么完美 。而对于 FPGA 等并行处理的系统，其优势就很明显，只要片内逻辑资源够用，通过硬件加速软件消抖的处理，完全可以做到按键消抖并行化，不影响系统的实时性 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG_ARTICLE_213430.HTM"&gt;脉冲边沿检测（Verilog）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/lg2lh/article/details/8104551"&gt;脉冲边沿检测原理verilog版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/LVY33/article/details/6225925"&gt;脉冲边缘检测法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_790c0ca10100srid.html"&gt;按键消抖&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category></entry><entry><title>(转载) 如何学习 FPGA</title><link href="http://guqian110.github.io/pages/2014/04/07/learning_fpga_how_to.html" rel="alternate"></link><updated>2014-04-07T16:16:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-07:pages/2014/04/07/learning_fpga_how_to.html</id><summary type="html">&lt;p&gt;学习 FPGA 差不多一年多，长期混迹于各大论坛，让我学习到了很多知识，转载一篇文章。&lt;/p&gt;
&lt;p&gt;当年在对于 FPGA 什么都不懂的情况下，觉得这篇文章相当高大上，现在看来，的确如此～和别的入门级别的文章书籍相比，这篇文章没有涉及 FPGA 设计的细节，而是很精炼地讲了 FPGA 设计中最基本的 &lt;em&gt;“世界观”&lt;/em&gt; 。也就是说这篇没有一头扎进 &lt;strong&gt;“术”&lt;/strong&gt; 的内容中让读者无从读起，而是从整体上给出 FPGA 设计的 &lt;strong&gt;“道”&lt;/strong&gt; 。对于初学者——尤其是我这样从软件思维过渡过来的人，的确是不错的入门指导 。&lt;/p&gt;
&lt;p&gt;转载地址：&lt;a href="http://www.ednchina.com/ART_8800513345_18_20010_TA_38ec22f4.HTM"&gt;如何学习FPGA？FPGA学习必备的基础知识&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;FPGA已成为现今的技术热点之一，无论学生还是工程师都希望跨进FPGA的大门。网络上各种开发板、培训班更是多如牛毛，仿佛在告诉你不懂FPGA你就OUT啦。那么我们要玩转FPGA必须具备哪些基础知识呢?下面我们慢慢道来。&lt;/p&gt;
&lt;h2&gt;要了解什么是FPGA&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;既然要玩转FPGA，那我们首先最重要的当然是要了解什么 FPGA 。FPGA（Field-Programmable Gate Array），即现场可编程门阵列 。看到编程两个字码农就笑了，不就是编程嘛，那可是我们的强项 。且慢，此编程非彼编程 。一定要把 FPGA 的编程和软件编程区分开来 。软件的编程，处理器会逐条的把语言翻译成各种控制信号，去控制内部电路完成一个个运算或操作 。那么FPGA的编程是怎么实现的呢？无论 Altera 家还是 Xlinix 家的 FPGA，叫法有什么差异，基本单元都相似，都是由真值表和 D 触发器构成 。改变真值表的值就改变了逻辑功能，再通过和D触发器组合来实现任何时序逻辑 。所以我们对 FPGA 的编程，实际上就是去修改这些真值表和连接关系，使他们组成一张专门的真值表，去实现特定的功能 。这和软件编程一步步运行程序有本质的区别 。要想玩转 FPGA，就必须理解 FPGA 内部的工作原理，学习如何利用这些单元实现复杂的逻辑设计 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;正确理解HDL语言&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;HDL（Hardware Description Language），硬件描述语言 。通过名称我们能看出来，HDL语言是一种 “描述” 语言，这一点和 C 语言是有本质区别的 。正确理解描述的含义，对学好 HDL 语言很有帮助 。HDL 语言只是用文本的方式把硬件电路描述出来 。我们在阅读 HDL 程序的时候，在脑子里应该能反映出一个完整的硬件电路结构 。从另一方面说，我们在编写 HDL 语言之前，就已经对要实现的电路有清晰的概念 。所以 HDL 语言只是一个描述我们头脑中具体电路的工具，&lt;strong&gt;玩转 FPGA 的根本不是语言而是逻辑电路设计&lt;/strong&gt;。不要再纠结于我应该学习 VHDL 还是 Verilog，哪种语言更好学这些问题 。如果把学习 FPGA 的重点放在学习语言上，死记硬背一些语法，那自然是抓错了重点 。语言在日常使用中会越用越熟练，不需要花很长的专门时间去学习 。当然一本好的参考资料可以随时方便查询会是很有帮助的 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;数字电路基础&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;说到底，FPGA 就是一堆数字逻辑组合在一起实现特定功能而已 。所以数字电路基础知识是根本 。如果你连触发器，组合电路，时序电路，竞争，毛刺等等基本概念还莫能两可不清不楚的话，那玩转 FPGA 只能是痴人说梦的幻想了 。我们必须要好好的学好数字电路基础这门课，基本的数字电路烂熟于心 。把这些基础打牢固，再往更深的方向发展 。什么时候能够从抽象的算法中提炼算法的结构，再分解成具体的模块并通过硬件电路实现出来，这时候就算从菜鸟级别步入老鸟级别了 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;硬件设计思想&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;这一点应该说是重中之重 。学习 FPGA，一定要有硬件设计思想 。在软件编程的时候，比如 1 秒钟能实现 5 次乘法运算，那系统要求 1 秒钟实现 50 次乘法运算怎么办，我们会尽可能的优化代码，让代码更简洁更高效，或者提高系统主频，让系统跑的更快 。但是在 FPGA 里面我们不是这种思维方式。在 FPGA 里实现一个乘法器不够用，那我就实现两个实现三个去满足系统要求；我可以进行流水线设计；串行运行方式不够快了，我可以先串并转换，再并行的做处理 — —只要 FPGA 的资源够用，我可以充分利用资源去满足系统要求 。因为在我手里的就是一堆硬件资源，我要做的是把他们组合成一个好用的电路 。评价硬件描述语言写的好坏的标准和其他软件编程语言的标准是完全不同的 。因此一定要摒弃软件编程的一些固有思路，学会用硬件的方式去解决问题 。时刻提醒自己正在设计的是一个电路，而不是一行行空洞的代码 。这是很多做软件编程的人很难跨过的坎 。FPGA 学了很久还在纠结到底是用 &lt;code&gt;if-else&lt;/code&gt; 语句好呢还是用 &lt;code&gt;case&lt;/code&gt; 语句好？而不能透过这些语句表面看到他们所具体代表的电路 。只有建立了硬件设计思想，才有更深入学习FPGA的可能 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;FPGA 入门简单精通难 。要想入门，买一块开发板跟着例程走一遍，很多人都能在很短的时间内熟悉开发软件的操作方法并且点亮开发板上的 LED 或者再实现个跑马灯什么的，但是再往后进步往往就进展很慢 。上面提到的这四条是玩转 FPGA 的基础，只有打好了坚实的基础后面才能一马平川 。希望每个学习 FPGA 的人最后都能成为大牛，设计出自己的完美电路 。&lt;/p&gt;</summary><category term="FPGA"></category></entry><entry><title>编写可综合的 Verilog HDL 代码</title><link href="http://guqian110.github.io/pages/2014/04/04/writing_synthesizable_code.html" rel="alternate"></link><updated>2014-04-04T01:35:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-04:pages/2014/04/04/writing_synthesizable_code.html</id><summary type="html">&lt;p&gt;对电路建模方法有很多种，可以用绘制原理图，也可以用 &lt;em&gt;硬件描述语言（Hardware Description Language）&lt;/em&gt; 建模 。硬件描述语言中最常用的就是 Verlilog 和 VHDL 。&lt;/p&gt;
&lt;p&gt;Verilog HDL和VHDL相比有很多优点，有C语言基础的话很容易上手。搜集了一些网上大神的经验总结和书上的例子，所以对于和我一样的初学者，这篇博客应该还是很有提高作用的，至于具体语法，任何一本书都讲的很详细。&lt;/p&gt;
&lt;h2&gt;HDL&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;从网上找到一篇文章，把 HDL 的历史说的非常清楚。&lt;/p&gt;
&lt;p&gt;作者 董培良 &lt;/p&gt;
&lt;p&gt;题目： &lt;a href="http://www.dzkf.cn/html/EDAjishu/2006/0720/9.html"&gt;浅谈VHDL/Verilog的可综合性以及对初学者的一些建议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要明确的是 VHDL 和 Verilog 并非是针对硬件设计而开发的语言，只不过目前被我们用来设计硬件。HDL 是 Hardware &lt;strong&gt;Description&lt;/strong&gt; Language 的缩写，正式中文名称是 “硬件描述语言”。也就是说，HDL 并不是 “硬件设计语言（Hardware &lt;strong&gt;Design&lt;/strong&gt; Language）”。别看只差这一个单词，正是这一个单词才决定了绝大部分电路设计必须遵循RTL的模式来编写代码，而不能随心所欲得写仅仅符合语法的 HDL 代码。&lt;/p&gt;
&lt;p&gt;VHDL 于 1980 年开始在美国国防部的指导下开发，完成于 1983 年，并于 1987 年成为 IEEE 的标准。当初开发这种语言，是出于美国国防部采购电子设备的需要。美军的装备采购自私人企业，时常要面对这样一种风险：如果某种武器大量装备部队，而其中某个零件的供应商却在几年后倒闭了，那这种武器的再生产、维修和保养都会出现大问题。而电子设备、尤其是集成电路的内部结构较为复杂，若出现前面所说的情况要找其他公司生产代用品非常困难。于是美国防部希望供应商能以某种形式留下其产品的信息，以保证一旦其破产后能由其他厂商迅速生产出代用品。&lt;/p&gt;
&lt;p&gt;显然，当初的设计文档显然是不能交出来的，这在美国会涉及商业机密和知识产权问题。于是美国防部就想出了一种折衷的方法——描述硬件的语言，也就是 VHDL 。通过 VHDL，供应商要把自己生产的集成电路芯片的行为描述出来：比如说，加了什么样的信号后过多少时间它能输出什么等等。这样，如果有必要让其他厂商生产代用品，他们只需照着 VHDL 文档，设计出行为与其相同的芯片即可。这样的代用品相当于是新厂商在不了解原产品结构的情况下独立设计的，所以不太会涉及知识侵权。&lt;/p&gt;
&lt;p&gt;Verilog HDL 也形成于差不多的年代，是由 Gateway Design Automation 公司大约在 1983 年左右开发的。其架构同 VHDL 相似，但主要被用来进行硬件仿真。或许私人公司更注重实用，Verilog 要比 VHDL 简洁得多。&lt;/p&gt;
&lt;p&gt;由此可见，这两种最流行的用于电路设计的语言，没有一种是为了设计硬件而开发的（更何况 80 年代还没有现在的那些功能强大的EDA软件呢）。因此，当初制订 HDL 语言标准的时候，并没有考虑这些代码如何用硬件来实现。换句话说，有些代码写起来简单，实现起来却可能非常复杂，或者几乎不可能实现。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;可综合代码&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;任何符合 HDL 语法标准的代码都是对硬件行为的一种描述，但不一定是可直接对应成电路的设计信息。行为描述可以基于不同的层次，如系统级，算法级，寄存器传输级(RTL)、门级等等。以目前大部分EDA软件的综合能力来说，&lt;strong&gt;只有RTL或更低层次的行为描述才能保证是可综合的&lt;/strong&gt;。而众多初学者试图做的，却是想让软件去综合 &lt;em&gt;算法级或者更加抽象的硬件行为描述&lt;/em&gt;。&lt;/p&gt;
&lt;h3&gt;所有综合工具都支持的语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="nx"&gt;always&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="nx"&gt;wire&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;tri&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;inout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;aupply0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;supply1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="nx"&gt;and&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;nand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;nor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;xor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;xnor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;not&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;bufif0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;bufif1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;notif0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;notif1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;instantitation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;module&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;negedge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;posedge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;operators&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parameter&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;有些工具支持，有些工具不支持的语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;asex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;casez&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;triand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;trior&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;disable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forever&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arrays&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;memories&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;repreat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建立可综合模块的原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不要用 initial （FPGA 上电时初始状态不定，一般需要上电复位信号，在复位信号有效的时候进行初始化，上电复位信号可以由外部手动输入，也可以系统自己产生 —— 写一个实现上电产生自动复位信号的模块）。P.S. 现在的综合软件功能已经足够强大，即使写了 initial 语句，在 ISE 13.3 中仍然是可综合的，而且没有 warning 和 info 的提示）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用 &lt;code&gt;#10&lt;/code&gt;（在仿真中有用，实际在硬件上不会实现）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用循环次数不定的循环语句，如 &lt;code&gt;forever&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt; 等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用用户自定义原语（UDP 原件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除非是关键路径设计，一般不采用调用门级原件描述的设计的方法，建议采用行为语句完成设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用同步方式设计电路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;code&gt;always&lt;/code&gt; 语句描述组合逻辑时，在敏感信号列表中要列出所有输入信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的内部寄存器都应该可以被复位，在 FPGA 设计时应尽量使用器件的全局复位端信号作为系统的总复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序逻辑使用非阻塞赋值，组合逻辑使用阻塞赋值，同一过程块中不要同时使用阻塞和非阻塞两种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要在不同的 &lt;code&gt;always&lt;/code&gt; 过程块中对同一变量赋值（否则综合时会提示有多驱动源错误，&lt;em&gt;multiple source
&lt;/em&gt;），对同一赋值对象，不能既使用阻塞赋值，又使用非阻塞赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不打算把变量综合成锁存器，在 &lt;code&gt;if&lt;/code&gt; 语句或 &lt;code&gt;case&lt;/code&gt; 语句的所有分支中都要对变量明确赋值（不能省去 &lt;code&gt;else&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt;，原理：在省去的情况下，变量的值会保持原来的值不变，所以系统会综合出一个锁存器 Latch）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免混合使用上升沿和下降沿触发器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一变量的赋值不能受多个时钟控制，也不能受两种不同时钟条件（或不同时钟沿）控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免在 &lt;code&gt;case&lt;/code&gt; 语句中使用 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;z&lt;/code&gt; 值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;不可综合代码&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;不可综合语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;defparam&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delays&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UDP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wait&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;initial&lt;/code&gt; 只能在 Testbench 中使用，不能综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;events&lt;/code&gt; 在 Testbench 中更有用，不能综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;real&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;time&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;force&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;assign&lt;/code&gt; 和 &lt;code&gt;deassign&lt;/code&gt; 不支持 &lt;code&gt;reg&lt;/code&gt; 类型的综合，支持 &lt;code&gt;wire&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fork...join&lt;/code&gt; 不可综合，可以用非块语句达到同样的效果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;primitives&lt;/code&gt; 支持门级原语综合，不支持非门级原语综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;table&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt; 的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一个 &lt;code&gt;reg&lt;/code&gt; 被多个 &lt;code&gt;always&lt;/code&gt; 块驱动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;延时，不可综合为硬件电路延时，综合工具会忽略延时，但是不会报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与 &lt;code&gt;x&lt;/code&gt;、&lt;code&gt;z&lt;/code&gt; 比较，综合工具会忽略，所以要保证信号只有两个状态，&lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;判断是否可综合&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;继续引用 &lt;strong&gt;董培良&lt;/strong&gt; 的文章：&lt;/p&gt;
&lt;p&gt;用一句简单的话概括：电脑永远没有你聪明 。具体来说，通常 EDA 软件对 HDL 代码的综合能力总是比人差 。对于一段代码，如果你不能想象出一个较直观的硬件实现方法，那 EDA 软件肯定也不行。比如说，加法器、多路选择器是大家都很熟悉的电路，所以类似&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的运算一定可以综合。而除法、开根、对数等等较复杂的运算，必须通过一定的算法实现，没有直观简单的实现方法，则可以判断那些计算式是不能综合的，必须按它们的算法写出更具体的代码才能实现 。此外，硬件无法支持的行为描述，当然也不能被综合（比如想在 FPGA 上实现 DDR 内存那样的双延触发逻辑，代码很容易写，但却不能实现）。&lt;/p&gt;
&lt;p&gt;不过，这样的判断标准非常主观模糊，遇到具体情况还得按设计人员自己的经验来判断 。如果要一个相对客观的标准，一般来说：在 RTL 级的描述中，所有逻辑运算和加减法运算、以及他们的有限次组合，基本上是可综合的，否则就有无法综合的可能性 。当然，这样的标准仍然有缺陷，更况且 EDA 的技术也在不断发展，过去无法综合的代码或许将来行，某些软件不支持的代码换个软件或许行 。比如固定次数的循环，含一个常数参数的乘法运算等等，有些 EDA 软件支持对它们的综合，而有些软件不行。&lt;/p&gt;
&lt;p&gt;所以，正确的判断仍然要靠实践来积累经验。当你可以较准确判断代码的可综合性的时候，你对 HDL 的掌握就算完全入门了。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.dzkf.cn/html/EDAjishu/2006/0720/9.html"&gt;浅谈VHDL/Verilog的可综合性以及对初学者的一些建议&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="Verilog"></category></entry><entry><title>学习 FPGA 入门</title><link href="http://guqian110.github.io/pages/2014/04/03/learning_fpga_getting_started.html" rel="alternate"></link><updated>2014-04-03T12:40:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-03:pages/2014/04/03/learning_fpga_getting_started.html</id><summary type="html">&lt;h2&gt;FPGA 是什么&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 是 PLD 家族中的一员，要说清楚什么是 FPGA，就不得不说一说 PLD 。（&lt;strong&gt;以下内容来自wikipedia&lt;/strong&gt;）&lt;/p&gt;
&lt;h3&gt;PLD &amp;amp; ASIC&lt;/h3&gt;
&lt;p&gt;早期的数字逻辑系统，是由中、小规模集成电路芯片搭建而成的。这种形式的电路在可靠性、工作速度、功耗和体积方面都难以满足大规模、高性能信息处理系统的要求 。后来，随着集成电路的发展，出现可专用集成电路 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专用集成电路&lt;/strong&gt;（Application Specific Integrated Circuits, &lt;a href="http://en.wikipedia.org/wiki/Application-specific_integrated_circuit"&gt;&lt;code&gt;ASIC&lt;/code&gt;&lt;/a&gt;）是指依产品需求不同而非通用目的，而自定义的特殊规格集成电路 。ASIC 可以将整个系统集成到一个芯片上。由于芯片内集成度高、连线短，所以它可以满足之前 ”搭建系统“ 难以满足的性能指标 。&lt;/p&gt;
&lt;p&gt;随着芯片尺寸的减小和设计工具的发展，这些年来 ASIC 芯片最大的集成度从 5,000 增长到了 超过100,000,000 门 。现代的 ASIC 通常都包含了微处理器、存储块（如 ROM 、RAM 、EEPROM 、Flash 等）。这种 ASIC 被称为 SoC （&lt;a href="http://en.wikipedia.org/wiki/System-on-chip"&gt;system on chip&lt;/a&gt;），ASIC 设计师采用硬件描述语言（Hardware Description Language，HDL），比如 Verilog、VHDL，描述 ASIC 的功能 。&lt;/p&gt;
&lt;p&gt;但是 ASIC 的研制周期长，现代信息处理的快速发展要求集成电路的设计、测试和生产周期尽可能的段，这就促进了可编程逻辑器件的发展 。严格地说，有些可编程器件出现的时间比 ASIC 出现的早，这里说的可编程器件主要是指 CPLD/FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可编程逻辑器件&lt;/strong&gt;（Programmable Logic Device,&lt;a href="http://en.wikipedia.org/wiki/Programmable_logic_devices"&gt;&lt;code&gt;PLD&lt;/code&gt;&lt;/a&gt;）是一种用来搭建可重配置数字电路的电子器件。和逻辑门（logic gate）不同，PLD 出厂时逻辑功能是没有被定义的，在使用之前，必须先重配置（reconfigure）。&lt;/p&gt;
&lt;h3&gt;历史&lt;/h3&gt;
&lt;h4&gt;ROM as PLD&lt;/h4&gt;
&lt;p&gt;在 PLD 器件被发明之前，就已经有人 &lt;em&gt;将 &lt;a href="http://en.wikipedia.org/wiki/Read-only_memory"&gt;ROM&lt;/a&gt; 以 PLD 的概念来运用&lt;/em&gt;，用 ROM 芯片来充当一些输入性的组合逻辑（combinatorial logic）的函数发生器。ROM 有 m 个地址线，则有 &lt;code&gt;n = 2^m&lt;/code&gt; 个输出结果，这和布尔逻辑是一一对应的，所以如果把 ROM 的地址线当作相互之间没有关系的输入，则相应的输出就可以实现不同的函数。&lt;/p&gt;
&lt;p&gt;早期的 Mask ROM 存储数据的方式是使用内部的硬件电路，所以只能在出厂时就写入数据，而且以后不能更改。这就导致了一系列缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因为消费者必须联系制造商才能生产出自定义的芯片，所以只有买大量的 ROM 芯片时才经济划算 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为同样的原因，从设计到最终生产出产品，中间耗费的时间很长 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mask ROM 在研发中基本上不能使用，因为设计师在改进设计时需要经常改动 ROM 里面的值 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个设备中含有故障的 Mask ROM，那么修复这个设备的唯一方法就是召回设备并且更换其中的每一个 Mask ROM 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;PROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_read-only_memory"&gt;PROM&lt;/a&gt;（Programmable Read Only Memory）是周文俊于 1956 年发明的。他在纽约 Garden City 的 American Bosch Arma Corporation 工作，当时，美国空军为了提升空军用计算机以及Atlas E/F波段导弹的灵活性和保安性而提出要求，这项技术就是为了满足这一要求而产生的 。&lt;/p&gt;
&lt;p&gt;PROM 是通过熔丝/反熔丝（fuse/antifuse）实现对每个 bit 的设置 。通过使用高电压脉冲改变内部的物理结构，这种方法通常是不可逆的，所以它只允许用户更改一次配置 。PROM 解决了上面提到的问题 1 和问题 2 ，因为公司可以买一大批没有配置过的 PROM，设计人员可以根据自己的需要随意配置 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EPROM"&gt;EPROM&lt;/a&gt;（Erasable Programmable Read Only Memory）是 intel 公司的 Dov Frohman 于 1971 年发明的 。与 PROM 不同的是，EPROM 可利用高电压将资料编程写入，通过紫外线照射的方式不断的重置为未配置状态。因此，在封装外壳上会预留一个石英玻璃所制的透明窗以便进行紫外线曝光。写入程序后通常会用贴纸遮盖透明窗，以防日久不慎曝光过量影响资料。&lt;/p&gt;
&lt;p&gt;因为EPROM 可以重复配置，所以它解决了上面的第 3 个问题 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EEPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EEPROM"&gt;EEPROM&lt;/a&gt;（Electrically Erasable Programmable Read-Only Memory）于 1983 年被发明出来。相比EPROM，EEPROM不需要用紫外线照射，也不需取下，就可以用特定的电压，来抹除芯片上的信息，以便写入新的数据 。&lt;/p&gt;
&lt;p&gt;如果设备可以从外部接收数据（比如 PC 通过串口线），就可以在线配置 EEPROM，这样它解决了问题 4 。&lt;/p&gt;
&lt;p&gt;虽然解决了上面的 4 个问题，但是把 ROM 当作 PLD 器件使用，还是有很多弊端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;与专用逻辑电路相比，ROM 的速度很慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当输入不同步时（异步状态），ROM 的输出有毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更加耗电&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与可编程逻辑相比，价格更贵，尤其是高速应用中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而且，大部分 ROM 没有输出寄存器，所以它不能直接应用在时序电路中，所以在状态机的设计中，通常还需要一个外部的 TTL 寄存器 。对电路设计的业余爱好者来说，有时也仍然用“2716”之类的普遍型EPROM芯片来充当PLD，这种用法有时也称为“穷人的PAL”。（PAL也是PLD的一种，以下将再进一步说明）&lt;/p&gt;
&lt;p&gt;于是，就出现了 PLD 器件。&lt;/p&gt;
&lt;h4&gt;早期可编程逻辑&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1969 年，Motorola 生产出 XC157，它是一个有 12 个逻辑门和 30 个独立输入/输出管脚的可编程逻辑正列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（PLA）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1971 年，通用电器公司（GE）在新的 PROM 技术的基础上发明了一种可编程逻辑器件。这个实验性质的设备通过使用多层逻辑来提高 IBM 的 ROAM 性能 。GE 的这个设备是最早的 PLD 设备，比 Altera 的 EPLD 早了十几年 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1974 年，GE 和 Monolithic Memories 达成协议，开发一种可编程逻辑器件。这个设备被称为 ”Programmable Associative Logic Array“ 或者是 PALA 。最终于 1976 年完成 MMI 5760 ，它可以实现超过 100 门的时序电路。GE 的开发环境支持这一器件，它可以直接将布尔表达式转化为配置器件的代码，然而最终这个器件却没有上市。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;PLA&lt;/h4&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（&lt;a href="http://en.wikipedia.org/wiki/Programmable_Logic_Array"&gt;PLA&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;PLA 具有一组可编程的 AND 阵列，AND 阵列之后连接一组可编程的 OR 阵列 ，这样就可以只在合乎设定条件时才允许产生逻辑信号输出 。&lt;/p&gt;
&lt;p&gt;虽然名字中含有可编程 3 个字，但是并不是所有的 PLA 都可以现场编程，事实上许多都属遮罩性的可编程化，性质与ROM相同，必须在芯片制造厂内就执行与完成程序化设定，尤其是内嵌于电路较复杂的芯片（例如：微处理器）的PLA多属此种程序化方式。&lt;/p&gt;
&lt;h4&gt;PAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_Array_Logic"&gt;PAL&lt;/a&gt;（Programmable Array Logic）是 Monolithic Memories 公司在 1978 年 3 月提出的，在数字电路中用来搭建逻辑功能的可编程器件的总称 。PAL 内部含有固定的或门阵列，可编程的与门阵列，从而实现所要求的逻辑函数。&lt;/p&gt;
&lt;p&gt;PAL 内部有个 PROM 的核，外部附加的输出逻辑电路，这样就可以实现所需要的逻辑功能 。因为 PAL 是基于 PROM 的，所以要使用特殊的设备，PAL 才具有可编程性，而且是 ”一次编程“ 。&lt;/p&gt;
&lt;h4&gt;GAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Generic_array_logic"&gt;GAL&lt;/a&gt;（Generic array logic）是 PAL 的发展，是 Lattice Semiconductor 于 1985 年发明 。这个设备具有和 PAL 同样的功能，但是可以重配置多次，所以 GAL 在设计中很有用，一旦有错误，只需要擦除后重新配置即可 。&lt;/p&gt;
&lt;p&gt;后来，International CMOS Technology (ICT) 公司发明了 类似的设备，称为 PEEL（programmable electrically erasable logic）。&lt;/p&gt;
&lt;h4&gt;CPLD&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Complex_programmable_logic_device"&gt;CPLD&lt;/a&gt;（Complex programmable logic device）适合用来实现各种运算和组合逻辑（combinational logic）。PAL、GAL仅适合用在约数百个逻辑门所构成的小型电路，若要实现更大的电路则适合用 CPLD，一颗CPLD内等于包含了数颗的PAL，各PAL（逻辑区块）间的互接连线也可以进行程序性的规划、烧录，CPLD运用这种多合一（All-In-One）的整合作法，使其一颗就能实现数千个逻辑门，甚至数十万个逻辑门才能构成的电路。&lt;/p&gt;
&lt;p&gt;CPLD 与 PAL 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非易失性配置存储器。与 FPGA 不同，CPLD v不需要外部的 ROM，只要系统上电，就可以正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于许多旧的 CPLD 来说，布线约束要求大部分逻辑块要和输入输出相连接，以减少内部状态记录，对于新的 CPLD 系列来说，已经不需要这样了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPLD 与 FPGA 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以利用大量的逻辑资源，CPLD 等价有有数百万的逻辑门资源可以用来实现比较复杂的设计，而 PAL 最多等价有几千个逻辑门，FPGA 有几万到几百万的逻辑门。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供一些更加灵活的资源，比如宏模块之间复杂的反馈连接和整数运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大的 CPLD 和小 FPGA 之间最显著的差别就是 CPLD 含有片内非易失性存储器 。因为非易失性存储器的特点，CPLD 在数字电路设计中被当作 ”boot loader“ 来使用，之后它再把系统的控制权转交给没有这种特性的设备，最好的例子就是使一块 CPLD 从非易失性存储器中装载配置 FPGA 所需要的数据 。&lt;/p&gt;
&lt;h4&gt;FPGA&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array"&gt;FPGA&lt;/a&gt;（Field Programmable Gate Array，FPGA）是在 PAL、GAL、CPLD 等可编程逻辑器件的基础上进一步发展的产物。它是作为专用集成电路领域中的一种半定制电路而出现的，既解决了全定制电路的不足，又克服了原有可编程逻辑器件门电路数有限的缺点。&lt;/p&gt;
&lt;p&gt;当 PAL 忙于进展成 GAL、CPLD 时，另一种 “可编程化” 的流派也逐渐成形，此称之为现场可编程闸阵列（Field Programmable Gate Array，FPGA）。FPGA是以阵列（Gate Array）技术为基础所发展成的一种PLD 。所谓 ”Field Programmable“ 就是说芯片是出厂以后由客户或者设计师配置而工作的 。&lt;/p&gt;
&lt;p&gt;1980 年代后期，Naval Surface Warfare Department 在 Steve Casselman 的提议下成立了实验项目，目的是为了研制一台由 600,000 个逻辑门组成的计算机。Casselman 最后成功了并且在 1992 年获得了专利 。&lt;/p&gt;
&lt;p&gt;Xilinx 公司的共同创世人 &lt;a href="http://en.wikipedia.org/wiki/Ross_Freeman"&gt;Ross Freeman&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Bernard_Vonderschmitt"&gt;Bernard Vonderschmitt&lt;/a&gt; 在 1985 年发明出第一款商业 FPGA —— XC2064 。XC2064 芯片有可以编程的逻辑门和可以编程的内部连接线，这开辟了一项新的技术和市场 。XC2064 有 64 个可配置逻辑块（configurable logic blocks，CLBs），和 3 输入查找表（lookup tables，LUTs）。&lt;/p&gt;
&lt;p&gt;从 1985 开始到 90 年代中期，Xilinx 一直处于高速发展阶段，之后竞争对手出现了，截至 1993 年，Actel 占据了 18% 的市场 。&lt;/p&gt;
&lt;p&gt;90 年代是 FPGA 爆炸式发展的年代，这一期间出现了大量高端技术和产品。在 90 年代初期，FPGA 主要应用于通信领域，在 90 年代后期，FPGA 已经广泛应用于消费品、汽车和工业应用 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;为什么选择 FPGA&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;FPGA vs ASIC&lt;/h3&gt;
&lt;p&gt;ASIC 的优点：&lt;/p&gt;
&lt;p&gt;ASIC 在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低 。&lt;/p&gt;
&lt;p&gt;ASIC 的缺点：&lt;/p&gt;
&lt;p&gt;设计周期最长，设计成本贵，设计费用最高，适合于批量很大或者对产品成本不计较的场合。&lt;/p&gt;
&lt;p&gt;至于 FPGA 的优点和缺点完全就是 ASIC 的取反 。FPGA 一般来说比专用集成电路（ASIC）的速度要慢，无法完成更复杂的设计，并且会消耗更多的电能。但是，FPGA 具有很多优点，比如可以快速成品，而且其内部逻辑可以被设计者反复修改，从而改正程序中的错误，此外，使用 FPGA 进行除错的成本较低 。在一些技术更新比较快的行业，FPGA几乎是电子系统中的必要部件，因为在大批量供货前，必须迅速抢占市场，这时FPGA方便灵活的优势就显得很重要。这也是 FPGA 能够发展起来的原因，市场是不会允许一个毫无优势的技术发展到今天这种地步的 。&lt;/p&gt;
&lt;p&gt;个人认为两者不是对立的，由于各自的特点，它们有各自适用的环境，不能一棒子打死，否定其中一个 。事实上更多的情况是：设计的开发是在普通的FPGA上完成的，然后将设计转移到一个类似于专用集成电路的芯片上 。&lt;/p&gt;
&lt;h3&gt;FPGA vs CPLD&lt;/h3&gt;
&lt;p&gt;为了达到上述目的，还有一种方法是使用 CPLD 。
CPLD和FPGA都包括了一些相对大数量的可以编辑逻辑单元。CPLD逻辑门的密度在几千到几万个逻辑单元之间，而FPGA通常是在几万到几百万。&lt;/p&gt;
&lt;p&gt;FPGA 与 CLPD 最大的区别就是：FPGA 是基于查找表（look up table，LUT），而 CPLD 是基于海门架构（sea-of-gates），也就是它们的系统结构 。CPLD 的结构具有一定的局限性 。这个结构由一个或者多个可编辑的结果之和的逻辑组列和一些相对少量的锁定的寄存器组成 。这样的结果是缺乏编辑灵活性，但是它的优点是，其延迟时间易于预计，逻辑单元对连接单元比率较高 。而FPGA具有的连接单元数量很大，这样虽然让它可以更加灵活的编辑，但是结构却复杂的多 。&lt;/p&gt;
&lt;p&gt;CPLD 和 FPGA 另外一个区别是大多数的 FPGA 含有高层次的内置模块（比如加法器和乘法器）和内置的存储器 。一个由此带来的重要区别是，很多新的 FPGA 支持完全的或者部分的系统内重新配置 。允许他们的设计随着系统升级或者动态重新配置而改变 。一些FPGA可以让设备的一部分重新编辑，而其他部分继续正常运行 。&lt;/p&gt;
&lt;p&gt;CPLD 与 FPGA 之间结构、原理上的差别导致两者应用上的差别 。考虑成本、性能要求等因素，应该根据实际情况选择 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Xilinx &amp;amp; Altera&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 的制造商主要是 Xilinx 和 Altera 两家，他们合起来市场占有率达到了 80% 之多 。两家是 FPGA 技术的领导者也是长期竞争对手 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Xilinx"&gt;Xilinx&lt;/a&gt; 于 1984 年创建于美国加利福尼亚州的硅谷，总部位于硅谷核心的圣何塞。它是一家主要提供 FPGA 的科技公司 。并且就是它的创始人是发明了 FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Altera"&gt;Altera&lt;/a&gt; 是一家位于美国硅谷的可编程逻辑器件和 CPLD 的制造商 。该公司于1984年推出了其首款可编程逻辑设备。&lt;/p&gt;
&lt;p&gt;两家一直是互为竞争对手，一般来说，大学里面都 Altera 的器件和 VHDL 上课，所以在学校里面用 Xilinx 的人比较少 。&lt;/p&gt;
&lt;p&gt;因为原理是一样的，所以只要学会一种，另一种就很容易上手。学校实验室里面用的是 Xilinx 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Xilinx FPGA Architecture（架构）&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 需要反复烧写，所以不能像 ASIC 一样通过固定的与非门来完成，只能采用一种易于反复配置的结构，查找表就可以很好的满足这一要求。目前主流 FPGA 都是采用了基于 SRAM 工艺的查找表结构（军品和宇航级 FPGA 采用 Flash或者熔丝/反熔丝工艺），通过烧写文件改变查找表内容的方法来实现对 FPGA 的重复配置。&lt;/p&gt;
&lt;p&gt;查找表（look-up table，LUT）本质上就是一个 RAM 。当用户通过原理图或 HDL 语言描述了一个电路以后，FPGA 开发软件会计算逻辑电路的所有可能结果，并把真值表事先写入 RAM，这样，每输入一个信号进行逻辑运算就相当于输入一个地址进行查找，这样 LUT 就具有了和逻辑电路相同的功能 。实际上，LUT 具有更快的执行速度和更大的规模 。&lt;/p&gt;
&lt;p&gt;上电时，FPGA将外部存储器中的数据读入片内RAM，完成配置后，进入工作状态；掉电后FPGA恢复为白片，内部逻辑消失。这样FPGA不仅能够反复使用，还无须专门的FPGA编程器，只需通用的EPROM、PROM编程器即可。&lt;/p&gt;
&lt;p&gt;目前，Xilinx FPGA 仍然是基于查找表技术，但是其概念已经远远超出查找表技术的限制，并且整合了常用功能的硬核模块（如块 RAM，时钟管理和 DSP）。Xilinx FPGA 内部大致可以分为 6 部分：&lt;/p&gt;
&lt;h3&gt;IOB&lt;/h3&gt;
&lt;p&gt;可编程输入/输出单元简称 I/O 单元，是芯片与外界电路的接口部分，完成不同电气特性下输入/输出信号的驱动和匹配 。&lt;/p&gt;
&lt;h3&gt;CLB&lt;/h3&gt;
&lt;p&gt;CLB（Configurable Logic Block）是 FPGA 内的基本逻辑单元，Xilinx FPGA 的 CLB 由多个相同的 Slice 和附加逻辑组成 。&lt;/p&gt;
&lt;h3&gt;DCM&lt;/h3&gt;
&lt;p&gt;业内大多数 FPGA 都提供数字时钟管理（Digital Clock Manager）。Xilinx FPGA 提供 DCM 和 PLL 。&lt;/p&gt;
&lt;h3&gt;BRAM&lt;/h3&gt;
&lt;p&gt;大多数 FPGA 都具有内嵌的块 RAM，这大大扩展了 FPGA 的应用范围和灵活度 。块 RAM 可以被配置为单口 RAM、双端口 RAM、内容地址存储器（CAM）和 FIFO 等常用存储结构 。&lt;/p&gt;
&lt;h3&gt;Routing Resource&lt;/h3&gt;
&lt;p&gt;布线资源连通 FPGA 内部的所有单元，而连线的长度和工艺决定着信号在连线上的驱动能力和传输速度 。Xilinx FPGA 的布线资源可以分为 4 类：全局布线资源、长线资源、短线资源、分布式资源 。&lt;/p&gt;
&lt;h3&gt;Embedded Module&lt;/h3&gt;
&lt;p&gt;内嵌功能模块只要是指 DLL、PLL、DSP 和 CPU 等 &lt;strong&gt;软核&lt;/strong&gt;，还有底层的 &lt;strong&gt;硬核&lt;/strong&gt; 资源，比如内嵌的 Power PC、ARM9、DSP芯片等 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Xilinx 主流 FPGA&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Xilinx 主流的 FPGA 主要有A系列、K系列、V系列、Spartan系列，如今还有最新的 Zynq 系列，官网上有详细介绍 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;开发流程&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 的开发流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="design flow" src="/images/learning-fpga-getting-started/design-flow.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;整个开发过程就是使用开发工具 ISE Design Suite，按照流程图进行 。图示是标准流程，但是实际上并不是严格按照每一个步骤进行 。&lt;/p&gt;
&lt;p&gt;一般简化过的流程是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设计可综合的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合 Systhesis&lt;/p&gt;
&lt;p&gt;前两步主要是确保写的代码是开发工具可以转化为实际电路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合后仿真&lt;/p&gt;
&lt;p&gt;这一步保证模块的逻辑功能是正确的，即检验模块的结果是否和预期一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序约束&lt;/p&gt;
&lt;p&gt;为设计添加时序约束和管脚约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现 Implement&lt;/p&gt;
&lt;p&gt;按照约束条件将综合结果映射到实际器件中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序分析&lt;/p&gt;
&lt;p&gt;实际上，一次就能达到时序要求且布线成功的情况并不多，尤其是对于高速设计，所以需要根据上一步的时序结果对设计进行修改，以满足时序要求，类似于写软件的 Debug 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载，在线调试&lt;/p&gt;
&lt;p&gt;将设计下载到芯片中调试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_logic_devices"&gt;PLD wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array"&gt;FPGA wikipedia&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category></entry><entry><title>Ubuntu 下安装 ISE &amp; ModelSim</title><link href="http://guqian110.github.io/pages/2014/03/27/install_ise_modelsim_on_ubuntu.html" rel="alternate"></link><updated>2014-03-27T20:52:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-03-27:pages/2014/03/27/install_ise_modelsim_on_ubuntu.html</id><summary type="html">&lt;p&gt;从 Windows 平台转移到 Linux，于是把 FPGA 的开发平台也搬过来。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;软件版本：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu 13.10 Desktop amd64 &lt;/p&gt;
&lt;p&gt;ISE 14.7 for Linux&lt;/p&gt;
&lt;p&gt;ModelSim 6.5b for Linux&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;下载&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE Design Suit for Linux&lt;/h3&gt;
&lt;p&gt;Xilinx 官方网站上有&lt;a href="https://secure.xilinx.com/webreg/register.do?group=dlc&amp;amp;htmlfile=&amp;amp;emailFile=&amp;amp;cancellink=&amp;amp;eFrom=&amp;amp;eSubject=&amp;amp;version=14.7&amp;amp;akdm=1&amp;amp;filename=Xilinx_ISE_DS_Lin_14.7_1015_1.tar"&gt;下载链接&lt;/a&gt;，但是在校园网内下载速度实在是蛋疼，还好有校内 bt 资源。&lt;/p&gt;
&lt;p&gt;我下载下来的 ISE 版本为 &lt;strong&gt;14.7&lt;/strong&gt;，tar 包大小为 6.5 G 。&lt;/p&gt;
&lt;h3&gt;ModelSim for Linux&lt;/h3&gt;
&lt;p&gt;网上的教程（2011 年前）都说是 &lt;a href="http://www.mentor.com/products/fpga/model"&gt;ModelSim 官方网站&lt;/a&gt; 上提供 ftp 下载链接，但是好像现在官网上不再提供下载链接了，我只找到 ModelSim PE Student Edition，而且还是 Windows 平台的...&lt;/p&gt;
&lt;p&gt;花费了一下午的时间，不停地在各个论坛注册下载附件，终于把 ModelSim_6.5b for Linux 下载下来了,结果安装时提示找不到 &lt;code&gt;libxp.so.6&lt;/code&gt; 库，于是 &lt;code&gt;apt-get&lt;/code&gt; 到一些 &lt;code&gt;libxp&lt;/code&gt; 的库，安装后仍然提示找不到，无奈放弃了，准备老老实实用 &lt;code&gt;ism&lt;/code&gt; 了（以后有时间了再慢慢折腾 T_T）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE DS 14.7&lt;/h3&gt;
&lt;p&gt;首先解压&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xvf&lt;/span&gt; &lt;span class="n"&gt;Xilinx_ISE_DS_Lin_14&lt;/span&gt;&lt;span class="mf"&gt;.7&lt;/span&gt;&lt;span class="n"&gt;_1015_1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着进入解压出来的目录并给安装文件赋予执行的权限&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;Xilinx_ISE_DS_Lin_14&lt;/span&gt;&lt;span class="mf"&gt;.7&lt;/span&gt;&lt;span class="n"&gt;_1015_1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;chmod&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;xsetup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后执行 xsetup&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;xsetup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后熟悉的图形界面就出来，和 Windows 下一样，同意安装许可协议，不停地下一步就可以安装成功。&lt;/p&gt;
&lt;p&gt;安装完成以后，运行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;14.7&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE_DS&lt;/span&gt;
    &lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="n"&gt;settings64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时，已经可以从终端运行 ISE 了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;nohup&lt;/span&gt; &lt;span class="n"&gt;ise&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;熟悉的图形界面出来了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ise" src="/images/install-ise-modelsim/ise_start.png" /&gt;&lt;/p&gt;
&lt;p&gt;P.S.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择安装版本时，选择 &lt;code&gt;System Edition&lt;/code&gt;，因为这个版本功能最全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择安装组件时，不要勾选 &lt;code&gt;Install Cable Drivers&lt;/code&gt;，我们自己编译安装另外一个驱动（因为此驱动只能在 Linux 内核 &amp;lt; 2.6的版本中使用，所以即使勾选了最后安装完成时会提示 &lt;em&gt;Driver installation failed&lt;/em&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Crack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又到了该和谐的地方了 =.=&lt;/p&gt;
&lt;p&gt;第一次打开 ISE 时，会自动弹出 License Management Tools 提示我们添加 License 。网上有一大堆破解包，我使用以前在 Windows 中生成的 Lincese，直接就可以使用了～&lt;/p&gt;
&lt;p&gt;再次声明：仅供技术交流，请支持正版软件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;installing Cable Drivers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如前面所说，因为 ISE 自带的驱动程序依赖于一个叫 windrvr 的文件。 而该文件目前只有 Linux 内核 2.4 的二进制版本，因此遇到高于 2.4 内核的 Linux发布版，如我使用的Ubuntu 13.10（Linux version 3.11.0-12-generic ） 就不工作了。&lt;/p&gt;
&lt;p&gt;好在一个叫 Michael Gernoth 的德国人，大公无私地写了一个 windrvr 的替代版本，并且开放源码，这样，无论碰到什么版本的内核，现场编译一个驱动并安装， 就能解决 Linux 内核版本匹配的问题。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://rmdir.de/~michael/xilinx/"&gt;XILINX JTAG tools on Linux without proprietary kernel modules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以按照说明&lt;/p&gt;
&lt;p&gt;首先安装 usb 驱动开发包，在 64 位系统下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;libusb&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="n"&gt;libc6&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt; &lt;span class="n"&gt;fxload&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着下载驱动程序的源代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;
    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//git.zerfleddert.de/usb-driver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后编译驱动程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;usb&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;make&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载下来的源代码中有个脚本可以设置好一切，我们只需要运行脚本就 ok&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;setup_pcusb&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;14.7&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE_DS&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把 Xilinx 路径添加到系统 PATH 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;PATH=\$PATH:/opt/Xilinx/13.2/ISE_DS/ISE/bin/lin64/&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bashrc&lt;/span&gt;
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;export PATH&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bashrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这时候，写个小测试的程序，&lt;code&gt;Systhesize&lt;/code&gt; -&amp;gt; &lt;code&gt;Implement&lt;/code&gt; -&amp;gt; &lt;code&gt;Generate Programming File&lt;/code&gt;，打开 &lt;code&gt;iMPACT&lt;/code&gt;, 如图所示，可以看到已经识别出 JTAG 链上的芯片&lt;/p&gt;
&lt;p&gt;&lt;img alt="jtag" src="/images/install-ise-modelsim/jtag.png" /&gt;&lt;/p&gt;
&lt;h3&gt;ModelSim&lt;/h3&gt;
&lt;p&gt;待续...&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;配置 ISE &amp;amp; ModelSim&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE&lt;/h3&gt;
&lt;p&gt;其实也没有特殊配置的地方，主要是自定义代码编辑器，目前我的主要使用的是 &lt;code&gt;sublime text 2&lt;/code&gt;，正在向 &lt;code&gt;vim&lt;/code&gt; 过度ing&lt;/p&gt;
&lt;p&gt;具体步骤 Edit -&amp;gt; Preferences -&amp;gt; Editors，选择 &lt;code&gt;custom&lt;/code&gt;，在右侧的 “Command line syntax” 中写自定义编辑器的执行路径&lt;/p&gt;
&lt;p&gt;配置自定义编辑器为 vim&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;gnome&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;terminal&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;maximize&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;ModelSim&lt;/h3&gt;
&lt;p&gt;ModelSim 编译 Xilinx库，ISE 关联 ModelSim&lt;/p&gt;
&lt;p&gt;待续...&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://rmdir.de/~michael/xilinx/"&gt;XILINX JTAG tools on Linux without proprietary kernel modules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.george-smart.co.uk/wiki/Xilinx_JTAG_Linux"&gt;Xilinx JTAG Linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/yunz1994/article/details/12350071"&gt;【Linux软件安装】Ubuntu12.04: Xilinx ISE 14.6&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="Linux"></category></entry></feed>