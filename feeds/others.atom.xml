<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Coding Life</title><link href="http://guqian110.github.io/" rel="alternate"></link><link href="http://guqian110.github.io/feeds/others.atom.xml" rel="self"></link><id>http://guqian110.github.io/</id><updated>2014-03-21T16:33:00+08:00</updated><entry><title>Code 书评</title><link href="http://guqian110.github.io/pages/2014/03/21/code_review.html" rel="alternate"></link><updated>2014-03-21T16:33:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-03-21:pages/2014/03/21/code_review.html</id><summary type="html">&lt;p&gt;最近花了一个星期的时间，终于把 &lt;a href="http://book.douban.com/subject/1494026/"&gt;&lt;em&gt;Code&lt;/em&gt;&lt;/a&gt; 看完了，看完全书，观后感总结出来就一个字——爽～&lt;/p&gt;
&lt;p&gt;书名： &lt;a href="http://book.douban.com/subject/1494026/"&gt;&lt;em&gt;Code:  The Hidden Language of Computer Hardware and Software&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者： &lt;a href="http://charlespetzold.com/"&gt;Charles Petzold&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这本书的作者 &lt;a href="http://en.wikipedia.org/wiki/Charles_Petzold"&gt;Charles Petzold&lt;/a&gt; 是 Windows 编程界一位大师，世界顶级技术作家。1994 年 5 月，Petzold 作为仅有的七个人之一（并且是唯一的作家）被《Window Magazine》和 Microsoft 公司授予 “Windows Pioneer” 奖，以表彰他对 Microsoft Windows 的成功做出的贡献 。&lt;/p&gt;
&lt;p&gt;关于这本书的 “江湖地位” ，只需要来看看 stackoverflow 上的这个帖子就明白了：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read"&gt;What is the single most influential book every programmer should read?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本书排名在 &lt;em&gt;第15&lt;/em&gt;，当然绝对排名没有很大的意义，但是也能说明本书的影响力 。另外本书号称 “完全不懂计算机的人也能看懂”... 如果这都不读，我不知道还有什么样的书值得我们去花费时间 : D&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;打通任督二脉&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;纵观程序员的 “武功秘籍”，不外乎两种：一种是讲 &lt;code&gt;道&lt;/code&gt;，另外一种是讲 &lt;code&gt;术&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;道&lt;/code&gt; 即 “道理”（真理），是脱离了具体事物，抽象出来的事物的本质 。比如平时学习的 &lt;em&gt;数学&lt;/em&gt;、&lt;em&gt;物理&lt;/em&gt;、&lt;em&gt;化学&lt;/em&gt; 知识，再比程序中的 &lt;em&gt;算法&lt;/em&gt;、分析解决问题的 &lt;em&gt;思维方式&lt;/em&gt; 等，都不会因时间和环境变化而不适用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;术&lt;/code&gt; 即 “技术”（技巧），是人们在具体工程实践中总结出来的一些技巧。比如 “The art of XXX” ，“The principle of XXX” 等 。&lt;/p&gt;
&lt;p&gt;是的，这本书既不是单独讲 &lt;code&gt;道&lt;/code&gt;，也不是单独讲 &lt;code&gt;术&lt;/code&gt;，而是将两者结合起来，让你不仅明白 &lt;em&gt;道&lt;/em&gt;  的深奥，也明白 &lt;em&gt;术&lt;/em&gt; 的精妙；让你体会到 &lt;em&gt;道&lt;/em&gt; 是如何在 &lt;em&gt;术&lt;/em&gt; 中实现，也体会到 &lt;em&gt;术&lt;/em&gt; 是如何在 &lt;em&gt;道&lt;/em&gt;   的约束下追求极限的 。更加关键的是全书都是用很平白的语言讲述，平白到 “即使完全不懂计算机的人也能读懂”的地步，这就是其厉害之处了。&lt;/p&gt;
&lt;p&gt;就好像你学习了五花八门的心法秘籍和各式武功，每一门都厉害无比，可偏偏无法把这些武功融会贯通，修至大成 。这时候，你需要的不是一本《葵花宝典》，而是《论天下武功之间的关系及其融会贯通方法》，打通自己的任督二脉，也就是这本 &lt;a href="http://book.douban.com/subject/1494026/"&gt;Code&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;读这本书时，让我想起了在大学 4 年间读的各种课程：&lt;/p&gt;
&lt;p&gt;读到 第 6 章 “电报机与继电器” 让我想起 &lt;em&gt;大学物理&lt;/em&gt; ，虽然翘了很多课，但是电磁感应什么的有中学基础，还好没有忘记 。&lt;/p&gt;
&lt;p&gt;读到 第 7～9 章，书中对计数的方法和进制的讨论，让我想起 &lt;em&gt;大学计算机基础&lt;/em&gt; ，然后花了一天时间去把以前一知半解的 “原码、反码、补码” 仔细推敲总结一遍，收获颇大 。&lt;/p&gt;
&lt;p&gt;读到 第 10 章，布尔代数 让我想起 &lt;em&gt;离散数学&lt;/em&gt; ，尤其发人深醒的是布尔发明了 布尔逻辑 100 多年后， 才有人（香农）将其和电路联系起来 。&lt;/p&gt;
&lt;p&gt;读到 第 11～13 章，跟随作者的思路，我才明白当年令人痛不欲生的 &lt;em&gt;模拟电路&lt;/em&gt; 、&lt;em&gt;数字电路&lt;/em&gt;  到底是来干什么的，数字电路是如何从最基本的门搭建出来更强的功能的元器件的，联系前面学习的 编码的知识，明白这样做的道理 。&lt;/p&gt;
&lt;p&gt;读到 第 16～22 章，让我想起 &lt;em&gt;微机原理&lt;/em&gt; ，对微处理器的工作方式不再模糊不清，跟随着作者的思路搭建一台 “计算机”（当然和现在的计算机完全不同，但是原理是一模一样的），为自己搭建的处理器设计一套可以实现自动功能的编程语言，然后写一段程序，甚至一窥操作系统 。&lt;/p&gt;
&lt;p&gt;还有等等...&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br&gt;
胡扯了这么多，书固然是好书，但是更让人深思的是 国内外教育的差异 。吐槽我们的教育体制毫无意义，吐槽的人都当不上教育部长，没有能力去改变现状，有能力的 guan猿却根本没有动力去改变。作为普通人，我们能做到的就是自己努力，找真正的好书、向真正的大师学习，比如上面提到过的&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read"&gt;What is the single most influential book every programmer should read?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了技术、还有很多程序员需要看的书。找到一本好书，然后 Let's start it !&lt;/p&gt;</summary><category term="Book"></category><category term="Code"></category></entry><entry><title>原码、反码、补码</title><link href="http://guqian110.github.io/pages/2014/03/19/signed_number_representations.html" rel="alternate"></link><updated>2014-03-19T14:31:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-03-19:pages/2014/03/19/signed_number_representations.html</id><summary type="html">&lt;p&gt;最近找到一本好书——&lt;a href="http://book.douban.com/subject/4822685/"&gt;《编码: 隐匿在计算机软硬件背后的语言》&lt;/a&gt;。作者是大名鼎鼎的 &lt;a href="http://en.wikipedia.org/wiki/Charles_Petzold"&gt;Charles Petzold&lt;/a&gt; (&lt;a href="http://charlespetzold.com/"&gt;个人网站&lt;/a&gt;)。书的介绍也很有意思，据说完全不懂计算机的人也能看懂...于是买了本来拜读一下（这种文章当然是英文版最好了，只是学生党没银子，只好买翻译版了）&lt;/p&gt;
&lt;p&gt;看到用继电器搭建加法器、减法器，讨论二进制编码方式那章，想起一直不是很清楚的原码、反码、补码等，果断 &lt;a href="https://www.google.com.hk/"&gt;Google&lt;/a&gt;、&lt;a href="http://en.wikipedia.org/wiki/Main_Page"&gt;Wiki&lt;/a&gt;，于是总结出下文。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;机器数&lt;/h3&gt;
&lt;p&gt;顾名思义，一个数字在机器中的存储方式，“&lt;em&gt;数&lt;/em&gt; ” 是指 有符号数（&lt;code&gt;signed number&lt;/code&gt;），即包含了正负号的数，“&lt;em&gt;机器&lt;/em&gt; ” 当然是指计算机（&lt;code&gt;Computer&lt;/code&gt;）了。&lt;/p&gt;
&lt;p&gt;从小学毕业，刚进入初中，我们就知道数字是有符号的：&lt;em&gt;正数&lt;/em&gt; &amp;amp; &lt;em&gt;负数&lt;/em&gt;。但是在计算机的哲学体系中，整个世界只有两个元素：0 &amp;amp; 1 ，没有额外的专门表示正负号的符号。怎么办呢？解决方法就是添加一位来表示符号。于是，人们约定把符号位放在一个数字的 &lt;em&gt;最高有效位&lt;/em&gt;（Most significant bit, &lt;code&gt;MSB&lt;/code&gt;），在&lt;a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F"&gt;大端序&lt;/a&gt;中，&lt;code&gt;MSB&lt;/code&gt; 指的是一个二进制数的最左边的一位。一般，&lt;code&gt;MSB&lt;/code&gt; 等于 0  表示正数，1 表示负数。&lt;/p&gt;
&lt;h3&gt;真值&lt;/h3&gt;
&lt;p&gt;因为机器数中有一位表示符号，所以机器数的形式值不等于真正的数值，机器数对应的数值称为机器数的 &lt;em&gt;真值&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
举个栗子：&lt;/p&gt;
&lt;p&gt;用 8 bit 表示一个数字，因为有符号位的存在，可以表示的范围为 (-127, -0, +0, +127) 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# +5 的 机器数 = 0000_0101 ；真值 = + 000_0101&lt;/span&gt;

&lt;span class="c"&gt;# -5 的 机器数 = 1000_0101 ；真值 = - 000_0101&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种机器数的编码方式称为 &lt;a href="http://en.wikipedia.org/wiki/Signed_magnitude#Signed_magnitude_representation"&gt;&lt;em&gt;原码&lt;/em&gt;&lt;/a&gt; (&lt;code&gt;signed-magnitude&lt;/code&gt;) ，是机器数编码方式中的一种。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The four best-known methods of extending the binary numeral system to represent signed numbers are: sign-and-magnitude, ones' complement, two's complement, and excess-K.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;There is no definitive criterion by which any of the representations is universally superior. The representation used in most current computing devices is two's complement, although the Unisys ClearPath Dorado series mainframes use ones' complement.&lt;/em&gt;
（&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations"&gt;Wikipeida&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;下面分别讨论：&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;机器数表示法&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;原码（sign and magnitude）&lt;/h3&gt;
&lt;h4&gt;编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 正数：  0_xxxxxxx&lt;/span&gt;

&lt;span class="c"&gt;# 负数：  1_xxxxxxx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8 bit 的原码可以表示的范围是 [ -127, -0, +0, +127 ]，共 255 个数&lt;/p&gt;
&lt;h4&gt;计算法则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 两数符号相同：  低位相加，最高位的符号位不变（当低位相加产生进位时，溢出 Overflow）&lt;/span&gt;

&lt;span class="c"&gt;# 两数符号不同：  比较绝对值的大小，差的绝对值 = 大数 - 小数 ，符号位和大数的符号位相同&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;电路复杂&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从前面的计算方法中可以看到，原码中的符号位不能直接参与运算，必须要单独的线路来确定符号位&lt;/li&gt;
&lt;li&gt;原码的计算不能避免减法运算，加法运算是产生 &lt;em&gt;进位&lt;/em&gt;，减法运算需要 &lt;em&gt;借位&lt;/em&gt;，这是两种不同的运算过程，需要额外的电路把 &lt;code&gt;加法器&lt;/code&gt; 改造为 &lt;code&gt;减法器&lt;/code&gt;（&lt;a href="http://www.charlespetzold.com/code/"&gt;《编码》&lt;/a&gt;这本书里面有详细介绍 如何使用继电器搭建 加法器 和 减法器）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0的表示不唯一&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0可以编码为两种方式： &lt;code&gt;0000_0000&lt;/code&gt; 和 &lt;code&gt;1000_0000&lt;/code&gt;，进一步增加了逻辑的复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;This approach is directly comparable to the common way of showing a sign (placing a "+" or "−" next to the number's magnitude). Some early binary computers (e.g., &lt;a href="http://en.wikipedia.org/wiki/IBM_7090"&gt;IBM 7090&lt;/a&gt;) used this representation, perhaps because of its natural relation to common usage. Signed magnitude is the most common way of representing the significand in floating point values.
（&lt;a href="http://en.wikipedia.org/wiki/Signed_magnitude#Signed_magnitude_representation"&gt;Wiki&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;虽然 &lt;code&gt;原码&lt;/code&gt; 的编码方式最接近人类的习惯，但是，并不适合在计算机中使用，为了解决原码计算中的一些问题，于是 &lt;code&gt;反码&lt;/code&gt; 就出现了&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;反码（one's complement）&lt;/h3&gt;
&lt;p&gt;首先，来看看 &lt;a href="http://www.charlespetzold.com/code/"&gt;Code&lt;/a&gt; 中介绍了基于10进制的补码：&lt;/p&gt;
&lt;p&gt;实现一个减法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 - 176 =？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照我们从数学课上学习到知识，这个计算需要进行 &lt;em&gt;借位&lt;/em&gt; 操作，为了避免这个在计算机中很难实现的操作，可以稍微变化一下计算过程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (999-176) + 1 - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个过程中，用两个减法代替了原来的一个减法，避免了烦琐的 &lt;em&gt;借位&lt;/em&gt; 操作。在这个运算中，负数 &lt;code&gt;-176&lt;/code&gt; 转化为另外一个数 &lt;code&gt;999 - 176&lt;/code&gt; ，这个数称为它的 &lt;code&gt;9 的补数(nine's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个运算的关键在于：&lt;em&gt;把负数用 9 的补数表示，减法转化为加法&lt;/em&gt; 。同理，我们推广到 2 进制，就得到了 &lt;code&gt;1 的补数(one's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;把减数从一串 1 当中减去，结果就称为这个数的 “1 的补数”，在求 1 的补数的时候，其实并不需要做减法，因为求 1 的补数，只需要将原来的 1 变为 0 ，0 变为 1 即可，也就是取反，在电路中只需要一个反向器就可以实现，所以 &lt;code&gt;1 的补数&lt;/code&gt; 也称为 &lt;code&gt;反码&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;从上面的描述就可以很容易写出反码的编码规则&lt;/p&gt;
&lt;h4&gt;编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 正数    反码 = 原码&lt;/span&gt;

&lt;span class="c"&gt;# 负数    反码 = 符号位不变，其他位取反&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8 bit 的反码可以表示的范围是 [ -127, -0, +0, +127 ]，共 255 个数&lt;/p&gt;
&lt;h4&gt;计算法则&lt;/h4&gt;
&lt;p&gt;反码的计算不用区分符号和绝对值，直接进行计算，计算结果若有溢出，需要将溢出加到最低位，这种操作称为 “循环进位”（end-around carry）&lt;/p&gt;
&lt;h4&gt;优缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;优点，电路简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为不需要把符号和绝对值分开考虑，正数和负数的加法都一样算，所以反码计算不需要单独的判断符号的电路，也不需要判断两个数绝对值相对大小的电路&lt;/li&gt;
&lt;li&gt;节省了减法器，只需要一组额外的反向器就能把加法器改进为可以计算 加 / 减法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算机中仍然需要进行 “循环进位” 的硬件电路，但是这种复杂度的电路是可以接受的&lt;/li&gt;
&lt;li&gt;0的表示不唯一，0的编码仍然有两种方式： &lt;code&gt;0000_0000&lt;/code&gt; 和 &lt;code&gt;1111_1111&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;The &lt;a href="http://en.wikipedia.org/wiki/PDP-1"&gt;PDP-1&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/CDC_160_series"&gt;CDC 160 series&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/CDC_6000_series"&gt;CDC 6000 series&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/UNIVAC_1100"&gt;UNIVAC 1100 series&lt;/a&gt;, and the &lt;a href="http://en.wikipedia.org/wiki/LINC"&gt;LINC&lt;/a&gt; computer used ones' complement representation.（&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations#Ones.27_complement"&gt;Wiki&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;反码&lt;/code&gt; 中仍然没有避免 0 有两种编码方式的问题，虽然对于人来说，+0 和 -0 没有区别，但是对于计算机来说，判断一个数是否为0，要进行两次判断。为了解决 0 的表示问题和硬件上的 “循环进位”，于是人们又发明了 &lt;code&gt;补码&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;补码（two's complement）&lt;/h3&gt;
&lt;p&gt;前面介绍的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 - 176 =？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照反码的方法可以转换为&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (999-176) + 1 - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果我们稍微再变形一下，就有&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (1000 - 176) - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个运算中 &lt;code&gt;-176&lt;/code&gt; 转化为 &lt;code&gt;1000 - 176&lt;/code&gt;，这个数称为它的 &lt;code&gt;10 的补数(ten's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个运算的关键在于：&lt;em&gt;把负数用 10 的补数表示，减法转化为加法&lt;/em&gt; 。同理，我们推广到 2 进制，就得到了 &lt;code&gt;2 的补数(two's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;因为对一位二进制数 b 取补码就是 &lt;code&gt;1 - b + 1 = 10 - b&lt;/code&gt;，相当于从 2 里面减去 b ,所以，这种方法称为 &lt;code&gt;2 的补数&lt;/code&gt;，这种编码方式简称 &lt;code&gt;补码&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;举例说明，要表示 -4 ，需要对 &lt;code&gt;0000_0100&lt;/code&gt;取补码，&lt;code&gt;1111_1111 - 0000_0100 + 1 = 1_0000_0000 - 0000_0100&lt;/code&gt;，相当于从2^8里面减去 4 。&lt;/p&gt;
&lt;p&gt;从上面的计算过程可以很容易写出补码的编码规则&lt;/p&gt;
&lt;h4&gt;编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 正数    补码 = 原码&lt;/span&gt;

&lt;span class="c"&gt;# 负数    补码 = 反码 + 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8 bit补码可以表示的范围是 [ -128, 0 , +127 ]，共 256 个数 。&lt;/p&gt;
&lt;p&gt;目前大多数计算机内部使用的都是补码，所以对于编程中的 32 位 &lt;code&gt;int&lt;/code&gt; 型变量，它可以表示的范围就是 [ -2^32, +2^32 - 1] 。&lt;/p&gt;
&lt;p&gt;P.S. -128 没有对应的 原码 和反码，它的补码为 &lt;code&gt;1000_0000&lt;/code&gt; 。&lt;/p&gt;
&lt;h4&gt;计算法则&lt;/h4&gt;
&lt;p&gt;采用补码的系统，减法转换成加法（减法等同于加上一个负数，所以不再有减法），忽略计算结果最高位的进位，不必加回到最低位上去。&lt;/p&gt;
&lt;h4&gt;优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;电路简单，从计算法则中可以看到，不用考虑 “循环进位” 的问题，所以，补码系统的电路是最简单的，这也是补码系统应用最广泛的原因&lt;/li&gt;
&lt;li&gt;0 的表示是唯一的，&lt;code&gt;0000_0000&lt;/code&gt;，不再有 -0 的困扰&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;补码中的数学原理&lt;/h4&gt;
&lt;p&gt;补码能将减法转化为加法，其数学原理就是 &lt;em&gt;模&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 如果有个手表的时间为6点，实际时间为4点，那么如何校准呢？&lt;/span&gt;

&lt;span class="c"&gt;# 答案有两种方法：&lt;/span&gt;

&lt;span class="c"&gt;#   1. 逆时针转动  2，也就是做 减法 6 - 2 = 4&lt;/span&gt;
&lt;span class="c"&gt;#   2. 顺时针转动 10, 也就是做 加法 (6 + 10) mod 12 = 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从这个例子中就可以很明白的看到 &lt;em&gt;减法&lt;/em&gt; 是如何转化为 &lt;em&gt;加法&lt;/em&gt; 的，也就是如何将一个 &lt;em&gt;负数&lt;/em&gt; 转化为 &lt;em&gt;正数&lt;/em&gt;的 。&lt;/p&gt;
&lt;p&gt;即有公式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A - B = A + (-B + M)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个式子中的 &lt;code&gt;-B + M&lt;/code&gt; 即为 &lt;code&gt;B&lt;/code&gt; 的 &lt;em&gt;补数&lt;/em&gt; （类似于几何中的&lt;em&gt;补角&lt;/em&gt;） 。&lt;/p&gt;
&lt;h4&gt;溢出问题（摘自 &lt;a href="http://baike.baidu.com/view/60437.htm"&gt;百度百科&lt;/a&gt;）&lt;/h4&gt;
&lt;p&gt;无论采用何种机器数，只要运算的结果大于数值设备所能表示数的范围，就会产生溢出。 溢出现象应当作一种故障来处理，因为它使结果数发生错误。异号两数相加时，实际是两数的绝对值相减，不可能产生溢出，但有可能出现正常进位；同号两数相加时，实际上是两数的绝对值相加，既可能产生溢出，也可能出现正常进位。&lt;/p&gt;
&lt;p&gt;由于补码运算存在符号位进位自然丢失而运算结果正确的问题，因此，应区分补码的溢出与正常进位。&lt;/p&gt;
&lt;p&gt;详细论证过程不再复制粘贴了...直接给出结论&lt;/p&gt;
&lt;p&gt;结论：在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;由 &lt;em&gt;“减去一个数 = 加上一个负数”&lt;/em&gt;，计算机系统内部就不再有减法操作&lt;/p&gt;
&lt;p&gt;由 &lt;em&gt;“负数的表示由取模运算转变为补码表示”&lt;/em&gt;，计算机系统就可以用一个正数来表示负数&lt;/p&gt;
&lt;p&gt;所以，计算机内部只需要加法器就可以完成 加减法 和 正负数 的表示 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Two's complement is the easiest to implement in hardware, which may be the ultimate reason for its widespread popularity. Processors on the early mainframes often consisted of thousands of transistors – eliminating a significant number of transistors was a significant cost savings. Mainframes such as the IBM System/360, the GE-600 series, and the PDP-6 and PDP-10 used two's complement, as did minicomputers such as the PDP-5 and PDP-8 and the PDP-11 and VAX. The architects of the early integrated circuit-based CPUs (Intel 8080, etc.) chose to use two's complement math. As IC technology advanced, virtually all adopted two's complement technology. x86, m68k, Power Architecture, MIPS, SPARC, ARM, Itanium, PA-RISC, and DEC Alpha processors are all two's complement.&lt;/em&gt;(&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations#Two.27s_complement"&gt;Wiki&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;有符号数和无符号数（摘自 &lt;a href="http://learn.akae.cn/media/ch14s03.html"&gt;整数的加减运算&lt;/a&gt;）&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;如果把所有的位数都用来表示数值的大小，那么8 bit 二进制数可以表示的范围是 [0, 255] ，这种称为无符号数 。其实计算机做加法时并不区分操作数是有符号数还是无符号数，计算过程都一样 。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c"&gt;#   1000_0010              130                  -126&lt;/span&gt;
    &lt;span class="c"&gt;# + 1111_1000     =&amp;gt;   +   256          =&amp;gt;  +   -  8&lt;/span&gt;
    &lt;span class="c"&gt;# --------------      ---------------      -----------&lt;/span&gt;
    &lt;span class="c"&gt;# 1_0111_1010              122 + 256             122&lt;/span&gt;

    &lt;span class="c"&gt;#                        无符号数（ok）        有符号数（error）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;计算机的加法器在做完计算之后，根据最高位产生的进位设置 &lt;em&gt;进位标志&lt;/em&gt; ，同时根据最高位和次高位产生的进位的异或设置 &lt;em&gt;溢出标志&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;如果看作无符号数130和248相加，计算结果是122进1，也就是122+256，这个结果是对的; 如果把这两个操作数看作有符号数-126和-8相加，计算结果是错的，因为产生了溢出 。&lt;/p&gt;
&lt;p&gt;至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，下一步就要检查溢出标志，如果程序把它理解成无符号数加法，下一步就要检查进位标志。&lt;/p&gt;
&lt;p&gt;通常计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有bit都是零则设置零标志，如果计算结果的最高位是1则设置负数标志，如果程序把计算结果理解成有符号数，也可以检查负数标志判断结果是正是负。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;从 &lt;code&gt;原码&lt;/code&gt; 到 &lt;code&gt;反码&lt;/code&gt;，再到 &lt;code&gt;补码&lt;/code&gt;，可以清楚看到为了解决问题而改进的技术路线，虽然这些是非常基础知识，可能对我们对写程序没有很大的帮助，但是搞清楚这些不仅让你对计算机底层更加了解，更加关键的是 &lt;em&gt;这个学习过程&lt;/em&gt; 和 &lt;em&gt;解决编码问题的思路&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations"&gt;Signed number representations——Wiki&lt;/a&gt;
&lt;a href="http://en.wikipedia.org/wiki/Ones'_complement"&gt;Ones' complement&lt;/a&gt;
&lt;a href="http://en.wikipedia.org/wiki/Two's_complement"&gt;Two's complement&lt;/a&gt;
&lt;a href="http://learn.akae.cn/media/ch14s03.html"&gt;整数的加减运算&lt;/a&gt;
&lt;a href="http://baike.baidu.com/view/60437.htm"&gt;机器数——百度百科&lt;/a&gt;&lt;/p&gt;</summary><category term="Code"></category></entry><entry><title>First Blood</title><link href="http://guqian110.github.io/pages/2014/03/17/first_blood.html" rel="alternate"></link><updated>2014-03-17T14:29:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-03-17:pages/2014/03/17/first_blood.html</id><summary type="html">&lt;h2&gt;为什么要搭建自己的博客&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;首先，来看看各类门户博客的优缺点。&lt;/p&gt;
&lt;p&gt;国内大多数人的朋友圈都聚集在 QQ、微博、人人等社交平台上。但是这些社区并不适合写博客，面对满屏幕毫无营养的转载文章和五颜六色的广告，谁还有兴趣把自己的生活感悟写下来？其实，我们需要的仅仅是一方可以写字的净土。至于各大技术博客平台，它们明显不适合用来记录生活中的点滴琐事。CSDN 的博客系统一直是人们的吐槽对象，况且，CSDN 已经沦为学生求作业的地方，很多大神都转移阵地，去搭建自己的博客了。&lt;/p&gt;
&lt;p&gt;既然这些平台都不能满足我们的需求，为什么我们不搭建一个属于自己的博客呢？&lt;/p&gt;
&lt;p&gt;我们写博客是为了记录自己的学习、生活和成长，寻找志同道合的知己。个人博客也是一种身份，代表了博主的兴趣爱好和品味。我们自己是博客的主人，可以自己定制主题和内容，而无需经受别人的审核和莫名删除的烦恼。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;为什么选择 Markdown + Pelican + GitHub&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;不同于面向 &lt;em&gt;发布&lt;/em&gt; 的 &lt;code&gt;Html&lt;/code&gt; 语言，&lt;code&gt;Markdown&lt;/code&gt; 是一种面向&lt;em&gt;书写&lt;/em&gt;的语言，其目的就是让文档更容易写和读，让人们不再为 &lt;code&gt;Html&lt;/code&gt; 繁琐的标签烦恼。&lt;/p&gt;
&lt;p&gt;搭建个人博客最方便也最简易的方式就是采用 &lt;code&gt;WordPress&lt;/code&gt; 平台。但是，简易也意味着无脑、不能随行所欲地定制。我们只是需要一个写字的地方，显然 &lt;code&gt;WordPress&lt;/code&gt; 太臃肿，用来生成静态博客的 &lt;code&gt;Pelican&lt;/code&gt; 才是我们的最佳选择。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Github&lt;/code&gt; 是一个共享虚拟主机服务，用于存放使用 &lt;code&gt;Git&lt;/code&gt; 版本控制的软件代码和内容项目。——by &lt;a href="http://zh.wikipedia.org/wiki/GitHub"&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以我们只要采用 &lt;code&gt;Markdown&lt;/code&gt; 写下我们的博客内容，用 &lt;code&gt;Pelican&lt;/code&gt; 生成静态网页，然后将其托管到&lt;code&gt;GitHub&lt;/code&gt; 上，就大功告成了！&lt;/p&gt;
&lt;p&gt;折腾了几天，终于在 &lt;a href="https://www.google.com.hk"&gt;Google&lt;/a&gt; 和以下几篇博客的帮助下，初步搭建好了个人的小窝。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.lizherui.com/pages/2013/08/17/build_blog.html"&gt;一步一步打造Geek风格的技术博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.xycoding.com/articles/2013/11/21/blog-create/"&gt;使用Pelican和GitHub Pages搭建个人博客 —— 基础篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.dongxf.com/3_Build_Personal_Blog_With_Pelican_And_GitHub_Pages.html"&gt;用 Pelican 和 GitHub Pages 搭建免费的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://frantic1048.com/bo-ke-dan-sheng-ji-ji-yu-githubpelicanchuang-jian-bo-ke-de-zheng-ge-guo-cheng.html"&gt;博客诞生记:基于GitHub+Pelican创建博客的整个过程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;如何搭建&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;本博客就是在参考以上 4篇博客的教程 + &lt;a href="https://www.google.com.hk"&gt;Google&lt;/a&gt; ，在 &lt;code&gt;Ubuntu 13.10&lt;/code&gt; 下完成的，十分感谢各位博主的分享。在搭建过程中遇到了不少问题，但是在万能的 Google 面前，都一切都不是问题，同时我也学习到了不少知识。&lt;/p&gt;
&lt;p&gt;详细的搭建过程参考以上4篇博客，不再赘述，下面总结一下自己安装过程中遇到的问题吧。&lt;/p&gt;
&lt;h3&gt;学习流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;学习 &lt;code&gt;Git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://gitref.org/"&gt;Git Refence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://git-scm.com/book"&gt;Pro Git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://help.github.com/"&gt;GitHub help&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装、学习使用 &lt;code&gt;Pelican&lt;/code&gt; 搭建博客骨架&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/getpelican/pelican"&gt;Pelican Source Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.getpelican.com/en/latest/"&gt;Pelican Doc&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习 &lt;code&gt;Markdown&lt;/code&gt; 语法，写博客内容&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wowubuntu.com/markdown/#hr"&gt;Markdown语法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sourceforge.net/projects/retext/"&gt;Markdown 编辑器 Retext&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pelican theme&lt;/code&gt; 修改&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.getpelican.com/en/latest/settings.html#themes"&gt;Pelican theme setting&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;问题总结&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一种安装方式不成功时，可以试试其他方法。使用命令行安装 &lt;code&gt;Pelican&lt;/code&gt; 时，由于学校的渣网速，我安装了好几遍都 &lt;em&gt;time_out&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须先安装 &lt;code&gt;Pelican&lt;/code&gt;，后安装 &lt;code&gt;Markdown&lt;/code&gt;，否则在生成网页时会报错，不能识别 &lt;code&gt;.md&lt;/code&gt; 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于薄弱的 &lt;code&gt;Html&lt;/code&gt; 知识， &lt;code&gt;Pelican theme&lt;/code&gt; 的修改花费了很多时间 (Orz...)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;总之，既然搭建好了博客，就要坚持认真写下去，记录下生活中的每一点一滴。&lt;/p&gt;</summary><category term="Build Blog"></category></entry></feed>