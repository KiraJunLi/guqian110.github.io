<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Coding Life</title><link href="http://guqian110.github.io/" rel="alternate"></link><link href="http://guqian110.github.io/feeds/fpga.atom.xml" rel="self"></link><id>http://guqian110.github.io/</id><updated>2014-04-08T18:33:00+08:00</updated><entry><title>脉冲边沿检测</title><link href="http://guqian110.github.io/pulse_edge_detection.html" rel="alternate"></link><updated>2014-04-08T18:33:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-08:pulse_edge_detection.html</id><summary type="html">&lt;p&gt;脉冲边沿检测是 FPGA 设计中经常用到的方法，本文总结一下其原理和实现代码，可以将其加入我们自己的代码库中，以备以后使用 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测原理&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="pulse" src="/images/learning-fpga-pulse-edge-detection/pulse.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;如图，任何一个脉冲既有上升沿也有下降沿，系统的时钟周期一定要比脉冲宽度小，而且越小越好，即频率越高越好 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脉冲边沿的特点就是：边沿两侧的电平发生了变化 。&lt;/strong&gt; 利用这一点，我们就可以设计出检测边沿的方法 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作方法：&lt;/strong&gt; 建立 2 个寄存器，形成二级寄存器，在时钟触发中，首先把数据送入第一个寄存器中，然后在下一个时钟上沿到来时，将第一个寄存器中的数据存入第二个寄存器，也就是说第二个寄存器中的数据始终比第一个寄存器晚一个周期，即晚一个数据 。根据系统时钟检测，如果前后进来的信号发生了变化，可以用异或运算，异或结果为1，说明电平发生了变化，有边沿产生。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测方法&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;检测是否有边沿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
        &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_edge&lt;/span&gt;  
        &lt;span class="p"&gt;);&lt;/span&gt; 

        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trigedge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
        &lt;span class="n"&gt;end&lt;/span&gt;  

        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trigEdge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

    &lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl1" src="/images/learning-fpga-pulse-edge-detection/rtl1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim1" src="/images/learning-fpga-pulse-edge-detection/sim1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;检测 上/下 边沿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;下降沿检测原理：&lt;/strong&gt; 将第一个寄存器中的数据取反与第二个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 1 变为 0 时，就会在新的寄存器里产生一个高电平，并维持一个周期 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上升沿检测原理：&lt;/strong&gt; 将第二个寄存器中的数据取反与第一个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 0 变为 1 时（上升沿，此时 r1 变为 1，但 r2 仍保持前一周期的 0），就会在新的寄存器里产生一个高电平，并维持一个周期 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
        &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;  
        &lt;span class="p"&gt;);&lt;/span&gt;  

        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
        &lt;span class="n"&gt;end&lt;/span&gt;  

        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// Detect posedge  &lt;/span&gt;
        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// Detect negedge  &lt;/span&gt;

    &lt;span class="n"&gt;endmodule&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl2" src="/images/learning-fpga-pulse-edge-detection/rtl2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim2" src="/images/learning-fpga-pulse-edge-detection/sim2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外一种写法：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
        &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tirg_pos_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;  
        &lt;span class="p"&gt;);&lt;/span&gt;  

        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="k"&gt;else&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
        &lt;span class="n"&gt;end&lt;/span&gt;  

        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  

    &lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl3" src="/images/learning-fpga-pulse-edge-detection/rtl3.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim3" src="/images/learning-fpga-pulse-edge-detection/sim3.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测应用&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;理想的键盘输入特性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keyboard1" src="/images/learning-fpga-pulse-edge-detection/keyboard1.png" /&gt;&lt;/p&gt;
&lt;p&gt;然而实际的键盘受制造工艺等影响，其输入特性不可能如上图完美 。当按键按下时，在触点即将接触到完全接触这段时间里，键盘的通断状态很可能已经改变了多次 。即在这段时间里，键盘输入了多次逻辑 0 和 1，也就是输入处于失控状态 。如果这些输入被系统响应，则系统暂时也将处于失控状态，这是我们要尽量避免的 。在触点即将分离到完全分离这段时间也是一样的 。&lt;/p&gt;
&lt;p&gt;实际的键盘输入特性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keyboard2" src="/images/learning-fpga-pulse-edge-detection/keyboard2.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件消抖&lt;/strong&gt; 要占用系统资源，在系统资源充足的情况下使用软件消抖更加简单 。软件消抖的实质在于降低键盘输入端口的采样频率，将高频抖动略去 。实际应用中通常采用延时跳过高频抖动区间，然后再检测输入做出相应处理。一般程序代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="c1"&gt;//一旦检测到键值&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Delay&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;//延时20ms，有效滤除按键的抖动&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;//再次确定键值是否有效&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt;    &lt;span class="c1"&gt;//执行相应处理&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段软消抖程序从机理上看不会有什么问题，通常在软件程序不太 "繁忙" 的情况下也能够很好的消抖并做相应处理 。但是如果在延时期间产生了中断，则此中断可能无法得到响应 。&lt;/p&gt;
&lt;p&gt;对于硬件资源丰富的 FPGA 系统，可以使用硬件来减轻软件工作量，通常称之为 &lt;strong&gt;"硬件加速"&lt;/strong&gt; 。在按键信号输入到软件系统前用逻辑对其进行一下简单的处理即可实现所谓的"硬件消抖"，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;//对输入信号inpio硬件滤波，每20ms采样一次当前值&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//20ms计数器&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_25m&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d500000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; 
            &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//当前inpio信号锁存，每20ms锁存一拍&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_25m&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;h7ffff&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;inpio_swin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//前后20ms两次锁存值都为0时才为0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该程序中设置了一个 20 ms 计数器，通过间隔 20 ms 对输入信号 inpio 采样两次，两次相同则认为键盘输入稳定，得到用硬件逻辑处理后的 inpio_swin 信号则是消抖处理过的信号 。程序不再需要 delay() 来滤波了，也不会出现使用纯软件处理出现的 "中断失去响应" 的情况了，这就是 "硬件加速" 的效果 。&lt;/p&gt;
&lt;p&gt;我们可以看到，传统单片机等系统大多是串行处理，即顺序执行，只能并行处理一些中断程序 。对于这样的系统，只能采用单纯软件或硬件电路消抖，但都不那么完美 。而对于 FPGA 等并行处理的系统，其优势就很明显，只要片内逻辑资源够用，通过硬件加速软件消抖的处理，完全可以做到按键消抖并行化，不影响系统的实时性 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG_ARTICLE_213430.HTM"&gt;脉冲边沿检测（Verilog）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/lg2lh/article/details/8104551"&gt;脉冲边沿检测原理verilog版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/LVY33/article/details/6225925"&gt;脉冲边缘检测法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_790c0ca10100srid.html"&gt;按键消抖&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category></entry><entry><title>(转载) 如何学习 FPGA</title><link href="http://guqian110.github.io/learning_fpga_how_to.html" rel="alternate"></link><updated>2014-04-07T16:16:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-07:learning_fpga_how_to.html</id><summary type="html">&lt;p&gt;学习 FPGA 差不多一年多，长期混迹于各大论坛，让我学习到了很多知识，转载一篇文章。&lt;/p&gt;
&lt;p&gt;当年在对于 FPGA 什么都不懂的情况下，觉得这篇文章相当高大上，现在看来，的确如此～和别的入门级别的文章书籍相比，这篇文章没有涉及 FPGA 设计的细节，而是很精炼地讲了 FPGA 设计中最基本的 &lt;em&gt;“世界观”&lt;/em&gt; 。也就是说这篇没有一头扎进 &lt;strong&gt;“术”&lt;/strong&gt; 的内容中让读者无从读起，而是从整体上给出 FPGA 设计的 &lt;strong&gt;“道”&lt;/strong&gt; 。对于初学者——尤其是我这样从软件思维过渡过来的人，的确是不错的入门指导 。&lt;/p&gt;
&lt;p&gt;转载地址：&lt;a href="http://www.ednchina.com/ART_8800513345_18_20010_TA_38ec22f4.HTM"&gt;如何学习FPGA？FPGA学习必备的基础知识&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;FPGA已成为现今的技术热点之一，无论学生还是工程师都希望跨进FPGA的大门。网络上各种开发板、培训班更是多如牛毛，仿佛在告诉你不懂FPGA你就OUT啦。那么我们要玩转FPGA必须具备哪些基础知识呢?下面我们慢慢道来。&lt;/p&gt;
&lt;h2&gt;要了解什么是FPGA&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;既然要玩转FPGA，那我们首先最重要的当然是要了解什么 FPGA 。FPGA（Field-Programmable Gate Array），即现场可编程门阵列 。看到编程两个字码农就笑了，不就是编程嘛，那可是我们的强项 。且慢，此编程非彼编程 。一定要把 FPGA 的编程和软件编程区分开来 。软件的编程，处理器会逐条的把语言翻译成各种控制信号，去控制内部电路完成一个个运算或操作 。那么FPGA的编程是怎么实现的呢？无论 Altera 家还是 Xlinix 家的 FPGA，叫法有什么差异，基本单元都相似，都是由真值表和 D 触发器构成 。改变真值表的值就改变了逻辑功能，再通过和D触发器组合来实现任何时序逻辑 。所以我们对 FPGA 的编程，实际上就是去修改这些真值表和连接关系，使他们组成一张专门的真值表，去实现特定的功能 。这和软件编程一步步运行程序有本质的区别 。要想玩转 FPGA，就必须理解 FPGA 内部的工作原理，学习如何利用这些单元实现复杂的逻辑设计 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;正确理解HDL语言&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;HDL（Hardware Description Language），硬件描述语言 。通过名称我们能看出来，HDL语言是一种 “描述” 语言，这一点和 C 语言是有本质区别的 。正确理解描述的含义，对学好 HDL 语言很有帮助 。HDL 语言只是用文本的方式把硬件电路描述出来 。我们在阅读 HDL 程序的时候，在脑子里应该能反映出一个完整的硬件电路结构 。从另一方面说，我们在编写 HDL 语言之前，就已经对要实现的电路有清晰的概念 。所以 HDL 语言只是一个描述我们头脑中具体电路的工具，&lt;strong&gt;玩转 FPGA 的根本不是语言而是逻辑电路设计&lt;/strong&gt;。不要再纠结于我应该学习 VHDL 还是 Verilog，哪种语言更好学这些问题 。如果把学习 FPGA 的重点放在学习语言上，死记硬背一些语法，那自然是抓错了重点 。语言在日常使用中会越用越熟练，不需要花很长的专门时间去学习 。当然一本好的参考资料可以随时方便查询会是很有帮助的 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;数字电路基础&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;说到底，FPGA 就是一堆数字逻辑组合在一起实现特定功能而已 。所以数字电路基础知识是根本 。如果你连触发器，组合电路，时序电路，竞争，毛刺等等基本概念还莫能两可不清不楚的话，那玩转 FPGA 只能是痴人说梦的幻想了 。我们必须要好好的学好数字电路基础这门课，基本的数字电路烂熟于心 。把这些基础打牢固，再往更深的方向发展 。什么时候能够从抽象的算法中提炼算法的结构，再分解成具体的模块并通过硬件电路实现出来，这时候就算从菜鸟级别步入老鸟级别了 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;硬件设计思想&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;这一点应该说是重中之重 。学习 FPGA，一定要有硬件设计思想 。在软件编程的时候，比如 1 秒钟能实现 5 次乘法运算，那系统要求 1 秒钟实现 50 次乘法运算怎么办，我们会尽可能的优化代码，让代码更简洁更高效，或者提高系统主频，让系统跑的更快 。但是在 FPGA 里面我们不是这种思维方式。在 FPGA 里实现一个乘法器不够用，那我就实现两个实现三个去满足系统要求；我可以进行流水线设计；串行运行方式不够快了，我可以先串并转换，再并行的做处理 — —只要 FPGA 的资源够用，我可以充分利用资源去满足系统要求 。因为在我手里的就是一堆硬件资源，我要做的是把他们组合成一个好用的电路 。评价硬件描述语言写的好坏的标准和其他软件编程语言的标准是完全不同的 。因此一定要摒弃软件编程的一些固有思路，学会用硬件的方式去解决问题 。时刻提醒自己正在设计的是一个电路，而不是一行行空洞的代码 。这是很多做软件编程的人很难跨过的坎 。FPGA 学了很久还在纠结到底是用 &lt;code&gt;if-else&lt;/code&gt; 语句好呢还是用 &lt;code&gt;case&lt;/code&gt; 语句好？而不能透过这些语句表面看到他们所具体代表的电路 。只有建立了硬件设计思想，才有更深入学习FPGA的可能 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;FPGA 入门简单精通难 。要想入门，买一块开发板跟着例程走一遍，很多人都能在很短的时间内熟悉开发软件的操作方法并且点亮开发板上的 LED 或者再实现个跑马灯什么的，但是再往后进步往往就进展很慢 。上面提到的这四条是玩转 FPGA 的基础，只有打好了坚实的基础后面才能一马平川 。希望每个学习 FPGA 的人最后都能成为大牛，设计出自己的完美电路 。&lt;/p&gt;</summary><category term="FPGA"></category></entry><entry><title>编写可综合的 Verilog HDL 代码</title><link href="http://guqian110.github.io/writing_synthesizable_code.html" rel="alternate"></link><updated>2014-04-04T01:35:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-04:writing_synthesizable_code.html</id><summary type="html">&lt;p&gt;对电路建模方法有很多种，可以用绘制原理图，也可以用 &lt;em&gt;硬件描述语言（Hardware Description Language）&lt;/em&gt; 建模 。硬件描述语言中最常用的就是 Verlilog 和 VHDL 。&lt;/p&gt;
&lt;p&gt;Verilog HDL和VHDL相比有很多优点，有C语言基础的话很容易上手。搜集了一些网上大神的经验总结和书上的例子，所以对于和我一样的初学者，这篇博客应该还是很有提高作用的，至于具体语法，任何一本书都讲的很详细。&lt;/p&gt;
&lt;h2&gt;HDL&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;从网上找到一篇文章，把 HDL 的历史说的非常清楚。&lt;/p&gt;
&lt;p&gt;作者 董培良 &lt;/p&gt;
&lt;p&gt;题目： &lt;a href="http://www.dzkf.cn/html/EDAjishu/2006/0720/9.html"&gt;浅谈VHDL/Verilog的可综合性以及对初学者的一些建议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要明确的是 VHDL 和 Verilog 并非是针对硬件设计而开发的语言，只不过目前被我们用来设计硬件。HDL 是 Hardware &lt;strong&gt;Description&lt;/strong&gt; Language 的缩写，正式中文名称是 “硬件描述语言”。也就是说，HDL 并不是 “硬件设计语言（Hardware &lt;strong&gt;Design&lt;/strong&gt; Language）”。别看只差这一个单词，正是这一个单词才决定了绝大部分电路设计必须遵循RTL的模式来编写代码，而不能随心所欲得写仅仅符合语法的 HDL 代码。&lt;/p&gt;
&lt;p&gt;VHDL 于 1980 年开始在美国国防部的指导下开发，完成于 1983 年，并于 1987 年成为 IEEE 的标准。当初开发这种语言，是出于美国国防部采购电子设备的需要。美军的装备采购自私人企业，时常要面对这样一种风险：如果某种武器大量装备部队，而其中某个零件的供应商却在几年后倒闭了，那这种武器的再生产、维修和保养都会出现大问题。而电子设备、尤其是集成电路的内部结构较为复杂，若出现前面所说的情况要找其他公司生产代用品非常困难。于是美国防部希望供应商能以某种形式留下其产品的信息，以保证一旦其破产后能由其他厂商迅速生产出代用品。&lt;/p&gt;
&lt;p&gt;显然，当初的设计文档显然是不能交出来的，这在美国会涉及商业机密和知识产权问题。于是美国防部就想出了一种折衷的方法——描述硬件的语言，也就是 VHDL 。通过 VHDL，供应商要把自己生产的集成电路芯片的行为描述出来：比如说，加了什么样的信号后过多少时间它能输出什么等等。这样，如果有必要让其他厂商生产代用品，他们只需照着 VHDL 文档，设计出行为与其相同的芯片即可。这样的代用品相当于是新厂商在不了解原产品结构的情况下独立设计的，所以不太会涉及知识侵权。&lt;/p&gt;
&lt;p&gt;Verilog HDL 也形成于差不多的年代，是由 Gateway Design Automation 公司大约在 1983 年左右开发的。其架构同 VHDL 相似，但主要被用来进行硬件仿真。或许私人公司更注重实用，Verilog 要比 VHDL 简洁得多。&lt;/p&gt;
&lt;p&gt;由此可见，这两种最流行的用于电路设计的语言，没有一种是为了设计硬件而开发的（更何况 80 年代还没有现在的那些功能强大的EDA软件呢）。因此，当初制订 HDL 语言标准的时候，并没有考虑这些代码如何用硬件来实现。换句话说，有些代码写起来简单，实现起来却可能非常复杂，或者几乎不可能实现。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;可综合代码&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;任何符合 HDL 语法标准的代码都是对硬件行为的一种描述，但不一定是可直接对应成电路的设计信息。行为描述可以基于不同的层次，如系统级，算法级，寄存器传输级(RTL)、门级等等。以目前大部分EDA软件的综合能力来说，&lt;strong&gt;只有RTL或更低层次的行为描述才能保证是可综合的&lt;/strong&gt;。而众多初学者试图做的，却是想让软件去综合 &lt;em&gt;算法级或者更加抽象的硬件行为描述&lt;/em&gt;。&lt;/p&gt;
&lt;h3&gt;所有综合工具都支持的语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="nx"&gt;always&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="nx"&gt;wire&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;tri&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;inout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;aupply0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;supply1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="nx"&gt;and&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;nand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;nor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;xor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;xnor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;not&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;bufif0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;bufif1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;notif0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;notif1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;instantitation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;module&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;negedge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;posedge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;operators&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parameter&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;有些工具支持，有些工具不支持的语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;asex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;casez&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;triand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;trior&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;disable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forever&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arrays&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;memories&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;repreat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建立可综合模块的原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不要用 initial （FPGA 上电时初始状态不定，一般需要上电复位信号，在复位信号有效的时候进行初始化，上电复位信号可以由外部手动输入，也可以系统自己产生 —— 写一个实现上电产生自动复位信号的模块）。P.S. 现在的综合软件功能已经足够强大，即使写了 initial 语句，在 ISE 13.3 中仍然是可综合的，而且没有 warning 和 info 的提示）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用 &lt;code&gt;#10&lt;/code&gt;（在仿真中有用，实际在硬件上不会实现）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用循环次数不定的循环语句，如 &lt;code&gt;forever&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt; 等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用用户自定义原语（UDP 原件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除非是关键路径设计，一般不采用调用门级原件描述的设计的方法，建议采用行为语句完成设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用同步方式设计电路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;code&gt;always&lt;/code&gt; 语句描述组合逻辑时，在敏感信号列表中要列出所有输入信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的内部寄存器都应该可以被复位，在 FPGA 设计时应尽量使用器件的全局复位端信号作为系统的总复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序逻辑使用非阻塞赋值，组合逻辑使用阻塞赋值，同一过程块中不要同时使用阻塞和非阻塞两种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要在不同的 &lt;code&gt;always&lt;/code&gt; 过程块中对同一变量赋值（否则综合时会提示有多驱动源错误，&lt;em&gt;multiple source
&lt;/em&gt;），对同一赋值对象，不能既使用阻塞赋值，又使用非阻塞赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不打算把变量综合成锁存器，在 &lt;code&gt;if&lt;/code&gt; 语句或 &lt;code&gt;case&lt;/code&gt; 语句的所有分支中都要对变量明确赋值（不能省去 &lt;code&gt;else&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt;，原理：在省去的情况下，变量的值会保持原来的值不变，所以系统会综合出一个锁存器 Latch）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免混合使用上升沿和下降沿触发器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一变量的赋值不能受多个时钟控制，也不能受两种不同时钟条件（或不同时钟沿）控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免在 &lt;code&gt;case&lt;/code&gt; 语句中使用 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;z&lt;/code&gt; 值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;不可综合代码&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;不可综合语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;defparam&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delays&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UDP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wait&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;initial&lt;/code&gt; 只能在 Testbench 中使用，不能综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;events&lt;/code&gt; 在 Testbench 中更有用，不能综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;real&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;time&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;force&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;assign&lt;/code&gt; 和 &lt;code&gt;deassign&lt;/code&gt; 不支持 &lt;code&gt;reg&lt;/code&gt; 类型的综合，支持 &lt;code&gt;wire&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fork...join&lt;/code&gt; 不可综合，可以用非块语句达到同样的效果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;primitives&lt;/code&gt; 支持门级原语综合，不支持非门级原语综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;table&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt; 的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一个 &lt;code&gt;reg&lt;/code&gt; 被多个 &lt;code&gt;always&lt;/code&gt; 块驱动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;延时，不可综合为硬件电路延时，综合工具会忽略延时，但是不会报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与 &lt;code&gt;x&lt;/code&gt;、&lt;code&gt;z&lt;/code&gt; 比较，综合工具会忽略，所以要保证信号只有两个状态，&lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;判断是否可综合&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;继续引用 &lt;strong&gt;董培良&lt;/strong&gt; 的文章：&lt;/p&gt;
&lt;p&gt;用一句简单的话概括：电脑永远没有你聪明 。具体来说，通常 EDA 软件对 HDL 代码的综合能力总是比人差 。对于一段代码，如果你不能想象出一个较直观的硬件实现方法，那 EDA 软件肯定也不行。比如说，加法器、多路选择器是大家都很熟悉的电路，所以类似&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的运算一定可以综合。而除法、开根、对数等等较复杂的运算，必须通过一定的算法实现，没有直观简单的实现方法，则可以判断那些计算式是不能综合的，必须按它们的算法写出更具体的代码才能实现 。此外，硬件无法支持的行为描述，当然也不能被综合（比如想在 FPGA 上实现 DDR 内存那样的双延触发逻辑，代码很容易写，但却不能实现）。&lt;/p&gt;
&lt;p&gt;不过，这样的判断标准非常主观模糊，遇到具体情况还得按设计人员自己的经验来判断 。如果要一个相对客观的标准，一般来说：在 RTL 级的描述中，所有逻辑运算和加减法运算、以及他们的有限次组合，基本上是可综合的，否则就有无法综合的可能性 。当然，这样的标准仍然有缺陷，更况且 EDA 的技术也在不断发展，过去无法综合的代码或许将来行，某些软件不支持的代码换个软件或许行 。比如固定次数的循环，含一个常数参数的乘法运算等等，有些 EDA 软件支持对它们的综合，而有些软件不行。&lt;/p&gt;
&lt;p&gt;所以，正确的判断仍然要靠实践来积累经验。当你可以较准确判断代码的可综合性的时候，你对 HDL 的掌握就算完全入门了。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.dzkf.cn/html/EDAjishu/2006/0720/9.html"&gt;浅谈VHDL/Verilog的可综合性以及对初学者的一些建议&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="Verilog"></category></entry><entry><title>学习 FPGA 入门</title><link href="http://guqian110.github.io/learning_fpga_getting_started.html" rel="alternate"></link><updated>2014-04-03T12:40:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-03:learning_fpga_getting_started.html</id><summary type="html">&lt;h2&gt;FPGA 是什么&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 是 PLD 家族中的一员，要说清楚什么是 FPGA，就不得不说一说 PLD 。（&lt;strong&gt;以下内容来自wikipedia&lt;/strong&gt;）&lt;/p&gt;
&lt;h3&gt;PLD &amp;amp; ASIC&lt;/h3&gt;
&lt;p&gt;早期的数字逻辑系统，是由中、小规模集成电路芯片搭建而成的。这种形式的电路在可靠性、工作速度、功耗和体积方面都难以满足大规模、高性能信息处理系统的要求 。后来，随着集成电路的发展，出现可专用集成电路 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专用集成电路&lt;/strong&gt;（Application Specific Integrated Circuits, &lt;a href="http://en.wikipedia.org/wiki/Application-specific_integrated_circuit"&gt;&lt;code&gt;ASIC&lt;/code&gt;&lt;/a&gt;）是指依产品需求不同而非通用目的，而自定义的特殊规格集成电路 。ASIC 可以将整个系统集成到一个芯片上。由于芯片内集成度高、连线短，所以它可以满足之前 ”搭建系统“ 难以满足的性能指标 。&lt;/p&gt;
&lt;p&gt;随着芯片尺寸的减小和设计工具的发展，这些年来 ASIC 芯片最大的集成度从 5,000 增长到了 超过100,000,000 门 。现代的 ASIC 通常都包含了微处理器、存储块（如 ROM 、RAM 、EEPROM 、Flash 等）。这种 ASIC 被称为 SoC （&lt;a href="http://en.wikipedia.org/wiki/System-on-chip"&gt;system on chip&lt;/a&gt;），ASIC 设计师采用硬件描述语言（Hardware Description Language，HDL），比如 Verilog、VHDL，描述 ASIC 的功能 。&lt;/p&gt;
&lt;p&gt;但是 ASIC 的研制周期长，现代信息处理的快速发展要求集成电路的设计、测试和生产周期尽可能的段，这就促进了可编程逻辑器件的发展 。严格地说，有些可编程器件出现的时间比 ASIC 出现的早，这里说的可编程器件主要是指 CPLD/FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可编程逻辑器件&lt;/strong&gt;（Programmable Logic Device,&lt;a href="http://en.wikipedia.org/wiki/Programmable_logic_devices"&gt;&lt;code&gt;PLD&lt;/code&gt;&lt;/a&gt;）是一种用来搭建可重配置数字电路的电子器件。和逻辑门（logic gate）不同，PLD 出厂时逻辑功能是没有被定义的，在使用之前，必须先重配置（reconfigure）。&lt;/p&gt;
&lt;h3&gt;历史&lt;/h3&gt;
&lt;h4&gt;ROM as PLD&lt;/h4&gt;
&lt;p&gt;在 PLD 器件被发明之前，就已经有人 &lt;em&gt;将 &lt;a href="http://en.wikipedia.org/wiki/Read-only_memory"&gt;ROM&lt;/a&gt; 以 PLD 的概念来运用&lt;/em&gt;，用 ROM 芯片来充当一些输入性的组合逻辑（combinatorial logic）的函数发生器。ROM 有 m 个地址线，则有 &lt;code&gt;n = 2^m&lt;/code&gt; 个输出结果，这和布尔逻辑是一一对应的，所以如果把 ROM 的地址线当作相互之间没有关系的输入，则相应的输出就可以实现不同的函数。&lt;/p&gt;
&lt;p&gt;早期的 Mask ROM 存储数据的方式是使用内部的硬件电路，所以只能在出厂时就写入数据，而且以后不能更改。这就导致了一系列缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因为消费者必须联系制造商才能生产出自定义的芯片，所以只有买大量的 ROM 芯片时才经济划算 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为同样的原因，从设计到最终生产出产品，中间耗费的时间很长 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mask ROM 在研发中基本上不能使用，因为设计师在改进设计时需要经常改动 ROM 里面的值 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个设备中含有故障的 Mask ROM，那么修复这个设备的唯一方法就是召回设备并且更换其中的每一个 Mask ROM 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;PROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_read-only_memory"&gt;PROM&lt;/a&gt;（Programmable Read Only Memory）是周文俊于 1956 年发明的。他在纽约 Garden City 的 American Bosch Arma Corporation 工作，当时，美国空军为了提升空军用计算机以及Atlas E/F波段导弹的灵活性和保安性而提出要求，这项技术就是为了满足这一要求而产生的 。&lt;/p&gt;
&lt;p&gt;PROM 是通过熔丝/反熔丝（fuse/antifuse）实现对每个 bit 的设置 。通过使用高电压脉冲改变内部的物理结构，这种方法通常是不可逆的，所以它只允许用户更改一次配置 。PROM 解决了上面提到的问题 1 和问题 2 ，因为公司可以买一大批没有配置过的 PROM，设计人员可以根据自己的需要随意配置 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EPROM"&gt;EPROM&lt;/a&gt;（Erasable Programmable Read Only Memory）是 intel 公司的 Dov Frohman 于 1971 年发明的 。与 PROM 不同的是，EPROM 可利用高电压将资料编程写入，通过紫外线照射的方式不断的重置为未配置状态。因此，在封装外壳上会预留一个石英玻璃所制的透明窗以便进行紫外线曝光。写入程序后通常会用贴纸遮盖透明窗，以防日久不慎曝光过量影响资料。&lt;/p&gt;
&lt;p&gt;因为EPROM 可以重复配置，所以它解决了上面的第 3 个问题 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EEPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EEPROM"&gt;EEPROM&lt;/a&gt;（Electrically Erasable Programmable Read-Only Memory）于 1983 年被发明出来。相比EPROM，EEPROM不需要用紫外线照射，也不需取下，就可以用特定的电压，来抹除芯片上的信息，以便写入新的数据 。&lt;/p&gt;
&lt;p&gt;如果设备可以从外部接收数据（比如 PC 通过串口线），就可以在线配置 EEPROM，这样它解决了问题 4 。&lt;/p&gt;
&lt;p&gt;虽然解决了上面的 4 个问题，但是把 ROM 当作 PLD 器件使用，还是有很多弊端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;与专用逻辑电路相比，ROM 的速度很慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当输入不同步时（异步状态），ROM 的输出有毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更加耗电&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与可编程逻辑相比，价格更贵，尤其是高速应用中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而且，大部分 ROM 没有输出寄存器，所以它不能直接应用在时序电路中，所以在状态机的设计中，通常还需要一个外部的 TTL 寄存器 。对电路设计的业余爱好者来说，有时也仍然用“2716”之类的普遍型EPROM芯片来充当PLD，这种用法有时也称为“穷人的PAL”。（PAL也是PLD的一种，以下将再进一步说明）&lt;/p&gt;
&lt;p&gt;于是，就出现了 PLD 器件。&lt;/p&gt;
&lt;h4&gt;早期可编程逻辑&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1969 年，Motorola 生产出 XC157，它是一个有 12 个逻辑门和 30 个独立输入/输出管脚的可编程逻辑正列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（PLA）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1971 年，通用电器公司（GE）在新的 PROM 技术的基础上发明了一种可编程逻辑器件。这个实验性质的设备通过使用多层逻辑来提高 IBM 的 ROAM 性能 。GE 的这个设备是最早的 PLD 设备，比 Altera 的 EPLD 早了十几年 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1974 年，GE 和 Monolithic Memories 达成协议，开发一种可编程逻辑器件。这个设备被称为 ”Programmable Associative Logic Array“ 或者是 PALA 。最终于 1976 年完成 MMI 5760 ，它可以实现超过 100 门的时序电路。GE 的开发环境支持这一器件，它可以直接将布尔表达式转化为配置器件的代码，然而最终这个器件却没有上市。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;PLA&lt;/h4&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（&lt;a href="http://en.wikipedia.org/wiki/Programmable_Logic_Array"&gt;PLA&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;PLA 具有一组可编程的 AND 阵列，AND 阵列之后连接一组可编程的 OR 阵列 ，这样就可以只在合乎设定条件时才允许产生逻辑信号输出 。&lt;/p&gt;
&lt;p&gt;虽然名字中含有可编程 3 个字，但是并不是所有的 PLA 都可以现场编程，事实上许多都属遮罩性的可编程化，性质与ROM相同，必须在芯片制造厂内就执行与完成程序化设定，尤其是内嵌于电路较复杂的芯片（例如：微处理器）的PLA多属此种程序化方式。&lt;/p&gt;
&lt;h4&gt;PAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_Array_Logic"&gt;PAL&lt;/a&gt;（Programmable Array Logic）是 Monolithic Memories 公司在 1978 年 3 月提出的，在数字电路中用来搭建逻辑功能的可编程器件的总称 。PAL 内部含有固定的或门阵列，可编程的与门阵列，从而实现所要求的逻辑函数。&lt;/p&gt;
&lt;p&gt;PAL 内部有个 PROM 的核，外部附加的输出逻辑电路，这样就可以实现所需要的逻辑功能 。因为 PAL 是基于 PROM 的，所以要使用特殊的设备，PAL 才具有可编程性，而且是 ”一次编程“ 。&lt;/p&gt;
&lt;h4&gt;GAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Generic_array_logic"&gt;GAL&lt;/a&gt;（Generic array logic）是 PAL 的发展，是 Lattice Semiconductor 于 1985 年发明 。这个设备具有和 PAL 同样的功能，但是可以重配置多次，所以 GAL 在设计中很有用，一旦有错误，只需要擦除后重新配置即可 。&lt;/p&gt;
&lt;p&gt;后来，International CMOS Technology (ICT) 公司发明了 类似的设备，称为 PEEL（programmable electrically erasable logic）。&lt;/p&gt;
&lt;h4&gt;CPLD&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Complex_programmable_logic_device"&gt;CPLD&lt;/a&gt;（Complex programmable logic device）适合用来实现各种运算和组合逻辑（combinational logic）。PAL、GAL仅适合用在约数百个逻辑门所构成的小型电路，若要实现更大的电路则适合用 CPLD，一颗CPLD内等于包含了数颗的PAL，各PAL（逻辑区块）间的互接连线也可以进行程序性的规划、烧录，CPLD运用这种多合一（All-In-One）的整合作法，使其一颗就能实现数千个逻辑门，甚至数十万个逻辑门才能构成的电路。&lt;/p&gt;
&lt;p&gt;CPLD 与 PAL 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非易失性配置存储器。与 FPGA 不同，CPLD v不需要外部的 ROM，只要系统上电，就可以正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于许多旧的 CPLD 来说，布线约束要求大部分逻辑块要和输入输出相连接，以减少内部状态记录，对于新的 CPLD 系列来说，已经不需要这样了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPLD 与 FPGA 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以利用大量的逻辑资源，CPLD 等价有有数百万的逻辑门资源可以用来实现比较复杂的设计，而 PAL 最多等价有几千个逻辑门，FPGA 有几万到几百万的逻辑门。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供一些更加灵活的资源，比如宏模块之间复杂的反馈连接和整数运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大的 CPLD 和小 FPGA 之间最显著的差别就是 CPLD 含有片内非易失性存储器 。因为非易失性存储器的特点，CPLD 在数字电路设计中被当作 ”boot loader“ 来使用，之后它再把系统的控制权转交给没有这种特性的设备，最好的例子就是使一块 CPLD 从非易失性存储器中装载配置 FPGA 所需要的数据 。&lt;/p&gt;
&lt;h4&gt;FPGA&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array"&gt;FPGA&lt;/a&gt;（Field Programmable Gate Array，FPGA）是在 PAL、GAL、CPLD 等可编程逻辑器件的基础上进一步发展的产物。它是作为专用集成电路领域中的一种半定制电路而出现的，既解决了全定制电路的不足，又克服了原有可编程逻辑器件门电路数有限的缺点。&lt;/p&gt;
&lt;p&gt;当 PAL 忙于进展成 GAL、CPLD 时，另一种 “可编程化” 的流派也逐渐成形，此称之为现场可编程闸阵列（Field Programmable Gate Array，FPGA）。FPGA是以阵列（Gate Array）技术为基础所发展成的一种PLD 。所谓 ”Field Programmable“ 就是说芯片是出厂以后由客户或者设计师配置而工作的 。&lt;/p&gt;
&lt;p&gt;1980 年代后期，Naval Surface Warfare Department 在 Steve Casselman 的提议下成立了实验项目，目的是为了研制一台由 600,000 个逻辑门组成的计算机。Casselman 最后成功了并且在 1992 年获得了专利 。&lt;/p&gt;
&lt;p&gt;Xilinx 公司的共同创世人 &lt;a href="http://en.wikipedia.org/wiki/Ross_Freeman"&gt;Ross Freeman&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Bernard_Vonderschmitt"&gt;Bernard Vonderschmitt&lt;/a&gt; 在 1985 年发明出第一款商业 FPGA —— XC2064 。XC2064 芯片有可以编程的逻辑门和可以编程的内部连接线，这开辟了一项新的技术和市场 。XC2064 有 64 个可配置逻辑块（configurable logic blocks，CLBs），和 3 输入查找表（lookup tables，LUTs）。&lt;/p&gt;
&lt;p&gt;从 1985 开始到 90 年代中期，Xilinx 一直处于高速发展阶段，之后竞争对手出现了，截至 1993 年，Actel 占据了 18% 的市场 。&lt;/p&gt;
&lt;p&gt;90 年代是 FPGA 爆炸式发展的年代，这一期间出现了大量高端技术和产品。在 90 年代初期，FPGA 主要应用于通信领域，在 90 年代后期，FPGA 已经广泛应用于消费品、汽车和工业应用 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;为什么选择 FPGA&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;FPGA vs ASIC&lt;/h3&gt;
&lt;p&gt;ASIC 的优点：&lt;/p&gt;
&lt;p&gt;ASIC 在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低 。&lt;/p&gt;
&lt;p&gt;ASIC 的缺点：&lt;/p&gt;
&lt;p&gt;设计周期最长，设计成本贵，设计费用最高，适合于批量很大或者对产品成本不计较的场合。&lt;/p&gt;
&lt;p&gt;至于 FPGA 的优点和缺点完全就是 ASIC 的取反 。FPGA 一般来说比专用集成电路（ASIC）的速度要慢，无法完成更复杂的设计，并且会消耗更多的电能。但是，FPGA 具有很多优点，比如可以快速成品，而且其内部逻辑可以被设计者反复修改，从而改正程序中的错误，此外，使用 FPGA 进行除错的成本较低 。在一些技术更新比较快的行业，FPGA几乎是电子系统中的必要部件，因为在大批量供货前，必须迅速抢占市场，这时FPGA方便灵活的优势就显得很重要。这也是 FPGA 能够发展起来的原因，市场是不会允许一个毫无优势的技术发展到今天这种地步的 。&lt;/p&gt;
&lt;p&gt;个人认为两者不是对立的，由于各自的特点，它们有各自适用的环境，不能一棒子打死，否定其中一个 。事实上更多的情况是：设计的开发是在普通的FPGA上完成的，然后将设计转移到一个类似于专用集成电路的芯片上 。&lt;/p&gt;
&lt;h3&gt;FPGA vs CPLD&lt;/h3&gt;
&lt;p&gt;为了达到上述目的，还有一种方法是使用 CPLD 。
CPLD和FPGA都包括了一些相对大数量的可以编辑逻辑单元。CPLD逻辑门的密度在几千到几万个逻辑单元之间，而FPGA通常是在几万到几百万。&lt;/p&gt;
&lt;p&gt;FPGA 与 CLPD 最大的区别就是：FPGA 是基于查找表（look up table，LUT），而 CPLD 是基于海门架构（sea-of-gates），也就是它们的系统结构 。CPLD 的结构具有一定的局限性 。这个结构由一个或者多个可编辑的结果之和的逻辑组列和一些相对少量的锁定的寄存器组成 。这样的结果是缺乏编辑灵活性，但是它的优点是，其延迟时间易于预计，逻辑单元对连接单元比率较高 。而FPGA具有的连接单元数量很大，这样虽然让它可以更加灵活的编辑，但是结构却复杂的多 。&lt;/p&gt;
&lt;p&gt;CPLD 和 FPGA 另外一个区别是大多数的 FPGA 含有高层次的内置模块（比如加法器和乘法器）和内置的存储器 。一个由此带来的重要区别是，很多新的 FPGA 支持完全的或者部分的系统内重新配置 。允许他们的设计随着系统升级或者动态重新配置而改变 。一些FPGA可以让设备的一部分重新编辑，而其他部分继续正常运行 。&lt;/p&gt;
&lt;p&gt;CPLD 与 FPGA 之间结构、原理上的差别导致两者应用上的差别 。考虑成本、性能要求等因素，应该根据实际情况选择 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Xilinx &amp;amp; Altera&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 的制造商主要是 Xilinx 和 Altera 两家，他们合起来市场占有率达到了 80% 之多 。两家是 FPGA 技术的领导者也是长期竞争对手 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Xilinx"&gt;Xilinx&lt;/a&gt; 于 1984 年创建于美国加利福尼亚州的硅谷，总部位于硅谷核心的圣何塞。它是一家主要提供 FPGA 的科技公司 。并且就是它的创始人是发明了 FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Altera"&gt;Altera&lt;/a&gt; 是一家位于美国硅谷的可编程逻辑器件和 CPLD 的制造商 。该公司于1984年推出了其首款可编程逻辑设备。&lt;/p&gt;
&lt;p&gt;两家一直是互为竞争对手，一般来说，大学里面都 Altera 的器件和 VHDL 上课，所以在学校里面用 Xilinx 的人比较少 。&lt;/p&gt;
&lt;p&gt;因为原理是一样的，所以只要学会一种，另一种就很容易上手。学校实验室里面用的是 Xilinx 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Xilinx FPGA Architecture（架构）&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 需要反复烧写，所以不能像 ASIC 一样通过固定的与非门来完成，只能采用一种易于反复配置的结构，查找表就可以很好的满足这一要求。目前主流 FPGA 都是采用了基于 SRAM 工艺的查找表结构（军品和宇航级 FPGA 采用 Flash或者熔丝/反熔丝工艺），通过烧写文件改变查找表内容的方法来实现对 FPGA 的重复配置。&lt;/p&gt;
&lt;p&gt;查找表（look-up table，LUT）本质上就是一个 RAM 。当用户通过原理图或 HDL 语言描述了一个电路以后，FPGA 开发软件会计算逻辑电路的所有可能结果，并把真值表事先写入 RAM，这样，每输入一个信号进行逻辑运算就相当于输入一个地址进行查找，这样 LUT 就具有了和逻辑电路相同的功能 。实际上，LUT 具有更快的执行速度和更大的规模 。&lt;/p&gt;
&lt;p&gt;上电时，FPGA将外部存储器中的数据读入片内RAM，完成配置后，进入工作状态；掉电后FPGA恢复为白片，内部逻辑消失。这样FPGA不仅能够反复使用，还无须专门的FPGA编程器，只需通用的EPROM、PROM编程器即可。&lt;/p&gt;
&lt;p&gt;目前，Xilinx FPGA 仍然是基于查找表技术，但是其概念已经远远超出查找表技术的限制，并且整合了常用功能的硬核模块（如块 RAM，时钟管理和 DSP）。Xilinx FPGA 内部大致可以分为 6 部分：&lt;/p&gt;
&lt;h3&gt;IOB&lt;/h3&gt;
&lt;p&gt;可编程输入/输出单元简称 I/O 单元，是芯片与外界电路的接口部分，完成不同电气特性下输入/输出信号的驱动和匹配 。&lt;/p&gt;
&lt;h3&gt;CLB&lt;/h3&gt;
&lt;p&gt;CLB（Configurable Logic Block）是 FPGA 内的基本逻辑单元，Xilinx FPGA 的 CLB 由多个相同的 Slice 和附加逻辑组成 。&lt;/p&gt;
&lt;h3&gt;DCM&lt;/h3&gt;
&lt;p&gt;业内大多数 FPGA 都提供数字时钟管理（Digital Clock Manager）。Xilinx FPGA 提供 DCM 和 PLL 。&lt;/p&gt;
&lt;h3&gt;BRAM&lt;/h3&gt;
&lt;p&gt;大多数 FPGA 都具有内嵌的块 RAM，这大大扩展了 FPGA 的应用范围和灵活度 。块 RAM 可以被配置为单口 RAM、双端口 RAM、内容地址存储器（CAM）和 FIFO 等常用存储结构 。&lt;/p&gt;
&lt;h3&gt;Routing Resource&lt;/h3&gt;
&lt;p&gt;布线资源连通 FPGA 内部的所有单元，而连线的长度和工艺决定着信号在连线上的驱动能力和传输速度 。Xilinx FPGA 的布线资源可以分为 4 类：全局布线资源、长线资源、短线资源、分布式资源 。&lt;/p&gt;
&lt;h3&gt;Embedded Module&lt;/h3&gt;
&lt;p&gt;内嵌功能模块只要是指 DLL、PLL、DSP 和 CPU 等 &lt;strong&gt;软核&lt;/strong&gt;，还有底层的 &lt;strong&gt;硬核&lt;/strong&gt; 资源，比如内嵌的 Power PC、ARM9、DSP芯片等 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Xilinx 主流 FPGA&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Xilinx 主流的 FPGA 主要有A系列、K系列、V系列、Spartan系列，如今还有最新的 Zynq 系列，官网上有详细介绍 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;开发流程&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 的开发流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="design flow" src="/images/learning-fpga-getting-started/design-flow.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;整个开发过程就是使用开发工具 ISE Design Suite，按照流程图进行 。图示是标准流程，但是实际上并不是严格按照每一个步骤进行 。&lt;/p&gt;
&lt;p&gt;一般简化过的流程是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设计可综合的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合 Systhesis&lt;/p&gt;
&lt;p&gt;前两步主要是确保写的代码是开发工具可以转化为实际电路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合后仿真&lt;/p&gt;
&lt;p&gt;这一步保证模块的逻辑功能是正确的，即检验模块的结果是否和预期一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序约束&lt;/p&gt;
&lt;p&gt;为设计添加时序约束和管脚约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现 Implement&lt;/p&gt;
&lt;p&gt;按照约束条件将综合结果映射到实际器件中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序分析&lt;/p&gt;
&lt;p&gt;实际上，一次就能达到时序要求且布线成功的情况并不多，尤其是对于高速设计，所以需要根据上一步的时序结果对设计进行修改，以满足时序要求，类似于写软件的 Debug 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载，在线调试&lt;/p&gt;
&lt;p&gt;将设计下载到芯片中调试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_logic_devices"&gt;PLD wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array"&gt;FPGA wikipedia&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category></entry><entry><title>Ubuntu 下安装 ISE &amp; ModelSim</title><link href="http://guqian110.github.io/install_ise_modelsim_on_ubuntu.html" rel="alternate"></link><updated>2014-03-27T20:52:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-03-27:install_ise_modelsim_on_ubuntu.html</id><summary type="html">&lt;p&gt;从 Windows 平台转移到 Linux，于是把 FPGA 的开发平台也搬过来。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;软件版本：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu 13.10 Desktop amd64 &lt;/p&gt;
&lt;p&gt;ISE 14.7 for Linux&lt;/p&gt;
&lt;p&gt;ModelSim 6.5b for Linux&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;下载&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE Design Suit for Linux&lt;/h3&gt;
&lt;p&gt;Xilinx 官方网站上有&lt;a href="https://secure.xilinx.com/webreg/register.do?group=dlc&amp;amp;htmlfile=&amp;amp;emailFile=&amp;amp;cancellink=&amp;amp;eFrom=&amp;amp;eSubject=&amp;amp;version=14.7&amp;amp;akdm=1&amp;amp;filename=Xilinx_ISE_DS_Lin_14.7_1015_1.tar"&gt;下载链接&lt;/a&gt;，但是在校园网内下载速度实在是蛋疼，还好有校内 bt 资源。&lt;/p&gt;
&lt;p&gt;我下载下来的 ISE 版本为 &lt;strong&gt;14.7&lt;/strong&gt;，tar 包大小为 6.5 G 。&lt;/p&gt;
&lt;h3&gt;ModelSim for Linux&lt;/h3&gt;
&lt;p&gt;网上的教程（2011 年前）都说是 &lt;a href="http://www.mentor.com/products/fpga/model"&gt;ModelSim 官方网站&lt;/a&gt; 上提供 ftp 下载链接，但是好像现在官网上不再提供下载链接了，我只找到 ModelSim PE Student Edition，而且还是 Windows 平台的...&lt;/p&gt;
&lt;p&gt;花费了一下午的时间，不停地在各个论坛注册下载附件，终于把 ModelSim_6.5b for Linux 下载下来了,结果安装时提示找不到 &lt;code&gt;libxp.so.6&lt;/code&gt; 库，于是 &lt;code&gt;apt-get&lt;/code&gt; 到一些 &lt;code&gt;libxp&lt;/code&gt; 的库，安装后仍然提示找不到，无奈放弃了，准备老老实实用 &lt;code&gt;ism&lt;/code&gt; 了（以后有时间了再慢慢折腾 T_T）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE DS 14.7&lt;/h3&gt;
&lt;p&gt;首先解压&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xvf&lt;/span&gt; &lt;span class="n"&gt;Xilinx_ISE_DS_Lin_14&lt;/span&gt;&lt;span class="mf"&gt;.7&lt;/span&gt;&lt;span class="n"&gt;_1015_1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着进入解压出来的目录并给安装文件赋予执行的权限&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;Xilinx_ISE_DS_Lin_14&lt;/span&gt;&lt;span class="mf"&gt;.7&lt;/span&gt;&lt;span class="n"&gt;_1015_1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;chmod&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;xsetup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后执行 xsetup&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;xsetup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后熟悉的图形界面就出来，和 Windows 下一样，同意安装许可协议，不停地下一步就可以安装成功。&lt;/p&gt;
&lt;p&gt;安装完成以后，运行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;14.7&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE_DS&lt;/span&gt;
    &lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="n"&gt;settings64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时，已经可以从终端运行 ISE 了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;nohup&lt;/span&gt; &lt;span class="n"&gt;ise&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;熟悉的图形界面出来了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ise" src="/images/install-ise-modelsim/ise_start.png" /&gt;&lt;/p&gt;
&lt;p&gt;P.S.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择安装版本时，选择 &lt;code&gt;System Edition&lt;/code&gt;，因为这个版本功能最全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择安装组件时，不要勾选 &lt;code&gt;Install Cable Drivers&lt;/code&gt;，我们自己编译安装另外一个驱动（因为此驱动只能在 Linux 内核 &amp;lt; 2.6的版本中使用，所以即使勾选了最后安装完成时会提示 &lt;em&gt;Driver installation failed&lt;/em&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Crack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又到了该和谐的地方了 =.=&lt;/p&gt;
&lt;p&gt;第一次打开 ISE 时，会自动弹出 License Management Tools 提示我们添加 License 。网上有一大堆破解包，我使用以前在 Windows 中生成的 Lincese，直接就可以使用了～&lt;/p&gt;
&lt;p&gt;再次声明：仅供技术交流，请支持正版软件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;installing Cable Drivers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如前面所说，因为 ISE 自带的驱动程序依赖于一个叫 windrvr 的文件。 而该文件目前只有 Linux 内核 2.4 的二进制版本，因此遇到高于 2.4 内核的 Linux发布版，如我使用的Ubuntu 13.10（Linux version 3.11.0-12-generic ） 就不工作了。&lt;/p&gt;
&lt;p&gt;好在一个叫 Michael Gernoth 的德国人，大公无私地写了一个 windrvr 的替代版本，并且开放源码，这样，无论碰到什么版本的内核，现场编译一个驱动并安装， 就能解决 Linux 内核版本匹配的问题。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://rmdir.de/~michael/xilinx/"&gt;XILINX JTAG tools on Linux without proprietary kernel modules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以按照说明&lt;/p&gt;
&lt;p&gt;首先安装 usb 驱动开发包，在 64 位系统下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;libusb&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="n"&gt;libc6&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt; &lt;span class="n"&gt;fxload&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着下载驱动程序的源代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;
    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//git.zerfleddert.de/usb-driver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后编译驱动程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;usb&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;make&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载下来的源代码中有个脚本可以设置好一切，我们只需要运行脚本就 ok&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;setup_pcusb&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;14.7&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE_DS&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把 Xilinx 路径添加到系统 PATH 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;PATH=\$PATH:/opt/Xilinx/13.2/ISE_DS/ISE/bin/lin64/&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bashrc&lt;/span&gt;
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;export PATH&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bashrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这时候，写个小测试的程序，&lt;code&gt;Systhesize&lt;/code&gt; -&amp;gt; &lt;code&gt;Implement&lt;/code&gt; -&amp;gt; &lt;code&gt;Generate Programming File&lt;/code&gt;，打开 &lt;code&gt;iMPACT&lt;/code&gt;, 如图所示，可以看到已经识别出 JTAG 链上的芯片&lt;/p&gt;
&lt;p&gt;&lt;img alt="jtag" src="/images/install-ise-modelsim/jtag.png" /&gt;&lt;/p&gt;
&lt;h3&gt;ModelSim&lt;/h3&gt;
&lt;p&gt;待续...&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;配置 ISE &amp;amp; ModelSim&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE&lt;/h3&gt;
&lt;p&gt;其实也没有特殊配置的地方，主要是自定义代码编辑器，目前我的主要使用的是 &lt;code&gt;sublime text 2&lt;/code&gt;，正在向 &lt;code&gt;vim&lt;/code&gt; 过度ing&lt;/p&gt;
&lt;p&gt;具体步骤 Edit -&amp;gt; Preferences -&amp;gt; Editors，选择 &lt;code&gt;custom&lt;/code&gt;，在右侧的 “Command line syntax” 中写自定义编辑器的执行路径&lt;/p&gt;
&lt;p&gt;配置自定义编辑器为 vim&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;gnome&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;terminal&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;maximize&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;ModelSim&lt;/h3&gt;
&lt;p&gt;ModelSim 编译 Xilinx库，ISE 关联 ModelSim&lt;/p&gt;
&lt;p&gt;待续...&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://rmdir.de/~michael/xilinx/"&gt;XILINX JTAG tools on Linux without proprietary kernel modules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.george-smart.co.uk/wiki/Xilinx_JTAG_Linux"&gt;Xilinx JTAG Linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/yunz1994/article/details/12350071"&gt;【Linux软件安装】Ubuntu12.04: Xilinx ISE 14.6&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="Linux"></category></entry></feed>