<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Geek Bunny's World</title><link href="http://guqian110.github.io/" rel="alternate"></link><link href="http://guqian110.github.io/feeds/fpga.atom.xml" rel="self"></link><id>http://guqian110.github.io/</id><updated>2014-10-09T23:01:00+08:00</updated><entry><title>FPGA 时钟设计 3 —— 跨时钟域设计</title><link href="http://guqian110.github.io/pages/2014/10/09/the_clock_design_in_fpga_3_multiasynchronous_clock_design.html" rel="alternate"></link><updated>2014-10-09T23:01:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-10-09:pages/2014/10/09/the_clock_design_in_fpga_3_multiasynchronous_clock_design.html</id><summary type="html">&lt;h2 id="problem"&gt;Problem&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;在前面一篇总结 &lt;a href="http://guqian110.github.io/pages/2014/09/23/latch_versus_flip_flop.html"&gt;Latch V.S. Flip-flop&lt;/a&gt; 的博文中，已经解释了 flip-flop 的一些参数：建立时间 &lt;code&gt;setup time&lt;/code&gt;、保持时间 &lt;code&gt;hold time&lt;/code&gt;、回复时间 &lt;code&gt;recovery time&lt;/code&gt;、撤销时间 &lt;code&gt;removal time&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果不满足这些参数的要求，则会发生所谓的 亚稳态 &lt;code&gt;Metastability&lt;/code&gt; 的问题。下面是 Altera 官方的一篇关于亚稳态的 white paper，详细介绍了亚稳态的产生原因、它是如何导致设计出现问题、以及描述它的参数 MTBF (Mean Time Between Failures) 如何计算。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.altera.com.hk/literature/wp/wp-01082-quartus-ii-metastability.pdf"&gt;Understanding Metastability in FPGAs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们知道，一般只涉及单时钟域的设计并不多见，尤其是对于一些复杂的应用，FPGA 往往需要和多个时钟域的信号进行通信，而这些时钟之间的关系一般都是频率不同、相位也不同，也就是不同频不同相的多异步时钟域设计 &lt;code&gt;Mulit-Asynchronous Clock Design&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为这些时钟信号之间的关系一般既不同频也不同相，所以一个时钟域的信号对于另外一个时钟域来说是异步信号，那么就无法保证进入新时钟域的信号和新的时钟信号之间满足 setup/hold time 的要求，最然就会引起亚稳态的问题。&lt;/p&gt;
&lt;p&gt;在 Clifford E. Cummings 大神的 paper：&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt; 里面就举例说明了这种现象：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"When sampling a changing data signal with a clock ... the order of the events determines the outcome. The smaller the time difference between the events, the longer it takes to determine which came first. When two events occur very close together, the decision process can take longer than the time allotted, and a synchronization failure occurs."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Illustation 1: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="failure" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronization_failure.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Illustation 2: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果不加处理，亚稳态产生的错误值将会传播到设计的其他部分，到这更加严重的问题&lt;/p&gt;
&lt;p&gt;&lt;img alt="propagatetion" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/propagation.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="synchronous-design"&gt;Synchronous Design&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;多时钟域导致的亚稳态的问题的根本原因就是：信号和时钟是异步的，也就是设计不是同步设计 &lt;code&gt;Synchronous Design&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步化设计思想&lt;/strong&gt; 是 FPGA 中非常重要的原则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Asynchronous Circuits&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步电路的核心逻辑是用 组合逻辑 &lt;code&gt;combination logic&lt;/code&gt; 实现的，比如异步FIFO/RAM 读写信号、地址译码等电路。电路的主要信号、输出信号不依赖任何一个时钟信号，不是由时钟信号驱动 flip-flop 产生的。&lt;em&gt;异步电路最大的缺点就是容易产生毛刺。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Synchronous Circuits&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步电路的核心逻辑是用 时序逻辑 &lt;code&gt;sequential logic&lt;/code&gt; 实现的。电路的主要信号、输出信号是由某个时钟沿驱动 flip-flop 产生的。&lt;em&gt;同步电路可以很好的避免毛刺。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Synchronous V.S. Asynchronous&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从 ASIC 设计的角度来看，大约需要 7 个门来实现一个 D 触发器，而一个门即可实现一个2输入与非门，所以一般来说，在 ASIC 设计中，同步时序电路比异步电路占用更大的面积。但是，由于 FPGA 是定制好的底层单元，对于 Xilinx 器件，一个底层可编程单元 Slice 包含两个触发器（FF）和一个查找表（LUT）。其中触发器用以实现同步电路，查找表用以实现组合电路。FPGA 最终使用率用 Slice 来衡量。所以对于某个选定器件，其可实现的同步电路和异步电路的资源数量和比例是固定的，这点造成了过度使用查找表会浪费触发器资源，反之亦然。因而对于 FPGA，同步时序设计不一定比异步设计多消耗资源。单从节约资源的角度考虑，应该按照芯片配置的资源比例实现设计，但是设计者还要时刻权衡同步设计没有毛刺、信号稳定等优点，&lt;strong&gt;所以对于 FPGA 设计推荐采用同步设计。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是用离散逻辑、可编程逻辑，还是用全定制硅器件实现的任何数字逻辑，为了成功操作，可靠的时钟是非常关键的。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为，FPGA 同步设计中最好的时钟解决方案是由专用全局时钟输入引脚驱动单个主时钟去控制设计项目中的每一个触发器。系统中各个功能模块使用同一同步复位信号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FPGA 同步设计中，时序电路应尽量采用同步电路，尽可能使用同步器件，尽量减小或不使用门控时钟（为了降低系统功耗以外）。设计中不用西哦他能够时钟经过逻辑运算得到控制信号，避免使用非时钟信号最为触发器的时钟输入。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面提到的所有方法，就是同步化思想的应用，其核心目的就是将本时钟域外的 &lt;strong&gt;异步信号同步化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="solution"&gt;Solution&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id="synchronizer"&gt;Synchronizer&lt;/h3&gt;
&lt;p&gt;通常使用 &lt;code&gt;MTBF (Mean Time Between Failures)&lt;/code&gt; 来描述 flip-flop 亚稳态指标，MTBF 越大，表示出现故障的间隔越大，表示设计越可靠。&lt;/p&gt;
&lt;p&gt;以一个典型的 0.25 us 工艺的 ASIC 库中的 flip-flop 的参数计算可以得到 MTBF = 2.01 d，即两天就会出现一次亚稳态。显然这是不能接受的，但是如果将两个 flip-flop 级联在一起，计算结果则变成了 9.57×109 years，显然这个概率基本就可以忽略不计，可以看作是消除了亚稳态。&lt;/p&gt;
&lt;p&gt;理论上，亚稳态是不可能完全消除的，一般级联多少个 flip-flop，由实际指标要求和设计者的强迫症习惯决定，对于普通的应用来说，2 级 flip-flop 级联已经足够了。&lt;/p&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="synchronizer" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronizer.png" /&gt;&lt;/p&gt;
&lt;p&gt;通常，同步器 synchronizer 由两个 flip-flop 串联而成，它们中间没有其他的组合电路。第一个 flip-flop 有很大的可能性会产生亚稳态，但是当第二个 flip-flop 获得前一个 flip-flop 的输出时，前一个 flip-flop 已经退出了亚稳态，并且输出稳定，这样就避免了第一级 flip-flop 的亚稳态对下一级逻辑造成的影响。&lt;/p&gt;
&lt;p&gt;为了让 synchronizer 正常工作，从某个 时钟域传递过来的信号应该先通过原时钟域的一个 flip-flop，然后不经过两个时钟域间的任何组合逻辑，直接进入 synchronizer。之所以这样要求，是因为 synchronizer 的第一级 flip-flop 对组合逻辑产生的毛刺非常敏感，如果一个足够长的信号毛刺正好满足 setup/hold time 的要求，那么它就会通过 synchronizer，给新时钟域后续逻辑一个虚假的信号。&lt;/p&gt;
&lt;p&gt;synchronizer 有很多设计方法，因为一种方法不能满足所有的应用需求。synchronizer 的类型基本上分为 3 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;level synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;edge-detecting synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pulse synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面分别讨论：&lt;/p&gt;
&lt;h4 id="level-synchronizer"&gt;level synchronizer&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电平同步器的结构图就是前面的图，在 Clifford E. Cummings 的 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;paper&lt;/a&gt; 中有更详细的图解说明：&lt;/p&gt;
&lt;p&gt;&lt;img alt="level" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/level.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;LVLSYNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// input&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// output&lt;/span&gt;
    &lt;span class="n"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// output attribute&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;din_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;dout_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// reg the din using orign clock&lt;/span&gt;
    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;din_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;din_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;// using two level DFF to synchronize the din_q&lt;/span&gt;
    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dout_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="level rtl" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/level_rtl.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 level synchronizer 的要求是：跨域时钟域的这个信号持续时间 &amp;gt;= 2 个新时钟域时钟周期。&lt;/p&gt;
&lt;p&gt;之所以这样要求是因为：synchronizer 要花费两个时钟周期来同步这个异步信号，如果这个信号长度短于两个时钟周期，则不能正常工作。&lt;/p&gt;
&lt;p&gt;level synchronizer 是其他两种同步器的核心。&lt;/p&gt;
&lt;h4 id="edge-detecting-synchronizer"&gt;edge-detecting synchronizer&lt;/h4&gt;
&lt;p&gt;边沿检测同步器 是在 level synchronizer 的输出端增加了一个 flip-flop，如下图所示。这个电路的功能是实现上升沿检测，产生一个和时钟周期等宽，高电平有效的脉冲；如果将与门的两个输入端交换，则会完成下降沿检测。如果改为非门，则可以得到一个低电平脉冲有效的电路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="edge-detecting" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/edge-detecting.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;EDGESYNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// input&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// output&lt;/span&gt;
    &lt;span class="n"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;din_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;dout_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;dout_qr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;dout_qrr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// reg the din using orign clock&lt;/span&gt;
    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;din_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;din_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;// using two level DFF to synchronize the din_q&lt;/span&gt;
    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout_qr&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout_qrr&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout_q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout_qr&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dout_q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dout_qrr&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dout_qr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

    &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dout_qrr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;dout_qr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="edge rtl" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/edge_rtl.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 edge-detecting synchronizer 的要求是：输入信号的宽度 &amp;gt;= 同步时钟周期 + 第一个 flip-flop 的 hold time。最保险的脉冲宽度是同步周期的两倍。&lt;/p&gt;
&lt;p&gt;edge-detecting synchronizer 在将一个慢时钟域的信号同步到一个较快时钟域时可以正常工作，它会产生一个脉冲表示输入信号的上升沿或者下降沿。但是反过来，将一个快时钟域的信号同步到慢时钟域时，并不能正常工作，这时候需要使用 pusle synchronizer。&lt;/p&gt;
&lt;h4 id="pulse-synchronizer"&gt;pulse synchronizer&lt;/h4&gt;
&lt;p&gt;脉冲同步器的基本功能是从某个时钟域中取出一个单时钟宽度的脉冲，然后在新的时钟域中建立另外一个单时钟宽度的脉冲。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="pusle" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/pulse.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 pusle synchronizer 的要求是：输入脉冲之间的最小间隔 &amp;gt;= 2 个同步时钟周期。&lt;/p&gt;
&lt;p&gt;如果两个输入脉冲相互过近，则新时钟域的输出脉冲也会紧密相邻。&lt;/p&gt;
&lt;h4 id="summary"&gt;Summary&lt;/h4&gt;
&lt;p&gt;总结 3 种同步器的特点，有下表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="synchronizer sum" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronizer_sum.png" /&gt;&lt;/p&gt;
&lt;p&gt;经过 synchronizer 的信号在两个时钟之后变为有效，一般延时为 1～2 新时钟周期，可以粗略估计延时为 2 个时钟周期，设计者需要仔细考虑同步延迟对于跨时钟域的信号时序造成的影响。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在许多应用中，跨时钟域传送的不只是简单的信号，数据总线、地址总线、控制总线都会同时跨域传输，这时候通常采用其他的方法，比如握手协议和 FIFO 等。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="handshaking"&gt;Handshaking&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Handshaking allows digital circuits to effectively communicate with each other when the response time of one or both circuits is unpredictable. For example, an arbitrated bus allows more than one circuit to request access to a single bus, such as PCI or AMBA (Advanced Microcontroller Bus Architecture), using arbitration to determine which circuit gains access to the bus. Each circuit signals a request, and the arbitration logic determines which request “wins.” This winning circuit receives an acknowledgment indicating that it has access to the bus. It then discontinues its request and begins the bus transaction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有两种基本握手协议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Full-handshaking&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Partial-handshaking&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种握手协议都要用到 synchronizer，每种都有各自的优缺点，下面分别讨论：&lt;/p&gt;
&lt;h4 id="full-handshaking"&gt;full handshaking&lt;/h4&gt;
&lt;p&gt;&lt;img alt="full" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/full.png" /&gt;&lt;/p&gt;
&lt;p&gt;如图所示，全握手协议中，双方电路在声明或中止各自的握手信号前都要等待对方的相应。首先，发送方电路A声明它的请求信号，然后接收方电路B检测到该请求有效后，声明它的效应信号；当电路A检测到响应信号有效之后，中止自己的请求信号；最后，当电路B检测到请求无效之后，中止自己的相应信号。这样，算是完成了一次通信。除非A检测到无效的响应信号，否则它不会再声明新的请求信号。这种机制要求请求电路A必须延迟它的下一个请求，直到它检测到无效的响应信号（意味着上次请求已完成）。&lt;/p&gt;
&lt;p&gt;这种类型的握手使用了 level synchronizer。可以根据两点来粗略估计这个协议的时序：信号跨域一个时钟域需要花费 2 个时钟周期，信号在跨域时钟域之前被电路寄存花费 1 个时钟周期。所以，发送端A需要 5 个周期，接收端B需要 6 个周期。&lt;/p&gt;
&lt;p&gt;全握手很强健，因为通过检测请求和响应信号，每个电路都清楚地知道对方的状态，这种方式的不足之处是完成整个过程要花费很多时钟周期。&lt;/p&gt;
&lt;h4 id="partial-handshaking"&gt;partial handshaking&lt;/h4&gt;
&lt;p&gt;另一中类型是部分握手。部分握手的双方不用等对方的响应就中止各自的信号，并继续执行握手命令序列。&lt;/p&gt;
&lt;p&gt;部分握手比全握手在健壮性方面稍弱，因为握手信号并不指示各自电路的状态，每一电路都必须保存状态信息（在全握手里这个信息被送出去），但是，由于无需等待对方的响应，完整的时间序列花费较少的时间。&lt;/p&gt;
&lt;p&gt;有两种类型的部分握手：&lt;/p&gt;
&lt;p&gt;第一种握手方法中，电路A以有效电平声明其请求信号，电路B以一个单时钟宽度脉冲作为响应。此时，电路B并不关心电路A何时中止它的请求。&lt;/p&gt;
&lt;p&gt;&lt;img alt="partial-1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partial_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;但是为了这种方法成立，电路A中止请求信号至少要 1 个时钟周期长度，否则，电路B就不能区别前一个和后一个新的请求。&lt;/p&gt;
&lt;p&gt;在这种握手方式下，电路B为请求信号使用一个 level synchronizer；电路A为响应信号使用一个 pusle synchronizer。只有当电路B检测到请求信号时才发出响应脉冲，这样电路A控制请求信号的时序，就能控制自己synchronizer接收到的脉冲间隔。&lt;/p&gt;
&lt;p&gt;同样，使用前面的方法可以估算出这种握手协议的时序：发送端电路A需要花费 3 个时钟周期，接收端B需要花费 5 个时钟周期。&lt;/p&gt;
&lt;p&gt;第二种握手方法中，电路A使用一个单时钟宽度脉冲发出它的请求，电路B也以一个单时钟宽度脉冲响应这个请求。这种情况下，两个电路都需要保存状态，以指示请求正待处理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="partial-2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partial_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;这种握手使用的是 pusle synchronizer。完整的时序是：电路A需要花费 2 个时钟周期，电路B需要花费 3 个时钟周期。&lt;/p&gt;
&lt;h4 id="summary_1"&gt;summary&lt;/h4&gt;
&lt;p&gt;&lt;img alt="handshaing sum" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/handshaking_sum.png" /&gt;&lt;/p&gt;
&lt;p&gt;因为 handshaking 内部采用了 synchronizer，所以可以解决异步信号导致的亚稳态现象。根据实际要求，选择不同的 synchronizer 和握手信号，就有了前面介绍的 3 种不同的 handshaking：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;full handshaking
是最健壮的，因为在这种机制下，两部分电路都在等待收到对方的确认信号之后才发送新的握手信号，两部分电路是相互都知道对方目前所处于的状态，而且用了两组握手信号（request/acknowledge，de-request/de-acknowledge），相当于完成了两次握手。但是，最健壮的代价就是花费的时间最长，而且要求信号在收到对方的回复之前要保持不变，这就限制了发送信号的速率和节奏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial handshaking 是对 full 的精简，动机就是减少握手所花费的时间，从减少花费时间的方法上，就有了两种不同的 partial shandshaking。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial I 精简了 1 个握手信号 de-acknowledge，剩下了 3 个握手信号，相当于完成了1次半的握手。而且修改了 full 中 level synchronizer 的方式，接收电路 B 发送的不再是电平信号，而是一个单时钟宽度的脉冲，所以电路A则必须使用 pusle synchronizer 来检测来自 B 的握手信号。通过减少一个握手信号和改进一方的 synchronizer，partial I 就比 full 方式节约了很多时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial II 则更进一步，在 partial I 的基础上又精简掉一个握手信号，只剩下 2 个握手信号，只完成1次握手。而且两部分电路的 synchronizer 同时修改为 pusle 方式。这样子进一步减少了握手花费的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial 和 full 的本质区别不在于synchronizer 的类型和握手信号的多少，而在于握手的方式。 partial 不用再等待对方的回答，就继续进行自己的下一步操作，而 full 必须等到对方的回复才进行下一步的操作，所以从某种意义上，full 方式才是真正的“握手”，而 partial 并不符合 “握手” 的意思，毕竟根本不管对方的反应，自顾自地挥手叫哪门子的握手 =.=&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;这些握手协议针对的都是跨时钟域的单一信号，但当几组信号要跨越时钟域时，设计者就需要更加复杂的信号传递方法。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="datapath-design"&gt;Datapath Design&lt;/h3&gt;
&lt;p&gt;在进行信号同步时，有一个重要的原则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不应该在设计中的多个地方对同一信号进行同步，即禁止单个信号扇出至多个同步器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为synchronizer要花 1~2 个时钟周期，设计者不能确切预测到每个信号何时跨越时钟域，此外，在新时钟域中一组经过同步后的信号其时序是不定的，因为synchronier的延迟可以是 1～2 个时钟周期，这种情况下各个同步信号间形成一种“竞争状况”，这种竞争状况在需要跨域时钟域传输的多组信号间也会发生，例如数据总线、地址总线、控制总线等。因此，&lt;strong&gt;不能对组中的每个信号单独使用synchronizer，也不能对数据/地址总线的每一位单独使用同步器&lt;/strong&gt;，因为在新的时钟域中，要求每个信号同时有效。&lt;/p&gt;
&lt;h4 id="problem_1"&gt;problem&lt;/h4&gt;
&lt;p&gt;Clifford E. Cummings 在他的文章中举例说明了几种常见的错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A frequent mistake made by engineers when working on multi-clock designs is passing multiple control signals from one clock domain to another and overlooking the importance of the sequencing of the control signals. &lt;strong&gt;Simply using synchronizers on all control signals is not always good enough&lt;/strong&gt; as will be shown in the following examples. &lt;/p&gt;
&lt;p&gt;If the order or alignment of the control signals is significant, care must be taken to correctly pass the signals into the new clock domain. All of the examples shown in this section are overly simplistic but they closely mimic situations that often arise in real designs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem - Two simultaneously required control signals&lt;/strong&gt;
 a register in the new clock domain requires both a load signal and an
enable signal in order to load a data value into the register. If both the load and enable signals are being sent from one clock domain, there is a chance that a small skew between the control signals could cause the two signals to be synchronized into different clock cycles within the new clock domain. In this example, this would cause the data to the register to not be loaded.&lt;/p&gt;
&lt;p&gt;&lt;img alt="problem 1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/problem_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Solution - Consolidating control signals before passing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution 1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/solution_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem - Two phase-shifted sequencing control signals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The problem is that in the first clock domain, the aen1 control signal might terminate slightly before the aen2 control signal is asserted, and the second clock domain might try to sample the aen1 and aen2 control signals in the middle of this slight time gap, causing a one-cycle gap to form in the enable control-signal chain in the second clock domain. This would cause the a2 output signal to be missed by the second flip-flop.&lt;/p&gt;
&lt;p&gt;&lt;img alt="problem 2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/problem_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Solution - Logic to generate the proper sequencing signals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution 2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/solution_2.png" /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="solution_1"&gt;solution&lt;/h4&gt;
&lt;p&gt;有一种解决这个问题的方法是：&lt;strong&gt;使用一个保持寄存器 + 一个握手信号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/datapath.png" /&gt;&lt;/p&gt;
&lt;p&gt;保持寄存器保持信号总线的数据，握手信号指示目标时钟域何时可以对总线进行采样，源时钟域何时可以更换当前寄存器中保存的内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In this design, the transmitting circuit stores the data (signal bus) in the holding register as it asserts the request signal. These two actions can happen at once because the request signal takes at least one clock cycle before the receiving circuit detects it (the minimum handshake-synchronization delay). When the receiving circuit samples the data (signal bus), it asserts the acknowledgment signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细分析一下，其实这里采用的原理类似于握手协议。&lt;/p&gt;
&lt;p&gt;当有一组新的数据出现在数据总线上需要跨时钟域时，额外添加一对握手信号 request/acknowledge，这对信号对于两个时钟域来说分别是异步信号（接收电路不知道何时会收到request，发送电路也不知道何时会获得acknowledge），可能会产生亚稳态的问题，所以在两个时钟域对它们分别用 synchronizer 进行同步。&lt;/p&gt;
&lt;p&gt;和request一起送过来的还有数据总线 上的数据信号，但是对于数据信号，不能简单地对每一位使用 synchronizer 来同步（原因前面已经说过了）。虽然对于接收电路来说，数据总线上的数据也是异步的，但是我们可以强制要求在握手过程中，数据保持不变，这样虽然数据是异步的，只要发送端满足保持寄存器数据在握手过程中不变化这一条件，那么即使数据总线上的数据到达接收时钟域有一些小的偏差 skew，但是不会超出 1 个时钟周期，在 synchronizer 最好的状态下，只花费了 1 个时钟周期就同步到了握手请求request，这时候数据总线上的数据已经是稳定不变的有效数据了，所以可以采样到正确的有效数据，不会存在亚稳态的问题。&lt;/p&gt;
&lt;p&gt;采用这种方法可以避免亚稳态的出现的原因就是它规定了异步信号（保持寄存器）什么时候可以变化，虽然是异步信号，但是在采样的时候人为地确保了它保持稳定，满足 setup/hold time 的要求，所以不会有亚稳态的问题。&lt;/p&gt;
&lt;p&gt;这里的握手机制可以采用 full handshaking，也可以采用 partial handshaking，设计者应该根据实际需求来选择。&lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt; 这本书中，有详细的时序图来说明了一种握手机制下，这种机制采用了 full handshaking 中等待对方的方法，但是对握手信号进行了精简（partial II 类型）。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="datapath timing" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/datapath_timing.png" /&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;如果发送端的数据速率很快/无法控制发送端发送数据的速度，那么就有可能无法满足握手机制中要求数据保持稳定这一要求，这时候这种方法就不再适用，而应该采用其他的方法，比如 FIFO。&lt;/p&gt;
&lt;h3 id="advanced-datapath-design"&gt;Advanced Datapath Design&lt;/h3&gt;
&lt;p&gt;有时候，数据在跨时钟域时需要“堆积”起来，这时候只使用单个的寄存器就无法完成工作。比如某个传输电路突发式地发送数据，接收电路来不及采样，为了保持数据不丢失，就必须先把数据存储起来；还有一种情况是接收电路的采样速率比发送速度快，但是位宽却不够，仍然需要将没有采样的数据先暂存起来，这时候就需要使用 FIFO。&lt;/p&gt;
&lt;p&gt;基本上，使用 FIFO 的目的有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;速度匹配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宽度匹配&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;FIFO 的实现可以直接使用 IP core，也可以自己写代码实现。&lt;/p&gt;
&lt;p&gt;如果是自己写代码实现，那么异步信号的问题还是需要我们在实现 FIFO 是仔细考虑的；如果是采用 IP core 的方式，那么可以很大程度地缓解我们的压力，因为事实上我们是把异步信号的问题交给了设计 IP core 的人来处理...这些 IP core 在内部针对异步数据读写的问题作了非常严谨复杂的设计，对外提供了非常简单的接口。采用这种方式虽然轻松，但是相应的地也有缺点：耗费更多的资源。&lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt; 和 &lt;a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf"&gt;Crossing the abyss: asynchronous signals in a synchronous world&lt;/a&gt; 两篇 paper 和 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art&lt;/a&gt; 中都有一些实现 FIFO 使用的相关技术的介绍，比如指针逻辑的处理，内部 gray code 计数器的实现等。这里就偷懒不细说了（以后再补） :P&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关于跨时钟域 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;papaer1&lt;/a&gt; 中还有一些其他方面的技巧，可以帮助我们更好的实现设计。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="desing-partitioning"&gt;Desing Partitioning&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Only allow one clock per module.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Static timing analysis and creating synthesis scripts is more easily accomplished on single-clock modules or groups of single-clock modules.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Create a synchronizer module for each set of signals that pass from just one clock domain into another clock domain.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;It is given that any signal passing from one clock domain to another clock domain is going to have setup and hold time problems. No worst-case (max time) timing analysis is required for synchronizer modules. Only best case (min time) timing analysis is required between first and second stage flip-flops to ensure that all hold times are met. Also, gate-level simulations can more easily be configured to ignore setup and hold time violations on the first stage of each synchronizer.&lt;/p&gt;
&lt;p&gt;采用这种设计方式的原因如上所示，可以减少不必要的时序验证，而且脚本也更容易写，总之可以使时序验证工作更容易。&lt;/p&gt;
&lt;p&gt;举例如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="partitioning" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partitioning.png" /&gt;&lt;/p&gt;
&lt;h3 id="clock-name-conventions"&gt;Clock Name Conventions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Use a clock naming convention to identify the clock source of every signal in a design.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A naming convention helps all team members to identify the clock domain for every signal in a design and also makes grouping of signals for timing analysis easier to do using regular expression "wild-carding" from within a synthesis script.&lt;/p&gt;
&lt;p&gt;作者还举例说明了一个这样的例子：1995 年为 In Focus projectors 设计 video ASIC 时，他们就采用了这样的方法，对于 mircroprocessor 的时钟命名为 uClk，对于 video 的时钟则命名为 vClk。对应的时钟域中的信号的名字也添加了对应的前缀，比如udata，uwrite，uadder等。&lt;/p&gt;
&lt;p&gt;使用了这样的策略后，整个设计团队的攻城狮们都可以很方便地确定某个信号是否为异步信号，如何处理。当时有个攻城狮没有按照这种策略，使用了自己的命名方式，在一次会议之后，大家墙裂建议他修改命名，结果也证明修改之后遇到的问题、出错的概率都小了很多。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="summary_2"&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;以上，就是一些在多时钟域设计中处理异步数据的常用方法，总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于普通的单比特的数据，根据实际情况选择对应的 synchronizer 即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于其他的信号，比如数据总线、地址总线、控制总线等数据，可以使用握手协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总线上的数据要求同时到达新的时钟域，所以不要对总线上的信号分别进行同步，而要采用一个保持寄存器 + 握手信号的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还可以采用 FIFO 来处理异步数据的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分块设计，尽可能保证一个模块只有一个时钟域，对于跨时钟域信号，写独立的同步模块，这样可以减轻时序验证的工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用良好的命名习惯，如前缀的方式，可以帮助设计。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf"&gt;Crossing the abyss: asynchronous signals in a synchronous world&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA高手设计实战真经100则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG_ARTICLE_174906.HTM"&gt;ASIC中的异步时序设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG_ARTICLE_175526.HTM"&gt;跨越鸿沟：同步世界中的异步信号&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.altera.com.hk/literature/wp/wp-01082-quartus-ii-metastability.pdf"&gt;Understanding Metastability in FPGAs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="clock design"></category></entry><entry><title>锁存器 Latch v.s. 触发器 Flip-Flop</title><link href="http://guqian110.github.io/pages/2014/09/23/latch_versus_flip_flop.html" rel="alternate"></link><updated>2014-09-23T23:02:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-09-23:pages/2014/09/23/latch_versus_flip_flop.html</id><summary type="html">&lt;p&gt;根据 &lt;a href="http://en.wikipedia.org/wiki/Flip-flop_(electronics"&gt;Wiki: Flip-flop (electronics)&lt;/a&gt; 上的介绍&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In electronics, a &lt;code&gt;flip-flop&lt;/code&gt; or &lt;code&gt;latch&lt;/code&gt; is a circuit that has two stable states and can be used to store state information. A flip-flop is a &lt;code&gt;bistable multivibrator&lt;/code&gt;. The circuit can be made to change state by signals applied to one or more control inputs and will have one or two outputs. It is the basic storage element in sequential logic. Flip-flops and latches are a fundamental building block of digital electronics systems used in computers, communications, and many other types of systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区别一下名字：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flip-flops can be either simple (transparent or opaque) or clocked (synchronous or edge-triggered). Although the term flip-flop has historically referred generically to both simple and clocked circuits, in modern usage it is common to reserve the term flip-flop exclusively for discussing clocked circuits; the simple ones are commonly called latches.&lt;/p&gt;
&lt;p&gt;Using this terminology, a latch is level-sensitive, whereas a flip-flop is edge-sensitive. That is, when a latch is enabled it becomes transparent, while a flip flop's output only changes on a single type (positive going or negative going) of clock edge.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以按照现在的约定习惯区分，latch 指的是电平触发的触发器，翻译为 “锁存器”；flip-flop 指边沿触发的触发器，就叫 “触发器”。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="history"&gt;History&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;翻译自 &lt;a href="http://en.wikipedia.org/wiki/Flip-flop_(electronics"&gt;wiki&lt;/a&gt;:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;第一个电子触发器(electronic flip-flop) 由  William Eccles 和 F. W. Jordan 于 1918 年发明的。它最早被称为 ：  &lt;code&gt;Eccles–Jordan trigger circuit&lt;/code&gt;，由两个真空管组成。虽然现在由逻辑门 (logic gates)组成的触发器很常见，但是在集成电路(intergrated circuits)中，这种元件及它的晶体管版本仍然也很常见。早期的触发器常用来构成触发电路或者多谐振荡器(multivibrators)。&lt;/p&gt;
&lt;p&gt;&lt;img alt="flip-flop" src="http://upload.wikimedia.org/wikipedia/commons/9/98/Eccles-Jordan_trigger_circuit_flip-flip_drawings.png" /&gt;&lt;/p&gt;
&lt;p&gt;根据一个 JPL 的工程师，P. L. Lindley介绍，Montgomery Phister 于 1954 年在 UCLA 的 computer design 的课程上第一次对触发器进行了分类的讨论（RS、D、T、JK），然后在他的书 Logical Design of Digital Computers 中也进行了讨论。Lindley 当时在 Hughes Aircraft 的 Eldred Nelson 手下工作，而Nelson 命名了 JK 触发器。其他的名字则是 Phister 命名的。Lindley 解释说他是从 Nelson 口中得知 JK 触发器的故事的，当时 Hughes Aircraft 使用的触发器都是 JK 触发器。在设计逻辑系统时，Nelson 给触发器的输入命名为 A&amp;amp;B、C&amp;amp;D、E&amp;amp;F、G&amp;amp;H、J&amp;amp;K。在 1953 年 Nelson 申请专利时，采用了 J&amp;amp;K 的命名方案。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="implementation"&gt;Implementation&lt;/h2&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Flip-flops can be either simple (transparent or asynchronous) or clocked (synchronous); the transparent ones are commonly called latches. The word latch is mainly used for storage elements, while clocked devices are described as flip-flops.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不会翻译了...大意就是说 flip-flop 可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;simple&lt;/p&gt;
&lt;p&gt;也可以说是 透明的(transparent) 或者是 异步的(asynchronous)，通常称为 &lt;code&gt;锁存器Latch&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;clocked&lt;/p&gt;
&lt;p&gt;也可以说是 同步的(synchronous)，称为 &lt;code&gt;触发器flip-flop&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分类讨论：&lt;/p&gt;
&lt;h3 id="latch"&gt;Latch&lt;/h3&gt;
&lt;p&gt;Latch 可以由一对真空管、三极管、场效应管组成，在实际应用中也可以用逻辑门组成 latch。&lt;/p&gt;
&lt;h4 id="sr-latch"&gt;SR Latch&lt;/h4&gt;
&lt;p&gt;当使用逻辑门搭建模块时，最基本的 latch 就是 &lt;code&gt;SR latch&lt;/code&gt; (set-reset latch)，所有的 latch 和 flip-flop 都是建立在它的基础之上。&lt;/p&gt;
&lt;p&gt;SR latch 的实现可以有两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SR NOR Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用或非门搭建：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor" src="http://upload.wikimedia.org/wikipedia/commons/c/c6/R-S_mk2.gif" /&gt;&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor" src="/images/latch_versus_flip_flop/nor.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;S'R' NAND Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用与非门搭建：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand" src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/92/SR_Flip-flop_Diagram.svg/500px-SR_Flip-flop_Diagram.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand" src="/images/latch_versus_flip_flop/nand.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="d-latch"&gt;D Latch&lt;/h4&gt;
&lt;p&gt;Latch 是 &lt;code&gt;透明的(transparent)&lt;/code&gt;，就是说输入的变换立即就能传递到输出端口，当几个透明的 latch 级联时，输入端的信号也能立即传递到输出端。当给 latch 添加额外的逻辑电路（比如使能信号 enable 无效时），就会使它变为 &lt;code&gt;不透明的(non-transparent)&lt;/code&gt;。下面的 D latch 就是这样的例子。&lt;/p&gt;
&lt;p&gt;仔细观察 SR latch 的功能表，就可以发现，R 的取值为 S 的补。D latch 利用了这一特点，而且避免了 SR latch 中的禁止状态的出现。&lt;/p&gt;
&lt;p&gt;因为 SR latch 的实现有两种，所以 &lt;code&gt;D latch&lt;/code&gt; 的实现也对应有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NOR D Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor d latch" src="http://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/D-type_Transparent_Latch_%28NOR%29.svg/500px-D-type_Transparent_Latch_%28NOR%29.svg.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NAND D Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand d latch" src="http://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/D-Type_Transparent_Latch.svg/500px-D-Type_Transparent_Latch.svg.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;D latch 的功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="d latch" src="/images/latch_versus_flip_flop/d_latch.png" /&gt;&lt;/p&gt;
&lt;p&gt;D latch 也称为  non-transparent、data latch、gated latch。它有一个数据输入端和一个使能端 enable(clock、control)。之所以叫透明，是因为当它使能时，输入端口的信号立刻就能传递到输出端口。&lt;/p&gt;
&lt;h3 id="flip-flop"&gt;Flip-Flop&lt;/h3&gt;
&lt;p&gt;如果 D latch 的控制端口加入时钟信号，就得到了基本触发器，只要时钟信号 CP = 1，则触发器就会受到触发，当 CP 保持为 1 时，数据输入端口的任何变化都将影响到 latch 的状态。&lt;/p&gt;
&lt;p&gt;latch 的这个特点应用到 时序电路中，就会出现比较严重的问题：&lt;/p&gt;
&lt;p&gt;一般时序逻辑的输出会经过组合电路的反馈通道，返回到时序逻辑的输入。当时钟信号有效时，latch 的输出通过组合电路反馈到 latch 的输入端，如果经过组合逻辑后，反馈的信号和之前的信号不同，则反馈信号会导致 latch 的输出变为新的值。在时钟信号有效的期间内，latch 的输出一直在变化，出现了不可预测的结果，这是不可靠的工作。&lt;/p&gt;
&lt;p&gt;latch 的&lt;strong&gt;问题&lt;/strong&gt;就在于：&lt;em&gt;它在时钟有效期间内一直在被触发，这种触发时间过长。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个问题的&lt;strong&gt;解决方法&lt;/strong&gt;就是：&lt;em&gt;将触发条件变为时钟沿触发，这样就得到了触发器 &lt;code&gt;flip-flop&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="d-flip-flop"&gt;D flip-flop&lt;/h4&gt;
&lt;p&gt;将 latch 改造为边沿敏感的触发器，最简单的就是 &lt;code&gt;D flip-flop&lt;/code&gt; (data or delay)，搭建电路最经济有效的方法就是使用 DFF，因为它需要的门电路最少，其他类型的触发器都是在 DFF 的基础上得到的。&lt;/p&gt;
&lt;p&gt;实现 DFF 可以有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Classical positive-edge-triggered D flip-flop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="classical" src="http://upload.wikimedia.org/wikipedia/en/thumb/9/99/Edge_triggered_D_flip_flop.svg/500px-Edge_triggered_D_flip_flop.svg.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Master–slave edge-triggered D flip-flop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="master-slave" src="http://upload.wikimedia.org/wikipedia/en/thumb/5/52/Negative-edge_triggered_master_slave_D_flip-flop.svg/500px-Negative-edge_triggered_master_slave_D_flip-flop.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;clk = 1 时，master D-latch 使能，D 传递到输出端 Q；&lt;/p&gt;
&lt;p&gt;clk = 0 时，slave D-latch 使能，输入 D (master D-latch 的输出 Q) 传递到输出 Q；&lt;/p&gt;
&lt;p&gt;可以看到，当 clk 从 1 变为 0 时，输入端的 D 才传递到输出端 Q，也就是说在时钟的下降沿才触发，其他时刻都保持输出不变。（如果需要上升沿触发，只需要在 clk 输入端键入一个反相器）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DFF 的特点就是在时钟信号的特定点触发（上升沿 or 下降沿），功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="dff" src="/images/latch_versus_flip_flop/dff.png" /&gt;&lt;/p&gt;
&lt;h4 id="jk-flip-flop"&gt;JK flip-flop&lt;/h4&gt;
&lt;p&gt;在 DFF 的基础上，可以得到 JK FF。&lt;/p&gt;
&lt;p&gt;JK FF 的特点和 SR latch 类似，可以将 J 看作是 S，K 看作是 R，它和 SR latch 的区别在于它是边沿触发，并且将 S = R = 1 状态设置为 &lt;code&gt;翻转 (toggle)&lt;/code&gt;，也就是在下一个时钟边沿，输出取反。当 J = K = 0 时，得到的并不是 DFF，而是保持输出不变。&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="jk" src="/images/latch_versus_flip_flop/jk.png" /&gt;&lt;/p&gt;
&lt;h4 id="t-flip-flop"&gt;T flip-flop&lt;/h4&gt;
&lt;p&gt;将 JK FF 的输入端 J 和 K 连接到一起，就可以得到 &lt;code&gt;T FF&lt;/code&gt; (toggle flip-flop)。&lt;/p&gt;
&lt;p&gt;当 T = 0 (J = K = 0) 时，输出保持不变，时钟边沿不影响状态；当 T = 1 (J = K = 1) 时，在时钟边沿输出反相，也就是翻转。&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="tff" src="/images/latch_versus_flip_flop/tff.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到 TFF 有 1/2 分频的作用，这一特点在很多电路中得到了应用。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="timing-considerations"&gt;Timing considerations&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id="metastability"&gt;Metastability&lt;/h3&gt;
&lt;p&gt;伴随着 flip-flop 的一个问题是 &lt;code&gt;亚稳态 Metastability&lt;/code&gt;。当两个输入端口 (比如 data 和 clk，或者 reset 和 clk)同时变化时，就会发生亚稳态的问题，需要消耗更长的时间来使输出达到稳定状态，而且这个稳定状态是不可预测的，有可能是 1，也有可能是 0。&lt;/p&gt;
&lt;p&gt;在计算机系统中，如果发生亚稳态，如果在下一个时钟使用数据时，还没有达到稳定状态，会导致数据传输错误或者程序崩溃。如果有两条路径同时用到了这个数据，有可能一条将它当作 1，另一条把它当作 0，这样会导致系统进入不一致的状态。&lt;/p&gt;
&lt;h3 id="setup-hold-recovery-removal-times"&gt;Setup, hold, recovery, removal times&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Setup time&lt;/strong&gt; is the minimum amount of time the data signal should be held steady &lt;strong&gt;before&lt;/strong&gt; the clock event so that the data are reliably sampled by the clock. This applies to synchronous input signals to the flip-flop.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hold time&lt;/strong&gt; is the minimum amount of time the data signal should be held steady &lt;strong&gt;after&lt;/strong&gt; the clock event so that the data are reliably sampled. This applies to synchronous input signals to the flip-flop.&lt;/p&gt;
&lt;p&gt;Synchronous signals (like Data) should be held steady from the set-up time to the hold time, where both times are relative to the clock signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="meta" src="http://upload.wikimedia.org/wikipedia/en/thumb/d/d9/FF_Tsetup_Thold_Toutput.svg/500px-FF_Tsetup_Thold_Toutput.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;如图所示，对于同步信号 (同步信号的意思是想对于时钟信号而言，它的变化和时钟是同步的，比如 data)，必须满足 &lt;code&gt;setup time&lt;/code&gt; 和 &lt;code&gt;hold time&lt;/code&gt; 要求。&lt;/p&gt;
&lt;p&gt;在有效时钟沿到来之前的 setup time 时间段内，同步信号必须保持稳定，在有效时钟沿到来之后的 hold time 时间段内，同步信号也必须保持稳定，也就是说从 setup time 到 hold time 之间，它必须保持稳定不变化，这样才能让时钟信号采样到正确的值。&lt;/p&gt;
&lt;p&gt;同理，对于异步信号，有类似的要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Recovery time&lt;/strong&gt; is like setup time for asynchronous ports (set, reset). It is the time available between the asynchronous signals going inactive and the active clock edge.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Removal time&lt;/strong&gt; is like hold time for asynchronous ports (set, reset). It is the time between active clock edge and asynchronous signal going inactive.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;找到一个更清晰的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Recovery time&lt;/strong&gt; is the minimum length of time an asynchronous control signal, for example, and preset, must be stable &lt;strong&gt;before&lt;/strong&gt; the next active clock edge. The recovery slack time calculation is similar to the clock setup slack time calculation, but it applies asynchronous control signals.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Removal time&lt;/strong&gt; is the minimum length of time an asynchronous control signal must be stable &lt;strong&gt;after&lt;/strong&gt; the active clock edge. The TimeQuest analyzer removal time slack calculation is similar to the clock hold slack calculation, but it applies asynchronous control signals.&lt;/p&gt;
&lt;p&gt;recovery time specifies the time the inactive edge of the asynchronous signal has to arrive before the closing edge of the clock.&lt;/p&gt;
&lt;p&gt;Removal time specifies the length of time the active phase of the asynchronous signal has to be held after the closing edge of the clock.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 Recovery / Removal time 类似于 Setup / Hold Time，不过是用于异步信号，比如 set，reset 信号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="recovery-removal" src="/images/latch_versus_flip_flop/recovery-removal.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;如图所示，在时钟沿到来之前的 recovery time 之前，异步信号必须释放 (变无效)，在时钟沿到来之后的 removal time 之后，异步信号才能变有效，也就是说在从 recovery time 到 removal time 这段时间内，异步信号是不能有效的。&lt;/p&gt;
&lt;p&gt;如果使 flip-flop 的输入满足 setup time 和 hold time，那么就可以避免亚稳态的出现，一般器件的手册上都会标明这些参数，从几 ns 到几百 ps 之间。根据 flip-flop 内的组织情况而定，有时候可以将 setup time 或者 hold time 两者中的一个（只能是其中之一）变为 0 甚至是负数。&lt;/p&gt;
&lt;p&gt;但是，并不是总能满足这一标准，因为有可能 flip-flop 的输入端连到了外界的，设计者无法控制的一个不断变化的信号，这时候设计者所能做的事就是根据电路要求，将发生错误的概率降低到一个确定的水平。通常使用的方法就是将信号通过一条链在一起的 flip-flop 组，这样子可以将发生亚稳态的概率降低到一个可以忽略的程度，但是还是不等于 0。链中的 flip-flop 越多，这个概率就越趋近于 0，通常的情况是采用 1 个或者两个 flip-flop。&lt;/p&gt;
&lt;p&gt;即使现在出现了所谓的 &lt;code&gt;metastable-hardened flip-flops&lt;/code&gt;，它可以尽可能地减小 setup time 和 hold time，但是仍然无法完全避免问题的出现。&lt;strong&gt;这是因为亚稳态并不是简单的设计方法上的问题。&lt;/strong&gt;当时钟信号和其他信号在相隔很近的时间内变化，flip-flop 必须判断哪一个先发生变化，哪一个后发生变化，无论我们的器件速度有多快，仍然有可能出现两者相隔的太近，以至于无法判断。所以理论上是不可能造出一个完美避免亚稳态的 flip-flop。&lt;/p&gt;
&lt;h3 id="propagation-delay"&gt;Propagation delay&lt;/h3&gt;
&lt;p&gt;flip-flop 还有一个参数叫做 clock-to-output delay (common symbol in data sheets: &lt;code&gt;tco&lt;/code&gt;) 或者是 propagation delay (&lt;code&gt;tp&lt;/code&gt;)，表示的是 flip-flop 从有效时钟沿开始到输出发生变化所消耗的时间。有时候从高电平变为低电平的时间 (high-to-low transition, tPHL))和从低电平变为高电平的时间 (low-to-high transition, tPLH) 不相等。&lt;/p&gt;
&lt;p&gt;当用同一时钟来驱动级联的 flip-flop (比如移位寄存器 shift register)时，必须保证前一级的 tco 要大于后一级的 th。这是因为必须要保证前一级的数据能够正确移位到后一级中。当有效时钟沿到来时，前后两级的 ff 在同时变化，采样前一级的输出作为本级的输入，然后经过 tco 输出更新的值。当后一级 ff 在 tsu 到 th 段内采样时，必须保证前一级的输出保持不变，也就是说前一级 ff 的响应速度不能太快，至少要等后一级正确采样完成之后才能变化，即 &lt;code&gt;tco &amp;gt; th&lt;/code&gt;。如果采用物理构造完全相同的 ff，那么通常是可以保证这一条件的。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="in-fpga"&gt;in FPGA&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;latch 和 flip-flop 的特点决定了它们各自的应用场景&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;latch 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;面积比 ff 小&lt;/p&gt;
&lt;p&gt;门电路是构建组合逻辑电路的基础，而锁存器和触发器是构建时序逻辑电路的基础。门电路是由晶体管构成的，锁存器是由门电路构成的，而触发器是由锁存器构成的。也就是 晶体管-&amp;gt;门电路-&amp;gt;锁存器-&amp;gt;触发器，前一级是后一级的基础。latch完成同一个功能所需要的门较触发器要少，所以在asic中用的较多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;速度比 ff 快&lt;/p&gt;
&lt;p&gt;用在地址锁存是很合适的，不过一定要保证所有的latch信号源的质量，锁存器在CPU设计中很常见，正是由于它的应用使得CPU的速度比外部IO部件逻辑快许多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;latch 的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;电平触发，非同步设计，受布线延迟影响较大，很难保证输出没有毛刺产生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;latch将静态时序分析变得极为复杂&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;flip-flop 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;边沿触发，同步设计，不容易受毛刺的印象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序分析简单&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;flip-flop 的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面积比 latch 大，消耗的门电路比 latch 多&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前 latch 只在极高端的电路中使用，如 intel 的 P4 等 CPU。而在 PLD / FPGA 中，基本单元 LE 是查找表 LUT 和触发器 FF 组成的，如果要实现 latch，反而需要更多的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般的设计规则是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在绝大多数设计中避免产生 latch。它会让您设计的时序完蛋，并且它的隐蔽性很强，非老手不能查出。latch 最大的危害在于不能过滤毛刺。这对于下一级电路是极其危险的。所以，只要能用 DFF 的地方，就不用 latch。&lt;/p&gt;
&lt;h3 id="reason-solution-to-unexpected-latch"&gt;Reason &amp;amp; Solution to unexpected latch&lt;/h3&gt;
&lt;p&gt;在电路设计中，要对Latch特别谨慎，如果综合出和设计意图不一致的 Latch，会导致设计错误，包括仿真和综合。因此，要避免产生意外的 Latch。&lt;/p&gt;
&lt;h4 id="reason"&gt;Reason&lt;/h4&gt;
&lt;p&gt;如果组合逻辑完全不使用 always 语句，那么就不会产生 latch，比如&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;电路不需要保存 dout 的前一个值，所以不会产生 latch。&lt;/p&gt;
&lt;p&gt;如果组合逻辑使用了 always 语句，那么就有可能产生 Latch ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不完整的 if-else&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="if_latch" src="/images/latch_versus_flip_flop/if_latch.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不完整的 case&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="case_latch" src="/images/latch_versus_flip_flop/case_latch.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="solution"&gt;Solution&lt;/h4&gt;
&lt;p&gt;知道了原因，那么解决方法也就显而易见了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用完整的 if-else&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="if-else" src="/images/latch_versus_flip_flop/if_else.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用完整的 case，添加 default 分支&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nl"&gt;default:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b00&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;RTL Schemtatic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="case-default" src="/images/latch_versus_flip_flop/case_default.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="application"&gt;Application&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3522845/"&gt;《Verilog HDL 程序设计与实践》&lt;/a&gt; 笔记：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;latch 作为一种电路单元,必然有其存在的理由以及应用场景,并不像目前的很多书籍简单地将锁存器列为“头等敌人”。其实在实际中,有些设计是不可避免地要用到锁存器,特别是在总线应用上,锁存器能提高驱动能力、隔离前后级。例如,常见的应用包括地址锁存器、数据锁存器以及复位信号锁存器等。但在更多的情况下,很容易在代码中产生未预料到的锁存器,使得逻辑功能不满足要求,浪费了大量的调试时间,从而使得大多数设计人员“闻虎色变”。&lt;/p&gt;
&lt;p&gt;因此较好的应用规则是:&lt;strong&gt;要学会分析是否需要锁存器以及代码是否会产生意想不到的锁存器。只有这样才能灵活运用锁存器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面通过实例来给予说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example1&lt;/strong&gt;: 通过Verilog HDL实现序列最大值搜索程序，并保持检测到的最大值&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;latch_demo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  
          &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;  
      &lt;span class="p"&gt;);&lt;/span&gt;  
      &lt;span class="n"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
      &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="n"&gt;reg&lt;/span&gt;      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
       &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;127&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="n"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码在ISE中的综合结果会给出设计中包含Latch的警告。但实际上，abmax_tmp锁存器正是我们需要的，所以，虽然有警告，但是代码设计是没有问题的。将上述代码的if语句补全：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;abmax_tmp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
      &lt;span class="n"&gt;abmax_tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="k"&gt;else&lt;/span&gt;  
      &lt;span class="n"&gt;abmax_tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;abmax_tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;经过综合后，仍然有Latch的警告。无论Latch是否是用户需要的，ISE都会给出警告，主要原因就是Latch对整个设计的时序性能影响较大。所以，在设计中要尽量避免Latch，但是确实需要使用的情况，也可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example2:&lt;/strong&gt; 用Verilog HDL实现一个锁存器，当输入数据大于127时，将输入数据输出，否则输出0&lt;/p&gt;
&lt;p&gt;不期望的 latch 指的是与设计意图不符，产生的 Latch。主要问题在于设计人员没有合理使用Verilog HDL语言，常见的原因是对条件语句（if、casse）的分支描述不完整，导致电路的功能不是预期的，发生了错误。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;latch_demo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  
      &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;  
  &lt;span class="p"&gt;);&lt;/span&gt;  
  &lt;span class="n"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="n"&gt;output&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;reg&lt;/span&gt;      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
       &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;127&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="n"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;综合后的结果，在比较器后面级联了锁存器，这是因为if语句缺少else分支造成的。查看仿真结果，当输入小于127时，输出保持了上次的127，不是0，没有达到设计要求。修改方法很简单，就是将if-else补全。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;127&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="k"&gt;else&lt;/span&gt;  
      &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在ISE中综合后的结果中，可以看到补全if-else后，在比较器后面级联了与门，代替原来的锁存器，仿真结果也正确。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;锁存器 latch 是一种基本电路单元,会影响到电路的时序性能,应该尽量避免使用,但出现锁存器造成设计和原始意图不符的情况,则是由于设计人员代码输入不正确造成的。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Flip-flop_(electronics"&gt;Flip-flop (electronics) --wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2883561/"&gt;数字设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3522845/"&gt;Verilog HDL 程序设计与实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/surgeddd/article/details/4683657"&gt;锁存器、触发器、寄存器和缓冲器的区别&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="latch"></category><category term="flip-flop"></category></entry><entry><title>VHDL 笔记 2 —— 系统设计</title><link href="http://guqian110.github.io/pages/2014/09/16/vhdl_notes_2_system_design.html" rel="alternate"></link><updated>2014-09-16T20:18:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-09-16:pages/2014/09/16/vhdl_notes_2_system_design.html</id><summary type="html">&lt;p&gt;总结 &lt;code&gt;packege&lt;/code&gt;, &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 的相关知识。&lt;/p&gt;
&lt;p&gt;这些组成部分添加到代码主体部分，目的是为了实现常用代码共享。通常这些代码被放在 &lt;code&gt;library&lt;/code&gt; 中，我们可以将自己设计的一些常用代码添加到 &lt;code&gt;library&lt;/code&gt; 中，这有利于使一个复杂设计具有更清晰的结构。&lt;/p&gt;
&lt;p&gt;总之，经常使用的代码可以以 &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 的形式放到 &lt;code&gt;package&lt;/code&gt; 中，然后被编译到目标 &lt;code&gt;library&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="packages-and-components"&gt;Packages and Components&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id="package"&gt;Package&lt;/h3&gt;
&lt;p&gt;除了 &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 之外，package 中还可以包含 &lt;code&gt;TYPE&lt;/code&gt;, &lt;code&gt;CONSTANT&lt;/code&gt; 的定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;PACKAGE&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;declarations&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;PACKAGE&lt;/span&gt; &lt;span class="n"&gt;BODY&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FUNCTION&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;PROCEDURE&lt;/span&gt; &lt;span class="n"&gt;descriptions&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，语法包括两部分，&lt;code&gt;PACKAGE&lt;/code&gt; 和 &lt;code&gt;PACKAGE BODY&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PACKAGE&lt;/code&gt; 是必需的，包括所有的声明语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PACKAGE BODY&lt;/code&gt;：可选，当第一部分包含一个/多个  FUNCTION，PROCEDURE 声明时，这部分必须包含相应的描述代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;---------&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;define&lt;/span&gt;&lt;span class="o"&gt;-------------&lt;/span&gt;
&lt;span class="n"&gt;LIRRARY&lt;/span&gt; &lt;span class="n"&gt;IEEE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;IDEE&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;STD_LOGIC_1164&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;PACKAGE&lt;/span&gt; &lt;span class="n"&gt;my_package&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt;
    &lt;span class="n"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="nf"&gt;IS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;st2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;st3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;st4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CONSTANT&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;STD_LOGIC_VECTOR&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;DOWNTO&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;11111111&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;my_package&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;---------&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="o"&gt;------------------&lt;/span&gt;

&lt;span class="n"&gt;LIBRARY&lt;/span&gt; &lt;span class="n"&gt;IEEE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;IEEE&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;STD_LOGIC_1164&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;my_package&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;declaration&lt;/span&gt;

&lt;span class="n"&gt;ENTITY&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="n"&gt;ARCHITECTURE&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="o"&gt;--------------------------------------&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="componet"&gt;Componet&lt;/h3&gt;
&lt;p&gt;VHDL 中的 &lt;code&gt;component&lt;/code&gt; 和 Verilog HDL 中的 &lt;code&gt;module&lt;/code&gt; 类似：&lt;/p&gt;
&lt;p&gt;一个 component 是一段完整的代码（包括 library, entity, architecture 这些组成部分），如果将这些代码声明为一个 component，那么就可以被其他电路调用，从而使代码具有了层次化的结构。&lt;/p&gt;
&lt;p&gt;使用 component 必须先声明这个元件，然后再例化这个元件（类似 C++，变量先声明，在定义）。声明和例化都必须在 architecture 中进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;declaration syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;COMPONENT&lt;/span&gt; &lt;span class="n"&gt;component_name&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt;
    &lt;span class="n"&gt;PORT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="nl"&gt;port_name:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nl"&gt;port_name:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;COMPONENT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;instantiation syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;component_name&lt;/span&gt; &lt;span class="n"&gt;PORT&lt;/span&gt; &lt;span class="n"&gt;MAP&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port_list&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;声明时，component 和 entity 相似，必须声明端口的模式和类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例化时，必须添加一个标号，就像 Verilog HDL 中例化 module 必须给个名字一样&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;声明元件时，可以有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上面的方法，先声明再例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 package 进行声明，将 component 的声明放在 package 中，则可以避免每次元件例化都要重复声明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种方法的区别类似于使用 C++ 中的 namespace 时的不同方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法一：每次使用 STL 都添加作用域&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;hello world!&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法二：声明一次作用域&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="port-map"&gt;port map&lt;/h3&gt;
&lt;p&gt;同 Verilog HDL 一样，两种端口映射的方法：位置映射、名字映射。&lt;/p&gt;
&lt;p&gt;位置映射书写简单，但是容易出错；名字映射书写繁琐，但是不易出错，端口连接也更清晰，未连接的端口要使用关键词 &lt;code&gt;open&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;positional&lt;/span&gt;
&lt;span class="nl"&gt;U1:&lt;/span&gt; &lt;span class="n"&gt;inverter&lt;/span&gt; &lt;span class="n"&gt;PORT&lt;/span&gt; &lt;span class="n"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;nominal&lt;/span&gt;
&lt;span class="nl"&gt;U1:&lt;/span&gt; &lt;span class="n"&gt;inverter&lt;/span&gt; &lt;span class="n"&gt;PORT&lt;/span&gt; &lt;span class="n"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="generic-map"&gt;generic map&lt;/h3&gt;
&lt;p&gt;generic 功能类似于 Veriog HDL 中的 parameter，所以在例化时 component 时，可以重载参数，使设计更方便灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;component_name&lt;/span&gt; &lt;span class="n"&gt;GENERIC&lt;/span&gt; &lt;span class="n"&gt;MAP&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;list&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;PORT&lt;/span&gt; &lt;span class="n"&gt;MAP&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也就是说，在例化时，添加一段 &lt;code&gt;GENERIC MAP (param.list)&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="functions-and-procedure"&gt;Functions and Procedure&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;function 和 procedure 统称为 子程序，它们和 process 相似，内部包含的都是顺序描述的代码，通常使用相同的顺序描述语句。但是，function 和 procedure 的存在主要是为了建库，以达到代码重用和共享的目的，当然它们也可以直接建立在主代码中。&lt;/p&gt;
&lt;h3 id="function"&gt;Function&lt;/h3&gt;
&lt;p&gt;一个 function 就是一段顺序描述的代码。&lt;/p&gt;
&lt;p&gt;在写代码的过程中，我们通常会遇到一些有共性的问题，我们希望实现这些功能的代码可以被共享和重用，从而使代码变得简洁，易于理解，function 的建立和使用就能达到这个目睹。
function 中可以使用 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;loop&lt;/code&gt; 等语句，但是不能有 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;component&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;function 的使用方法：先创建函数体本身，再调用函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function Body&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nx"&gt;FUNCTION&lt;/span&gt; &lt;span class="nx"&gt;function_name&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;parameter&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nx"&gt;RETURN&lt;/span&gt; &lt;span class="nx"&gt;data_type&lt;/span&gt; &lt;span class="nx"&gt;IS&lt;/span&gt;
    &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;declarations&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
&lt;span class="nx"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sequential&lt;/span&gt; &lt;span class="nx"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;END&lt;/span&gt; &lt;span class="nx"&gt;function_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，&lt;parameter list&gt; 指函数的输入参数：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;CONSTANT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;constant_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;constant_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt; &lt;span class="n"&gt;signal_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数可以是 constant, signal，但是不能是 variable；参数的个数可以是任意个，类型也任意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function Call&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数可以单独构成表达式，也可以作为表达式的一部分。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;conv_integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;maximum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Function Location&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数可以存放在两个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Package 中，这时候，函数声明在 package 中，函数定义在 package body 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Main Code 中，既可以在 entity 中，也可以在 architecture 中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="procedure"&gt;Procedure&lt;/h3&gt;
&lt;p&gt;procedure 和 function 类似，目的也相同，不同之处在于 procedure 可以有多个返回值。&lt;/p&gt;
&lt;p&gt;与 function 类似，procedure 也需要定义和调用两个过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Procedure Body&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;PROCEDURE&lt;/span&gt; &lt;span class="n"&gt;procedure_name&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarations&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;procedure_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，&lt;parameter list&gt; 指出了 procedure 的输入输出参数：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;CONSTANT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;constant_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt; &lt;span class="n"&gt;signal_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;VARIABLE&lt;/span&gt; &lt;span class="n"&gt;variable_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数可以有任意多个，可以是 in, out, inout 模式的 signal, variable, constant。&lt;/p&gt;
&lt;p&gt;和 function 一样，procedure 内部的 wait 语句，signal 声明，component 调用都是不可综合的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Procedure Call&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;procedure 的调用就是它自己。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;
&lt;span class="n"&gt;compute_min_max&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;in2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;in3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;out1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;out2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;divide&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dividend&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;divisor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;quotient&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;remainder&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Procedure Location&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;procedure 的存放和 function 类似，通常放在 package 中，当然也可以放在主代码中。&lt;/p&gt;
&lt;h3 id="function-versus-procedure-summary"&gt;FUNCTION versus PROCEDURE Summary&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;function 有任意个输入参数和一个返回值，输入参数只能是 constant, signal&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;procedure 有任意个输入/输出/双向参数，可以是 signal, variable, constant&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 可以作为表达式的一部分，procedure 直接调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 和 procedure 内部，wait 和 component 都不可综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 和 procedure 的存放位置相同，经常位于 package 中，也可以在主代码中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Circuit-Design-VHDL-Volnei-Pedroni/dp/0262162245"&gt;Circuit Design with VHDL&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="VHDL"></category><category term="syntax"></category></entry><entry><title>VHDL 笔记 1 —— 电路设计</title><link href="http://guqian110.github.io/pages/2014/09/16/vhdl_notes_1_circuit_design.html" rel="alternate"></link><updated>2014-09-16T14:56:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-09-16:pages/2014/09/16/vhdl_notes_1_circuit_design.html</id><summary type="html">&lt;h2 id="code-structure"&gt;Code Structure&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一段独立的 VHDL 代码一般至少由 3 部分组成：&lt;code&gt;LIBRARY declarations&lt;/code&gt;、&lt;code&gt;ENTITY&lt;/code&gt;、&lt;code&gt;ARCHITECTURE&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Library 用来设计重用和代码共享，使代码结构更清晰&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;LIBRARY&lt;/span&gt; &lt;span class="n"&gt;library_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;USE&lt;/span&gt; &lt;span class="n"&gt;library_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;package_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;package_parts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常用的 3 个 Library：&lt;code&gt;ieee&lt;/code&gt;、&lt;code&gt;std&lt;/code&gt;、&lt;code&gt;work&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中 std 和 work 是默认可见的，不需声明，ieee 需要明确的声明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Entity 描述电路的输入/输出引脚&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;ENTITY&lt;/span&gt; &lt;span class="n"&gt;entity_name&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt;
    &lt;span class="n"&gt;PORT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="nl"&gt;port_name:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nl"&gt;port_name:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;entity_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;singal_mode 可以是 4 种类型： &lt;code&gt;in&lt;/code&gt; &lt;code&gt;out&lt;/code&gt; &lt;code&gt;inout&lt;/code&gt; &lt;code&gt;buffer&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt; 模式无法回读到电路内部，&lt;code&gt;Buffer&lt;/code&gt; 模式可以，但是 buffer 不能连接到其他类型的端口，即不能把该模块作为子模块例化，一般使用中间缓冲信号，解决回读问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Architecture 描述电路的行为和实现的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Architecture 包含两部分：声明部分和代码部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明部分（可选）用来声明信号、常量等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码部分（begin ... end）描述电路行为&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释行用 &lt;code&gt;--&lt;/code&gt; 开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VHDL 不区分大小写&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="data-types"&gt;Data Types&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;前面的 Entity 中的端口定义：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;port_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有其它地方声明的信号 &lt;code&gt;signal&lt;/code&gt; :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有 常量 &lt;code&gt;constant&lt;/code&gt; 声明：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;constant&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有 变量 &lt;code&gt;variable&lt;/code&gt; 声明：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这些声明中都包含了数据类型字段。一个信号/常量/变量的数据类型决定了它能取到什么样的值，还有可以进行什么样的操作。&lt;/p&gt;
&lt;h3 id="pre-defined-data-types"&gt;Pre-defined Data Types&lt;/h3&gt;
&lt;p&gt;IEEE 1164 标准中包含了一些预先定义的数据类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std&lt;/code&gt; 库中的 &lt;code&gt;standard&lt;/code&gt; 包集(package) 定义了：&lt;code&gt;bit&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;integer&lt;/code&gt;、&lt;code&gt;real&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_1164&lt;/code&gt; 包集定义了：&lt;code&gt;std_logic&lt;/code&gt;、&lt;code&gt;std_ulogic&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_arith&lt;/code&gt; 包集定义了：&lt;code&gt;signed&lt;/code&gt;、&lt;code&gt;unsigned&lt;/code&gt; 类型，还有一些数据类型转换函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_signed&lt;/code&gt; 和 &lt;code&gt;std_logic_unsigned&lt;/code&gt; 包集：包含一些函数，可以使 &lt;code&gt;std_logic_vector&lt;/code&gt; 类型的数据可以像 &lt;code&gt;signed&lt;/code&gt; 和 &lt;code&gt;unsigned&lt;/code&gt; 一样进行运算&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="bit-bit_vector"&gt;&lt;code&gt;bit&lt;/code&gt; &amp;amp; &lt;code&gt;bit_vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用 '0' 和 '1' 赋值&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;bit_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0011&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="std_logic-std_logic_vector"&gt;&lt;code&gt;std_logic&lt;/code&gt; &amp;amp; &lt;code&gt;std_logic_vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee 1164&lt;/code&gt; 标准中引入的 8 逻辑值系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同于 bit 类型，可以取 8 种不同的值，但只有 &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;Z&lt;/code&gt; 是可综合的，其他 5 种用来仿真&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="std_ulogic-std_ulogic_vector"&gt;&lt;code&gt;std_ulogic&lt;/code&gt; &amp;amp; &lt;code&gt;std_ulogic_vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee 1164&lt;/code&gt; 标准中定义的具有 9 种逻辑值的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std_logic&lt;/code&gt; 是 &lt;code&gt;std_ulogic&lt;/code&gt; 的子集&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="boolean"&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;只有两种取值：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="integer"&gt;&lt;code&gt;integer&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;32 位的整数 (-2 147 483 647 ~ +2 147 483 647)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="natural"&gt;&lt;code&gt;natural&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;非负整数 (0 ~ +2 147483 647)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="real"&gt;&lt;code&gt;real&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;实数，不可综合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="physical-literal"&gt;&lt;code&gt;physical literal&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;表示物理量，不可综合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="character"&gt;&lt;code&gt;character&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单一/一串 ASCII 字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="signed-unsigned"&gt;&lt;code&gt;signed&lt;/code&gt; &amp;amp; &lt;code&gt;unsigned&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_arith&lt;/code&gt; 包中定义的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和 &lt;code&gt;std_logic_vector&lt;/code&gt; 类似，但是可以支持与整数类似的算术运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="user-defined-data-types"&gt;User-defined Data Types&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;
&lt;span class="n"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;student_grade&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt; &lt;span class="n"&gt;RANGE&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;TO&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;enumerated&lt;/span&gt;
&lt;span class="n"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;idle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;backward&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="nf"&gt;IS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;green&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;white&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="subtypes"&gt;Subtypes&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;SUBTYPE&lt;/span&gt; &lt;span class="n"&gt;my_color&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="n"&gt;RANGE&lt;/span&gt; &lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="n"&gt;TO&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;my_color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;green&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="arrays"&gt;Arrays&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以认为 VHDL 预定义的数据类型只有 &lt;code&gt;scalar&lt;/code&gt;(single bit) 和 &lt;code&gt;vector&lt;/code&gt;(one-dimensional array of bits) 两种类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这两种类型中只有一下类型是可综合的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scalars: bit, std_logic, std_ulogic, boolean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vectors: bit_vector, std_logic_vector, std_ulogic_vector, integer, signed, unsigned&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt; &lt;span class="n"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;type_name&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt; &lt;span class="n"&gt;ARRAY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;specification&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;OF&lt;/span&gt; &lt;span class="n"&gt;data_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;
&lt;span class="n"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;matrix&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt; &lt;span class="n"&gt;ARRAY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;TO&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;OF&lt;/span&gt; &lt;span class="n"&gt;STD_LOGIC_VECTOR&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;DOWNTO&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;
&lt;span class="n"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;matrix2D&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt; &lt;span class="n"&gt;ARRAY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;TO&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;DOWNTO&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;OF&lt;/span&gt; &lt;span class="n"&gt;STD_LOGIC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="port-array"&gt;Port Array&lt;/h3&gt;
&lt;p&gt;有时在定义端口时，需要把端口定义为矢量阵列。但是在 &lt;code&gt;Entity&lt;/code&gt; 中不允许使用 &lt;code&gt;type&lt;/code&gt; 定义，所以我们必须自己定义包集 (package)，然后使用 &lt;code&gt;use&lt;/code&gt; 声明使用该用户自定义的包集，最后才能在 Entity 中使用这种新定义的类型。&lt;/p&gt;
&lt;h3 id="signed-and-unsigned-data-types"&gt;Signed and Unsigned Data Types&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_arith&lt;/code&gt; 包中定义了有符号数 (&lt;code&gt;signed&lt;/code&gt;) 和无符号数 (&lt;code&gt;unsigned&lt;/code&gt;) 两种数据类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有先声明使用这个库下的包，才能在代码中使用 signed/unsigned&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;ieee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std_logic_arith&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;signed&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="nf"&gt;unsigned&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用它们主要是为了进行算术运算，但是它们不支持逻辑运算。( std_logic_vector 不支持算术运算，但是支持逻辑运算)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果信号的类型只能是 std_logic_vector，那么通过其他方法也是可以进行算术运算的，解决方案就是声明使用 &lt;code&gt;ieee&lt;/code&gt; 的 &lt;code&gt;std_logic_unsigned&lt;/code&gt; 和 &lt;code&gt;std_logic_signed&lt;/code&gt; 两个包集，声明之后，std_logic_vector 就可以像 signed/unsigned 一样进行算术运算了。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;ieee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std_logic_signed&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;ieee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std_logic_unsigned&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="nf"&gt;std_logic_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="nf"&gt;std_logic_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="nf"&gt;std_logic_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="n"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;legal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arithmetic&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;legal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;logiccal&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;需要注意的是，这两个包不能同时存在于同一份代码中，因为这样会引入二义性。比如上面例子中的 “+” 运算，如果我们同时包含了这两个包集，那么编译器不知道我们定义的运算到底应该重载哪一个，综合时会报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="data-conversion"&gt;Data Conversion&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 VHDL 中，不同类型的数据是不能直接进行算术/逻辑运算的，所以必要时必须进行类型转换操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有两种方法实现类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用包中预定义的数据类型转换函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手动写一段专门用于数据类型转换的代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std_logic_arith&lt;/code&gt; 中包含了很多数据类型转换函数，可以实现不同数据之间的转换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="operators-and-attributes"&gt;Operators and Attributes&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;VHDL 语法虽然枯燥无味，但是只有对数据类型、运算操作符及其属性有了深刻认识，才能写出高质量和高效率的代码。&lt;/p&gt;
&lt;h3 id="opreators"&gt;Opreators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;VHDL 提供了 6 种预定义的预算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;赋值 assignment&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑 logical&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算术 arithmetic&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系 relational&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移位 shift&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并置 concatenation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="assignment"&gt;&lt;code&gt;assignment&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;一共 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; 用于给 &lt;code&gt;signal&lt;/code&gt; 对象赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:=&lt;/code&gt; 用于给 &lt;code&gt;variable&lt;/code&gt;, &lt;code&gt;constant&lt;/code&gt;, &lt;code&gt;generic&lt;/code&gt; 赋值，还可用于赋初值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt; 用于给矢量(vector)对象的某些位赋值，常和 &lt;code&gt;others&lt;/code&gt; 一起使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="logical"&gt;&lt;code&gt;logical&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;进行逻辑运算，操作数必须是 &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;std_logic&lt;/code&gt;, &lt;code&gt;std_ulogic&lt;/code&gt; 类型或者它们的扩展，即&lt;code&gt;bit_vector&lt;/code&gt;, &lt;code&gt;std_logic_vector&lt;/code&gt;, &lt;code&gt;std_ulogic&lt;/code&gt; 类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NOT&lt;/code&gt;, &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, &lt;code&gt;NAND&lt;/code&gt;, &lt;code&gt;NOR&lt;/code&gt;, &lt;code&gt;XOR&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="arithmetic"&gt;&lt;code&gt;arithmetic&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作数是 &lt;code&gt;signed&lt;/code&gt;, &lt;code&gt;unsigned&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;，其中 &lt;code&gt;real&lt;/code&gt; 类型是不可综合的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果声明了 &lt;code&gt;std_logic_signed&lt;/code&gt; 或者 &lt;code&gt;std_logic_unsigned&lt;/code&gt;，则 &lt;code&gt;std_logic_vector&lt;/code&gt; 类型也可以进行加减运算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;MOD&lt;/code&gt;, &lt;code&gt;REM&lt;/code&gt;, &lt;code&gt;ABS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="comparison"&gt;&lt;code&gt;comparison&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;一共有 6 种：&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="shift"&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;VHDL93 中引入的操作，语法：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="n"&gt;operand&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;shift&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="n"&gt;operand&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;left operand 必须是 &lt;code&gt;bit_vector&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right operand 必须是 &lt;code&gt;integer&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shift operator 有：&lt;code&gt;sll&lt;/code&gt;, &lt;code&gt;srl&lt;/code&gt;, &lt;code&gt;sla&lt;/code&gt;, &lt;code&gt;sra&lt;/code&gt;, &lt;code&gt;rol&lt;/code&gt;, &lt;code&gt;ror&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="concatenation"&gt;&lt;code&gt;concatenation&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;用于位的拼接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作数：任何支持逻辑运算的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作符：&lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;(, , ,)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="attributes"&gt;Attributes&lt;/h3&gt;
&lt;p&gt;VHDL 中的属性语句可以获得相关数据/对象 的信息，使代码更加灵活。&lt;/p&gt;
&lt;h4 id="pre-defined"&gt;Pre-defined&lt;/h4&gt;
&lt;p&gt;内置的预定义属性可以分为两大类：数值类属性 和 信号类属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;data attributes&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;signal attributes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数信号类属性都是不可综合的，只有 &lt;code&gt;s'event&lt;/code&gt; 和 &lt;code&gt;s'stable&lt;/code&gt; 是可综合的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="user-defined"&gt;User-defined&lt;/h4&gt;
&lt;p&gt;也可以用户自己定义一个新的属性，并描述某个对象的这个属性的值是多少，之后就可以使用这个属性了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;ATTRIBUTE&lt;/span&gt; &lt;span class="n"&gt;attribute_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;attribute_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;declaration&lt;/span&gt;
&lt;span class="n"&gt;ATTIRBUTE&lt;/span&gt; &lt;span class="n"&gt;attribute_name&lt;/span&gt; &lt;span class="n"&gt;OF&lt;/span&gt; &lt;span class="n"&gt;target_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;specification&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;example：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;ATTRIBUTE&lt;/span&gt; &lt;span class="n"&gt;number_of_inputs&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;INTEGER&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ATTRIBUTE&lt;/span&gt; &lt;span class="n"&gt;number_of_inputs&lt;/span&gt; &lt;span class="n"&gt;OF&lt;/span&gt; &lt;span class="n"&gt;nand3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;nand3&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;number_of_inputs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;首先定义了一个新的属性，名字叫 &lt;code&gt;number_of_inputs&lt;/code&gt;，表示输入端口的个数，然后针对对象 nand3 (3输入的与非门) 这个对象，描述它的这个属性的类型为 signal 类型，取值为 3；最后，使用这个属性，将 nand3 的这个属性的值赋值给 input 对象。&lt;/p&gt;
&lt;h3 id="operator-overloading"&gt;Operator Overloading&lt;/h3&gt;
&lt;p&gt;用户不仅可以自定义属性，还可以自定义操作符。预定义的操作符的操作数必须是特定的类型，对于某些类型，我们可以自定义操作符对应的操作。&lt;/p&gt;
&lt;p&gt;VHDL 中的自定义操作符作用和 C++ 中的操作符重载 方法、目的都很类似。首先构造一个函数，然后调用这个函数即可。&lt;/p&gt;
&lt;h3 id="generic"&gt;GENERIC&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;generic&lt;/code&gt; 必须在 ENTITY 中声明，它可以指定常规参数，所指定的参数是&lt;strong&gt;静态的&lt;/strong&gt;，&lt;strong&gt;全局的&lt;/strong&gt;。感觉类似于 Verilog 中的 &lt;code&gt;define&lt;/code&gt; 吧，但是显然 Verilog 中的 &lt;code&gt;parameter&lt;/code&gt; 是更好的设计，因为全局变量/常量很不安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;GENERIC&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parameter_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;parameter_type&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;parameter_value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;ENTITY&lt;/span&gt; &lt;span class="n"&gt;my_entity&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt;
    &lt;span class="nf"&gt;GENERIC&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;INTEGER&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;PORT&lt;/span&gt; &lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;my_entity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="concurrent-code"&gt;Concurrent Code&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;从本质上讲，HDL 是 描述 (Description) 语言，对应的是硬件电路，而硬件电路是时刻工作的，所以，它的代码是并发执行的。只有 &lt;code&gt;process&lt;/code&gt;，&lt;code&gt;function&lt;/code&gt;，&lt;code&gt;procedure&lt;/code&gt; 中的代买是顺序执行的，而且当这些模块作为一个共同的整体时，它们之间也是并行的。&lt;/p&gt;
&lt;p&gt;在并发代码中可以使用下列各项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运算操作符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;when&lt;/code&gt; 语句（when/else 和 with/select/when）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;generate&lt;/code&gt; 语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;block&lt;/code&gt; 语句&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仔细观察可以发现，其实 when, generate, block 语句和预算语句相比，只是添加了一些条件判断，它们主要的核心还是运算操作符组成的运算，所以，并行代码的核心就是这些并行的运算语句。&lt;/p&gt;
&lt;h3 id="when"&gt;&lt;code&gt;when&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;When/else syntax:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="n"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="n"&gt;ELSE&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="n"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="n"&gt;ELSE&lt;/span&gt;
&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;with/select/when syntax:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt; &lt;span class="n"&gt;SELECT&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="n"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="n"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="generate"&gt;&lt;code&gt;generate&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;功能类似于 Verilog HDL 中的 generate，它常和 for/if 一起使用。
因为描述的对象是电路，最终的电路是固定的，功能也是静态的，所以，对于 generate，它的循环操作的上下界必须是静态的，否则代码是不可综合的。&lt;/p&gt;
&lt;p&gt;实际上，引入 generate 的主要目的是为了写出更加通用的代码，达到修改最少代码，实现不同设计的目的，也就是动态编译。而引入 for 循环，只是为了减少代码量。&lt;/p&gt;
&lt;h3 id="block"&gt;&lt;code&gt;block&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;VHDL 中存在两种类型的块 block：简单块 (simple block) 和 卫式块 (guarded block):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;simple block&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;simple block 只是对原有代码进行了区域分割，目的也仅仅是为了增强代码的可读性和可维护性。&lt;/p&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nl"&gt;label:&lt;/span&gt; &lt;span class="n"&gt;BLOCK&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarative&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concurrent&lt;/span&gt; &lt;span class="n"&gt;statement&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;BLOCK&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;guarded block&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;guarder block 是一种特殊的 block，它比 simple block 多了一个表达式，叫做 &lt;code&gt;guard expression&lt;/code&gt;，只有当这个表达式为 True 时，这个 block 才会执行。&lt;/p&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nl"&gt;label:&lt;/span&gt; &lt;span class="n"&gt;BLOCK&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarative&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concurrent&lt;/span&gt; &lt;span class="n"&gt;guarded&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;unguarded&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;BLOCK&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="sequential-code"&gt;Sequential Code&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;VHDL 本质是并发执行的代码，但是在 &lt;code&gt;process&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 内部的代码是顺序执行的，当它们作为一个整体时，相互之间也是并发执行的。&lt;/p&gt;
&lt;p&gt;顺序代码并非只能与时序逻辑 (&lt;code&gt;sequential logic&lt;/code&gt;) 对应，同样也可以用它们来实现组合逻辑 (&lt;code&gt;combinational logic&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;顺序代码也称为描述代码 (&lt;code&gt;behavioral code&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;这里主要讨论顺序代码，也就是这 3 个块中的代码，包括 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;wait&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;loop&lt;/code&gt; 语句。&lt;/p&gt;
&lt;h3 id="process"&gt;&lt;code&gt;process&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;作用类似于 Verilog HDL 中的 always 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lable&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;PROCESS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sensitivity&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;VARIABLE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;;]]&lt;/span&gt;
&lt;span class="n"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;PROCESS&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="if"&gt;&lt;code&gt;if&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;IF&lt;/span&gt; &lt;span class="n"&gt;conditions&lt;/span&gt; &lt;span class="n"&gt;THEN&lt;/span&gt; &lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ELSIF&lt;/span&gt; &lt;span class="n"&gt;conditions&lt;/span&gt; &lt;span class="n"&gt;THEN&lt;/span&gt; &lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;ELSE&lt;/span&gt; &lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="wait"&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果在 process 中使用了 wait 语句，那么 process 就不能含有敏感信号列表了，所以此时 wait 必须是 process 的第一条语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax1&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;WAIT&lt;/span&gt; &lt;span class="n"&gt;UNTILL&lt;/span&gt; &lt;span class="n"&gt;signal_condition&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;syntax2&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;WAIT&lt;/span&gt; &lt;span class="n"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;signal1&lt;/span&gt; &lt;span class="p"&gt;[,&lt;/span&gt; &lt;span class="n"&gt;signal2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;syntax3&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;WAIT&lt;/span&gt; &lt;span class="n"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;simulation&lt;/span&gt; &lt;span class="n"&gt;only&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="case"&gt;&lt;code&gt;case&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;case 和 when 的区别在于，case 允许在每个测试条件下执行多个赋值操作，而 when 只能执行一个赋值操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;CASE&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt; &lt;span class="n"&gt;IS&lt;/span&gt;
    &lt;span class="n"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;CASE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="loop"&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;syntax1: FOR/LOOP repeat a fix number of times&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt; &lt;span class="n"&gt;range&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;syntax: WHILE/LOOP&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;WHILE&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;syntax3: EXIT&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;EXIT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;syntax4: NEXT&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;NEXT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;loop_label&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="signals-variables"&gt;Signals &amp;amp; Variables&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;VHDL 提供了 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;variable&lt;/code&gt; 两种对象来处理非静态数据；提供了 &lt;code&gt;constant&lt;/code&gt; 和 &lt;code&gt;generic&lt;/code&gt; 来处理静态数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constant&lt;/code&gt; 和 &lt;code&gt;signal&lt;/code&gt; 是全局的，可以在顺序执行的代码中，也可以在并发执行的代码中；&lt;code&gt;variable&lt;/code&gt; 是局部的，只能值顺序代码中，并且它们的值是不能向外传递的(如果像传递出去，必须先把这个变量值传递给一个信号，再由这个信号传递出去)。&lt;/p&gt;
&lt;h3 id="constant"&gt;&lt;code&gt;constant&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;constant 可以定义在 package, entity, architecture 中，对应的作用域也不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义在 package 中的 constant 是真正的全局的，可以被所有调用该 package 的 entity 使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义在 entity 中的 constant 对于该 entity 的所有 architecture 而言是全局的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义在 architecture 中的 constant 仅在该 architecture 中是全局的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;CONSTANT&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="signal"&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;VHDL 中的 &lt;code&gt;signal&lt;/code&gt; 代表的是逻辑电路中的 “硬”连线，既可以用于电路的输入输出端口，也可以用于 内部单元之间的连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;SIGNAL&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和 Verilog HDL 的 always 中的 reg 类似，VHDL 的 process 中的 signal 也是在进程结束时更新值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对同一个信号多次重复赋值，结果取决于编译器。(Xilinx XST 不报错，认为最后一次赋值是有效的)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="variable"&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;相比于 signal 是局部的，variable 只能在 process，function，procedure 中使用，而且对它的赋值是立即更新的，新的值可以在下一行代码中立即使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;VARIABLE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Circuit-Design-VHDL-Volnei-Pedroni/dp/0262162245"&gt;Circuit Design with VHDL&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="VHDL"></category><category term="syntax"></category></entry><entry><title>FPGA 时钟设计 2 —— 时钟设计</title><link href="http://guqian110.github.io/pages/2014/09/12/the_clock_design_in_fpga_2_clock_design.html" rel="alternate"></link><updated>2014-09-12T12:45:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-09-12:pages/2014/09/12/the_clock_design_in_fpga_2_clock_design.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;无论是离散逻辑、可编程逻辑，还是用全定制硅器件实现的任何数字设计，为了成功地操作，可靠的时钟是非常关键的。&lt;/p&gt;
&lt;p&gt;设计不良的时钟在极限的温度、电压或者制造工艺的偏差情况下将导致错误的行为，并且调试困难、花销很大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下 FPGA 中的时钟设计原则。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="clock-design"&gt;Clock Design&lt;/h2&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;在 FPGA/CPLD 中通常采用几种时钟类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全局时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;门控时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级逻辑时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;波动式时钟&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多时钟系统能够包括上述 4 种时钟类型的任意组合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面是 &lt;a href="http://book.douban.com/subject/10593491/"&gt;《Xiliinx FPGA 高级设计及应用》&lt;/a&gt; 中的分类方法，个人觉得并不是很清晰，我总结了一下，大概可以分为下面的这 4 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;全局时钟 Global Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;门控时钟 Gated Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑时钟 Logic Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分频/倍频时钟 Divied/Multiplied Clock&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="gloabl-clock"&gt;Gloabl Clock&lt;/h3&gt;
&lt;p&gt;关于全局时钟，前面一篇 blog  &lt;a href=""&gt;FPGA 时钟设计 1 —— 时钟资源总结&lt;/a&gt; 中有总结。&lt;/p&gt;
&lt;p&gt;对于一个项目来说，全局时钟是 &lt;strong&gt;最简单&lt;/strong&gt;、&lt;strong&gt;最可预测&lt;/strong&gt; 的时钟。&lt;/p&gt;
&lt;p&gt;在 PLD/FPGA 项目中 &lt;strong&gt;最好的时钟方案&lt;/strong&gt; 是：由专用的全局时钟输入引脚驱动的单个主时钟去钟控设计项目中的每一个触发器。只要可能就应该尽量在设计中采用全局时钟&lt;/p&gt;
&lt;p&gt;PLD/FPGA 都具有专门的全局时钟引脚，它直接连接到器件中的每一个寄存器，这种全局时钟提供最短的时钟到输出的延时。&lt;/p&gt;
&lt;h3 id="gated-clock"&gt;Gated Clock&lt;/h3&gt;
&lt;p&gt;门控时钟的意思是通过组合逻辑，控制、禁止或允许时钟输入到寄存器和其他同步原件上的一种方法。因为它能够有效地降低功耗，所以被广泛地应用于 ASIC 设计中。但是，它不符合 &lt;code&gt;同步设计&lt;/code&gt; 的思想，可能会影响系统设计的实现和验证，所以，&lt;strong&gt;在 FPGA 设计中应该避免使用门控时钟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 ASIC 和 FPGA 结构设计上的区别，两者对待门控时钟的态度是完全不同的：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://electronics.stackexchange.com/questions/73398/gated-clocks-and-clock-enables-in-fpga-and-asics"&gt;Gated clocks and clock enables in FPGA and ASICS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;往往可以将门控时钟转化为全局时钟以改善项目设计的可靠性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;就是使用寄存器 &lt;code&gt;时钟使能 (clock enable, CE)&lt;/code&gt; 端口。&lt;/p&gt;
&lt;p&gt;单纯从功能来看，使用使能时钟代替门控时钟是一个不错的选项，但是使能时钟在使能信号关闭时，时钟信号仍然工作，它无法像门控时钟那样降低系统的功耗。&lt;/p&gt;
&lt;p&gt;推译带使能端的触发器的代码：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ce&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;得到的结果就是原语 &lt;code&gt;FDCE&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;// FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and&lt;/p&gt;
&lt;p&gt;//       Clock Enable (posedge clk).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;多路选择器（mux）&lt;/code&gt; 将组合逻辑从时钟通路搬移到数据通路。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="mux" src="/images/the-clock-design-in-fpga-2-clock-design/mux.png" /&gt;&lt;/p&gt;
&lt;p&gt;如果在设计中无法避免门控时钟，那么只要保证满足下面两个条件就可以使门控时钟和全局时钟一样可靠地工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;驱动时钟的逻辑必须只包含一个与门（或门），而且这个与门（或门）必须只有两个输入端。如果采用任何附加逻辑，则会出现竞争产生的毛刺。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑门的一个输入端为实际时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些条件的目的就是为了避免组合逻辑中的竞争带来的毛刺。&lt;/p&gt;
&lt;p&gt;根据数字电路的知识，我们知道可以通过添加“冗余逻辑”的方法来消除组合逻辑的冒险，但是，FPGA 的编译器在 综合时会去掉这些冗余逻辑，所以不能采用这种方法。&lt;/p&gt;
&lt;h3 id="logic-clock"&gt;Logic Clock&lt;/h3&gt;
&lt;p&gt;有时候会用到组合逻辑的输出作为时钟信号或者复位信号，但是这种时钟信号有两个非常重要的缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;组合逻辑产生的信号不可避免地会出现毛刺，会导致系统运行失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组合逻辑产生的时钟信号使用的是通用布线资源，和专用时钟布线相比，延迟长、时钟偏移大，满足时序要求会更加困难。如果大量的逻辑使用了这种时钟，这个问题会更加突出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（看到书上提出一个解决方案是：使用系统专用的时钟信号，将组合逻辑的输出打一拍，避免组合逻辑的直接输出，达到同步的效果。但是我个人认为这个方案不是非常好。）&lt;/p&gt;
&lt;p&gt;综上，对于 FPGA 来说，还是应该&lt;strong&gt;尽量避免使用组合逻辑的输出作为时钟&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="dividemultiplied-clock"&gt;Divide/Multiplied Clock&lt;/h3&gt;
&lt;p&gt;在我们的设计中，一般都不止一个时钟频率。如果不加注意，随意使用分频时钟，这叫做时钟满天飞，是非常不好的设计风格。&lt;/p&gt;
&lt;p&gt;对于 FPGA 来说，一般都内嵌了多个时钟管理单元，利用它们可以非常方便地达到多时钟的目的，这样的时钟信号是最稳定的。&lt;/p&gt;
&lt;p&gt;对于某些无法使用时钟管理单元的器件，则应该使用 &lt;code&gt;使能时钟 (clock enable, ce)&lt;/code&gt; 。具体方法就是：时钟还是使用原始的未分频的时钟，分频信号用来当作使能端来用。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="other-tips"&gt;Other Tips&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;只使用时钟的单个边沿&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了一些特殊的电路（如DDR）外，设计应该只使用单个边沿（上/下边沿）。使用两个边沿的问题是时钟占空比不一定是 50%，这会对电路的正常工作产生影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用差分时钟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常认为频率高于 100 MHz 就属于 &lt;code&gt;高频&lt;/code&gt;。建议在高频下使用差分时钟，因为差分时钟的抗噪声性能更好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;检测时钟缺失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 DCM/MMCM 的 &lt;code&gt;locked&lt;/code&gt; 输出，在使用时钟前先检查时钟是否锁定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发实用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4893454/"&gt;深入浅出玩转 FPGA&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="clock design"></category></entry><entry><title>Xilinx FFT IP core 笔记</title><link href="http://guqian110.github.io/pages/2014/09/02/xilinx_fft_core_notes.html" rel="alternate"></link><updated>2014-09-02T23:12:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-09-02:pages/2014/09/02/xilinx_fft_core_notes.html</id><summary type="html">&lt;p&gt;关于 FFT 的背景介绍就不再赘述，通原书和网上的教程、课件很多；关于这个 IP 核的介绍也就不再粘贴复制了，原版的 datasheet 必然是最全面的，仅记录我的使用时遇到的问题和需要注意到细节。&lt;/p&gt;
&lt;p&gt;IP 核的接口示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="schematic symbol" src="/images/xilinx_fft_core_notes/symbol.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="timing"&gt;Timing&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id="start-rfd-port"&gt;&lt;code&gt;START / RFD&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;datasheet 中没有专门描述 &lt;code&gt;start&lt;/code&gt; 信号和其他信号的时序关系，只是简单介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FFT start signal (Active High): START is asserted to begin the data loading and transform calculation (for the Burst I/O architectures). For Streaming I/O, START begins data loading, which proceeds directly to transform calculation and then data unloading.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我最开始的测试小程序中，是先判断 &lt;code&gt;rfd&lt;/code&gt; 信号，根据 rfd 来给 start 赋值。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;思路是：首先必须等 IP core 准备好接收新数据时，才能开始&lt;/em&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rfd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;busy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是仿真出来的结果显示 IP core 根本就没有工作，后来改了这两个信号的先后关系，&lt;/p&gt;
&lt;p&gt;&lt;em&gt;新思路：程序将输入 start 置有效，通知 IP core 需要调用，然后 IP core 根据自己的状态给出标识信号（rfd / busy），外部电路等到 rfd 有效时才输入需要变换的信号。&lt;/em&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;busy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样子程序就可以正常运行了。&lt;/p&gt;
&lt;h3 id="rfd-dv-port"&gt;&lt;code&gt;RFD / DV&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;在 datasheet 中给出的时序图如下所示（Burst I/O Solutions with Natural Order Output）&lt;/p&gt;
&lt;p&gt;&lt;img alt="Burst I/O Solution" src="/images/xilinx_fft_core_notes/burst_io_solution.png" /&gt;&lt;/p&gt;
&lt;p&gt;实际仿真图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rfd_dv_sim" src="/images/xilinx_fft_core_notes/rfd_dv.png" /&gt;&lt;/p&gt;
&lt;p&gt;实际仿真结果和示意图有一点点小差别：datasheet 中的时序图显示 rfd 必须在等 unload 阶段结束之后才能变有效，输入新的数据；但是实际的仿真图显示，在 unload 的后半段时间，rfd 已经变有效了，开始载入新的数据。&lt;/p&gt;
&lt;p&gt;从理论上分析，采用 Burst I/O with Natural Order Output 方案，总共需要 3N 个时钟周期，load 阶段需要 N 个周期载入数据，processing 阶段需要 N 个时钟变换，unload 阶段需要 N 个周期来输出数据。&lt;/p&gt;
&lt;p&gt;从仿真结果来看，unload 阶段和下一帧的 load 阶段有部分是重叠的，这样实际上的周期是少于 3N 个时钟的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然功能上是不影响下一帧的数据的，毕竟和预期的时序不同，不知道是否会影响时序设计，有待继续观察。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="port"&gt;Port&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id="nfft-port"&gt;&lt;code&gt;NFFT&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;这个 FFT core 是可以设置为 动态重配置的，可以在运行时改变做运算的点数，非常方便，不过有一点需要注意到是重配置的点数是有范围限制的，比如我测试时设置的最大点数为 4096 点，那么运行重配置时，最小的点数为 64。可以选择 64 ~ 4096 之间的任何一个 2 的指数。&lt;/p&gt;
&lt;p&gt;由于我一开始忽略了这一点，重配置为 16 点，迷糊了半天，重新打开 IP core 设置时才发现是自己看文档不够仔细 =.=&lt;/p&gt;
&lt;h3 id="cp-port"&gt;&lt;code&gt;CP&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;这个 FFT core 专门提供了一个端口可以设置循环前缀的长度，循环前缀 (cyclic prefix) 在通信中（尤其是 OFDM）是很有用的。&lt;/p&gt;
&lt;p&gt;在向导中设置了 cyclic prefix insertion，并且在程序重配置时设置了 CP length = 10，但是仿真结果却没有出现 CP，和 CP = 0 时的结果相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仔细看了两遍程序和 datasheet，没有发现问题...待解决！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 09/03/2014&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又仔细看了两遍 datasheet，终于发现了原因所在。在关于 CP length 部分，最有一小段话一直被我匆匆忽略了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The initial value and reset value of CP_LEN is 0 (no cyclic prefix). The core uses the log2(point size) MSBs of CP_LEN for the cyclic prefix length. So, when the point size decreases, the leftover LSBs are ignored. This effectively scales the cyclic prefix length with the point size, keeping them in approximately constant proportion. However, all bits of CP_LEN are latched into the core on CP_LEN_WE and are used in later transforms if the point size increases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细读了一遍才明白，CP_LEN 起作用的是高位的数据 —— 从 MSB 起共 log2(point size) 位。比如我测试程序设置的最大点数为 4096，这是 CP_LEN 的位宽为 12 比特，但是在程序运行过程中，我重配置为 64 点，所以这时候应该从 CP_LEN 的最高位数起，共 log2(64) = 6 比特数据起作用。如果我想设置 CP 的长度为 8 点，则应该如下&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cp_len&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b001000_000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这时候，如下图所示，结果与预期相符。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cp" src="/images/xilinx_fft_core_notes/cp.png" /&gt;&lt;/p&gt;
&lt;h3 id="fft-ifft"&gt;FFT/ IFFT&lt;/h3&gt;
&lt;p&gt;在 FFT 的测试程序中，一切都正常工作，但是切换为 IFFT 模式，却出现了问题。&lt;/p&gt;
&lt;p&gt;datasheet 中介绍，控制正反变换的信号一共有两个：&lt;code&gt;fwd_inv&lt;/code&gt; 和 &lt;code&gt;fwd_inv_we&lt;/code&gt;。前者取 1 时为 FFT，取 0 为 IFFT；后者是前者的写使能信号。&lt;/p&gt;
&lt;p&gt;因为 FFT 的程序可以正常工作，说明程序逻辑是没有问题的。但是只配置这两个端口，就是有问题。自己研究无果，只能 Google，还真的找到以前有人也遇到同样的问题，并且给出了解决方法（不得不说，还是 Google 好，某度搜出来的结果都是广告和没有用的链接）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://forums.xilinx.com/t5/Digital-Signal-Processing-IP-and/IFFT-of-FFT-module-does-not-work/td-p/71555"&gt;IFFT of FFT module does not work&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://myfpgablog.blogspot.com/2009/11/ifft-in-system-generator.html"&gt;IFFT in System Generator (blogspot 需翻墙)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转原博客部分内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By default, the FFT block is configured to calculate DFT. The setup and timing of control/data signals for IDFT are the same as DFT except for two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The FFT block needs to be set up for IDFT by setting fwd_inv_we signal to 1 and fwd_inv signal to 0 before the start of the transform.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The FFT output needs to be manually scaled to account for the factor 1/N in Equation 2 above. The scaling can be done either by using the scaling schedule input or shifting the FFT output if the FFT block is set to "unscaled".&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题关键就在于第二条，需要手动设置数据缩放，给结果乘以 1/N。&lt;/p&gt;
&lt;p&gt;原因就是这个 IP core 在计算 FFT 和 IFFT 时，利用两者表达式上的相似点，使用相同的结构，但是却缺少给 IFFT 的结果乘以 1/N 的步骤，需要用户自己添加。&lt;/p&gt;
&lt;p&gt;在 datasheet 中介绍说&lt;/p&gt;
&lt;p&gt;&lt;img alt="theory" src="/images/xilinx_fft_core_notes/theory.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The inverse FFT (IFFT) is computed by conjugating the phase factors of the corresponding forward FFT.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是却没有提到这个额外的 1/N 需要用户自己手动设置，应该算是 Xilinx 的坑。修正这个倍数关系以后，结果就与预期相符了～&lt;/p&gt;
&lt;p&gt;（其实如果仔细分析对比 FPGA 和 Matlab 的结果，就能发现两者的差别就是这个 1/N 的倍数关系，只是自己对数字不敏感，又懒得仔细观察 =.=）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="ps-test-program"&gt;P.S. Test program&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id="fft-ip-core"&gt;FFT IP core&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;page1: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;channel = 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transform Length = 4096&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Radix-4, Burst I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;run time configurable transform length&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page2:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fix Point&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Input data width  = 24&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phase factor width = 24&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;block floating point&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;natural output&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cyclic prefix insertion&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;input data timing - no offset&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page3:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;use 3-multiplier structer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;use CLB logic to implement butterfly arithmetic&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;运行时重配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变换长度为 64 点，cp 长度为 10&lt;/p&gt;
&lt;h3 id="matlab"&gt;Matlab&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;re&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;im&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;imag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;im&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;FFT IP core 仿真结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fft core sim" src="/images/xilinx_fft_core_notes/fft_core_sim.png" /&gt;&lt;/p&gt;
&lt;p&gt;对比 Matlab 中的结果，可以看到 IP core 的计算结果是正确的（除了 CP 的问题）。&lt;/p&gt;</summary><category term="FPGA"></category><category term="fft"></category></entry><entry><title>Verilog 中的参数化建模</title><link href="http://guqian110.github.io/pages/2014/07/09/parameterization_modeling_in_veriog.html" rel="alternate"></link><updated>2014-07-09T23:03:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-07-09:pages/2014/07/09/parameterization_modeling_in_veriog.html</id><summary type="html">&lt;p&gt;和写软件程序一样，我们也希望 Verilog 的模块也可以重利用。要使模块可以重复利用，关键就在于避免硬编码(hard literal)，使模块参数化。&lt;/p&gt;
&lt;p&gt;参数化建模的好处是可以使代码清晰，便于后续维护和修改。&lt;/p&gt;
&lt;p&gt;Verilog 的参数化建模是有一定限制的，它的参数值是编译时计算的，不会引入任何实际的硬件电路。参数必须在编译时确定值。也就是说只能达到动态编译，固态运行，而非软件的动态编译，动态运行。&lt;/p&gt;
&lt;p&gt;这主要是因为它是描述(Description)硬件的语言，而非软件设计(Design)语言。&lt;/p&gt;
&lt;p&gt;比如一个计数器，我们可以设置一个参数来指定它的计数周期(动态编译)，但是这个计数周期在综合之后就是固定值了(固态运行)，不能在运行的时候动态地改为另外一个值(除非电路综合时同时产生了多个计数器，这种情况不算真正意义上的动态运行，而且也达不到真正意义上的动态运行，因为不可能把所有可能的计数器都实现了备用，耗费资源而且没有实际意义)。&lt;/p&gt;
&lt;p&gt;参数化建模的主要目的是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提高模块的通用性，只需要修改参数，不用修改其他代码就可以适用于不同的环境中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下我找到的资料，具体的参数化建模方法一共就 3 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;`define&lt;/code&gt; 宏定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;parameter&lt;/code&gt; 模块参数化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;`ifdef&lt;/code&gt; 等 条件编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面详细说明&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="define-macro-substitution"&gt;Define Macro Substitution&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;`define&lt;/code&gt; 是编译器指令，功能是全局宏定义的文本代替。它类似于 C 语言中的 &lt;code&gt;#define&lt;/code&gt;，用法如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// define&lt;/span&gt;
&lt;span class="cp"&gt;`define     WORD_REG    reg     [31:0]&lt;/span&gt;

&lt;span class="c1"&gt;// using&lt;/span&gt;
&lt;span class="no"&gt;`WORD_REG&lt;/span&gt;   &lt;span class="n"&gt;reg32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;`define 定义的宏的作用域是全局的，这种机制会导致两个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可能会有在不同文件中发生重定义的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译顺序有要求 file-order dependent，必须确保使用前，宏定义有效，所以每个使用到宏定义的源文件必须包含这个头文件，这会导致多重包含的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于第一个问题，尽可能把所有的宏定义放在同一个头文件中，比如 "global_define.vh"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于第二个问题，和 C++ 类似，头文件应该使用头文件保护符。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// global_define.vh head file&lt;/span&gt;
&lt;span class="no"&gt;`ifndef&lt;/span&gt; &lt;span class="no"&gt;GLOBAL_DEFINE_VH&lt;/span&gt;
&lt;span class="cp"&gt;    `define     MAX = 8&lt;/span&gt;
&lt;span class="cp"&gt;    `define     SIZE = 4&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="no"&gt;`enif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="guideline"&gt;Guideline&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于那些只限于模块内的常量，不要使用 define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 &lt;code&gt;`undef&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="parameter"&gt;Parameter&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id="parameter_1"&gt;Parameter&lt;/h3&gt;
&lt;p&gt;应该避免硬编码设计 &lt;code&gt;hard literal&lt;/code&gt;，使用参数 &lt;code&gt;parameter&lt;/code&gt; 来代替。举个例子&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// use parameter&lt;/span&gt;
&lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="no"&gt;MAX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;      &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// DO NOT use hard literal&lt;/span&gt;
&lt;span class="k"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;     &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="localparam"&gt;Localparam&lt;/h3&gt;
&lt;p&gt;Verilog-2001 中添加了一个新的关键字 &lt;code&gt;localparam&lt;/code&gt;，用来定义模块内部的、不能被其他模块修改的局部常量，概念类似于 C++ 中 class 的 protect 成员。&lt;/p&gt;
&lt;p&gt;虽然 localparam 不能被外部模块修改，但是它可以用 parameter 来初始化。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;  &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;localparam&lt;/span&gt; &lt;span class="n"&gt;N1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="parameter-redefinition"&gt;Parameter Redefinition&lt;/h3&gt;
&lt;p&gt;在 Verilog-2001 出现之前，Verilog-1995 中只有两种方法实现参数重定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 # 符号，顺序列表重定义&lt;/li&gt;
&lt;li&gt;使用 defparam&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;逐个讨论&lt;/p&gt;
&lt;h4 id="1-uisng"&gt;1. Uisng &lt;code&gt;#&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个栗子，模块 myreg&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;myreg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;Trst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;Tclk&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在上一层的模块中传递参数例化这个模块&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt;  &lt;span class="nf"&gt;bad_warpper&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;// legal parameter passing&lt;/span&gt;
    &lt;span class="n"&gt;myreg&lt;/span&gt;   &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// illegal parameter passing&lt;/span&gt;
    &lt;span class="c1"&gt;// myreg #(,,8) r1(.q(q), .d(d), .clk(clk), .rst(rst) );&lt;/span&gt;
&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然每次例化都要说明所有的参数值，但是比第二种方法好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次例化都要说明所有的参数值。&lt;/p&gt;
&lt;h4 id="2-using-defparam"&gt;2. Using &lt;code&gt;defparam&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;defparam&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比如在上面的例子中&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;defparam&lt;/span&gt;    &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以放在任何文件的任何地方，不用再重复没有修改的参数值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 defparam 有这么 "强" 的功能，反而会导致一系列的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Hierarchical deparam. &lt;/p&gt;
&lt;p&gt;比如顶层模块使用 defparam 修改子模块的参数，子模块中又使用 defparam 修改顶层模块要传递进来的参数，形成一个环，这样子可能导致综合时不提示错误，但是结果与预期不符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multiple defparams&lt;/p&gt;
&lt;p&gt;在 单个文件 / 多个文件 中重复定义 defparam，会有微妙的问题，Verilog-1995 中没有定义这种现象，实际结果依赖于使用的综合工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为 defparam 有这么多缺点，所以在 2001 年之前，Synopsys 是不支持 defparam 的，网上很多转载的博客都说 defparam 是不可综合的，实际上在后来，Synopsys 在压力之下添加了对其的支持。而我用 XST 也证明是支持 defparam 可综合。&lt;/p&gt;
&lt;p&gt;综上原因，Verilog Standards Group (VSG) 倡议大家抵制使用 defparam，大神 Clifford E. Cummings 在论文中建议综合工具如果用户坚持使用 defparam 语句，必须添加以一个参数 &lt;code&gt;+Iamstupid&lt;/code&gt;...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"The Verilog compiler found a defparam statement in the source code at
(file_name/line#).
To use defparam statements in the Verilog source code, you must include the switch
+Iamstupid on the command line which will degrade compiler performance and introduce
potential problems but is bug-compatible with Verilog-1995 implementations.
Defparam statements can be replaced with named parameter redefinition as define by
the IEEE Verilog-2001 standard."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;总结一下，可以发现 Verilog-1995 中的两种方法都不怎么好，显然 VSG 也发现了这个问题，所以在 Verilog-2001 中，出现了第三种方法，并且墙裂推荐使用这种新方法。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="3-using-named-parameter-redefinition"&gt;3. Using named parameter redefinition&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似于模块例化时端口连接的方式，比如上例中只想改变 SIZE 的值&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;myreg&lt;/span&gt;   &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合了前两种方法的有点，既显示说明了哪个参数值改变了，也将参数传递放在了实例化的语句中。这种方法是最干净的 (cleanest) 方法，不依赖于任何综合工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;貌似没有～&lt;/p&gt;
&lt;h3 id="guideline_1"&gt;Guideline&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;不要使用 defparam，应该使用 named parameter redefinition。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="example"&gt;Example&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;clock cycle definition&lt;/p&gt;
&lt;p&gt;因为时钟是一个设计中最基本的常量，它不会在随着模块变化，所以应该用 &lt;code&gt;`define&lt;/code&gt; 来定义，并且将它放在顶层的头文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FSM&lt;/p&gt;
&lt;p&gt;在一个设计中可能有不止一个 FSM，而通常 FSM 有一些共同的状态名字，比如 IDLE、READY、READ、WRITE、ERROR、DONE 等，所以应该用 &lt;code&gt;localparam&lt;/code&gt; 来定义这些常量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="conditional-compilation"&gt;Conditional Compilation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Verilog 的条件编译和 C 也十分类似。前面介绍 define 时，已经用到了条件编译中的 &lt;code&gt;`ifdef&lt;/code&gt;。条件编译一共有 5 个关键字，分别是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;ifdef&lt;/span&gt;  &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;   &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;elsif&lt;/span&gt;  &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;endif&lt;/span&gt;  &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;ifndef&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;条件编译一般在以下情况中使用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择一个模块的不同部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择不同的时序和结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择不同的仿真激励&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// example1&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example2&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example3&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`elsif&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example4&lt;/span&gt;
&lt;span class="no"&gt;`ifndef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;条件编译是一个非常好的技术，它可以帮助我们更好的管理代码。&lt;/p&gt;
&lt;p&gt;举个栗子，比如我们写了一个程序，在 debug 阶段，在程序中添加了很多显示中间变量的语句，到最后 release 时，当然要去掉这些语句。最差的方法当然是删掉这些代码，但是如果以后我们还想 debug 时，又得手动写，而且时间长了，我们自己都记不清该加哪些语句了。稍微好点的方法是把它们注释起来，但是同样，时间长了，哪些该注释，那些不该注释又混淆了。最好的方法就是用条件编译。我们可以定义一个宏 DEBUG&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;DEBUG&lt;/span&gt;

&lt;span class="c1"&gt;// conditional compilation&lt;/span&gt;
&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;ifdef&lt;/span&gt; &lt;span class="n"&gt;DEBUG&lt;/span&gt;
    &lt;span class="c1"&gt;// debug&lt;/span&gt;
&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="c1"&gt;// release&lt;/span&gt;
&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，我们只需要选择是否注释第一行的宏定义就可快速在 debug 和 release 之间切换。&lt;/p&gt;
&lt;p&gt;再比如在 Verilog 的模块中，针对不同的应用环境，我们要实现不同的模块，这时候也可以使用条件编译选择具体综合哪段代码。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;总结一下，就是一下几点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于那些只限于模块内的常量，不要使用 define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 &lt;code&gt;`undef&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 defparam，应该使用 named parameter redefinition。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要时使用条件编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;IEEE Std 1364-1995&lt;/p&gt;
&lt;p&gt;IEEE Std 1364-2001&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsHDLCON2002_Parameters_rev1_2.pdf"&gt;New Verilog-2001 Techniques for Creating Parameterized Models&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/oomusou/archive/2008/07/09/verilog_parameter.html"&gt;(原创) 如何使用参数式模组? (SOC) (Verilog) (C/C++) (template)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.chinaaet.com/detail/14875"&gt;艾米电子 - 参数与常量，Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eefocus.com/ilove314/blog/2012-03/231583_52a1d.html"&gt;Verilog代码可移植性设计&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="parameterization"></category></entry><entry><title>FPGA 数字处理基础 (2)</title><link href="http://guqian110.github.io/pages/2014/07/07/fpga_digital_processing_basic_2.html" rel="alternate"></link><updated>2014-07-07T23:28:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-07-07:pages/2014/07/07/fpga_digital_processing_basic_2.html</id><summary type="html">&lt;p&gt;讨论 FPGA 中无符号数 unsigned 和有符号数 signed 的问题。&lt;/p&gt;
&lt;h2 id="basic-knowledge"&gt;Basic Knowledge&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;整数的分类：&lt;/strong&gt; 无符号数 &lt;code&gt;unsigned&lt;/code&gt; 和 有符号数 &lt;code&gt;signed&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数制：&lt;/strong&gt; 10、2、8、16 进制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器数：&lt;/strong&gt; 机器数的意思是数字在机器中的表示方式。主要有 3 种&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原码 sign-magnitude&lt;/code&gt;、&lt;code&gt;反码 one's complement&lt;/code&gt;、&lt;code&gt;补码 two's complement&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以前写过的一篇总结： &lt;a href="http://guqian110.github.io/pages/2014/03/19/signed_number_representations.html"&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机系统：&lt;/strong&gt; 采用二进制、补码系统。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;FPGA 中是如何表示数字的呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以前写过一篇总结，&lt;a href="http://guqian110.github.io/pages/2014/05/14/fpga_digital_processing_basic_1.html"&gt;FPGA 数字处理基础 (1)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文算是上面文章的续吧。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="unsigned-in-verilog"&gt;(un)signed in Verilog&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id="integer"&gt;Integer&lt;/h3&gt;
&lt;p&gt;在 Verilog 中表示一个整数可以有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;简单的数字&lt;/p&gt;
&lt;p&gt;即只有简单的数字，默认为有符号数。比如 8, -10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基数表示法 &lt;code&gt;&amp;lt;size&amp;gt;'&amp;lt;s&amp;gt;&amp;lt;base&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中，size 指定需要多少位表示这个数字，有 s 表示这个数为有符号数，没有则表示这个数是无符号数，base 指定后面的 value 是使用哪种基数来描述，value 制定这个数字的大小。默认为无符号数，除非声明 s 字段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在 FPGA 也采用补码系统&lt;/strong&gt;，即在综合时，综合工具会将有符号数翻译为补码，在硬件中存储起来。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d5&lt;/span&gt;   &lt;span class="c1"&gt;// 这个数为无符号数，理解为 5, 占用 8 bit，存储的值为 0101&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd5&lt;/span&gt;  &lt;span class="c1"&gt;// 这个数为有符号数，理解为 5, 占用 8 bit，存储的值为 0101&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d5&lt;/span&gt;  &lt;span class="c1"&gt;// 这个数为无符号数，理解为 -5, 占用 8 bit，存储的值为 1011&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="n"&gt;sd5&lt;/span&gt; &lt;span class="c1"&gt;// 这个数为有符号数，理解为 -5, 占用 8 bit，存储的值为 1011&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="register"&gt;Register&lt;/h3&gt;
&lt;p&gt;Verilog 中数据的基本类型： &lt;code&gt;wire&lt;/code&gt;、&lt;code&gt;reg&lt;/code&gt;、&lt;code&gt;integer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 Verilog-1995 中，规定所有的 wire、reg 都是 unsigned 类型，只有 integer 是 signed 类型。但是 integer 的宽度是固定的(与宿主机的字是一样的，最小为 32 位)，这样子，造成了很大的不方便和浪费。&lt;/p&gt;
&lt;p&gt;在 Verilog-2001 中，添加了 wire、reg 也可以是 signed 类型了。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据可以是 signed 和 unsigned，寄存器也可以是 signed 和 unsigned，那么综合时，是以哪个为准呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题一开始自己没有搞清楚，迷惑了一下午，后来写了几个小测试程序，最后发现这个结论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;以变量类型为准&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;即 reg/wire 为哪种，那么综合时就以这个为标准进行综合。比如当 reg 为 unsigned 类型，当我们给它赋值为 signed 类型的数据 &lt;code&gt;-5&lt;/code&gt;(&lt;code&gt;-4’d5&lt;/code&gt;) 时，综合出来的结果为 reg 存储的是 &lt;code&gt;-5&lt;/code&gt; 的补码 &lt;code&gt;1011&lt;/code&gt;,但是解释为 unsigned 类型的 &lt;code&gt;+11&lt;/code&gt;。这时候就结果和我们的预期是不一样的，出现了误差，一定要注意！另一种情况类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果参与运算的变量混合有 signed 和 unsigned 类型，那么会将 signed 转换为 unsigned 类型。(应该避免这种情况)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;=========================================以下为详细的分类讨论==================================&lt;/p&gt;
&lt;p&gt;编写一个简单的测试程序，查看综合结果和仿真波形，就可以知道综合时的策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;module: &lt;a href="http://guqian110.github.io/files/test_signed.v"&gt;test_signed.v&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;testbench: &lt;a href="http://guqian110.github.io/files/tb_test_signed.v"&gt;tb_test_signed.v&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="1-unsigned-reg-unsigned-value"&gt;1. unsigned reg &amp;amp; unsigned value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 unsigned 类型&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;赋值为 unsigned 类型&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么可以从 RTL Schematic 中看到，综合出来的比较器是 unsigned 类型。&lt;/p&gt;
&lt;h4 id="2-unsigned-reg-signed-value"&gt;2. unsigned reg &amp;amp; signed value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 unsigned 类型&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;赋值为 signed 类型&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么综合出来的比较器是 unsigned 类型。&lt;/p&gt;
&lt;h4 id="3-signed-reg-signed-value"&gt;3. signed reg &amp;amp; signed value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 signed 类型&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;赋值为 signed 类型&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么综合出来的比较器是 signed 类型。&lt;/p&gt;
&lt;h4 id="4-signed-reg-unsigned-value"&gt;4. signed reg &amp;amp; unsigned value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 signed 类型&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;赋值为 unsigned 类型&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么综合出来的比较器是 signed 类型。&lt;/p&gt;
&lt;h4 id="5-signed-reg-unsigned-reg"&gt;5. signed reg &amp;amp; unsigned reg&lt;/h4&gt;
&lt;p&gt;如果参与运算的两个变量一个是 signed，另一个是 unsigned。（注意这种现象应该避免，一般我们是不会将两种不同类型的数据混在一起进行计算的）&lt;/p&gt;
&lt;p&gt;定义 i 为 unsigned 类型，flag 为 signed 类型&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="kt"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;给 flag 赋值为 signed 的 -5&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// sigend&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;综合出来的比较器为 unsigned 类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 变量 integer 也是也可综合的。在上例中，如果将 flag 的类型改为 integer 也是可综合的，但是，因为只用到了低 8 位，所以在综合时会提示高 24 位是未连接 unconnected，但是因为 integer 是一个整体，所以即使未连接也不能优化掉，这就是在 Verilog-1995 中 integer 不够灵活的体现，好在 Verilog-2001 中已经添加了支持 reg/wire 为 signed 的类型，而且综合工具(XST)也是支持的。&lt;/p&gt;
&lt;p&gt;=======================================分割线结束==========================================&lt;/p&gt;
&lt;p&gt;以前只知道硬件上最基本的一些运算单元，比如加法器(adder)、减法器(subtractor)、比较器(comparator) 等，完成的功能是固定的，电路是不会检查输入数据的类型的。涉及到 signed 和 unsigned 类型，就出现一个问题：对于基本运算单元(比如加法器)，运算单元并不知道输入的数据是哪种数据，对于 unsigned 和 signed 类型，必然出现适合一种时不适合另外一种的问题。&lt;/p&gt;
&lt;p&gt;所以可以推断出 &lt;strong&gt;对于不同的数据类型，同样是个加法器，底层的硬件电路是不一样的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果我在程序中定义了 signed 和 unsigned 类型的数据，那么综合工具是否足够智能，能够根据数据的类型综合出正确适合的电路？&lt;/p&gt;
&lt;p&gt;答案是肯定的，即&lt;strong&gt;综合器足够智能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上面的程序证明了这一点，从 RTL 图中可以看到综合出的比较器是 signed 还是 unsigned 类型，仿真波形也可以看到，最终下载到板子上测试也符合预期。这些都证明 综合器足够智能。后来看到 &lt;a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/xst.pdf"&gt;UG627(v14.5): XST User Guide&lt;/a&gt;，才发现里面已经非常清楚地写着&lt;/p&gt;
&lt;p&gt;Chapter 3: Signed and Unsigned Support in XST&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When using Verilog or VHDL in XST, some macros, such as adders or counters, can be
implemented for signed and unsigned values.
To enable support for signed and unsigned values in Verilog, enable Verilog-2001
as follows:
+ ISE® Design Suite
  Select Verilog 2001 as instructed in the Synthesis Options topic of ISE Design Suite
Help
+ XST Command Line
  Set -verilog2001 to yes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;花费了大量时间上网找资料，在论坛里问别人无果，最后自己动手写程序测试，最后才发现原来官方资料里面早就写的清清楚楚 =.=&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;说了这么多，总结下来就是下面这几句话：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经验：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;遇到问题，先不要急着上网求助，上网求助这个方法虽然简单，但是是最不好的，一方面别人的话不一定可靠，另一方面，放弃思考直接上网求助对学习无益。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找资料的技巧很重要。虽然我大概能够猜测到 Xilinx 官方的文档中肯定有说明，但是就是懒得去下载文档，再去找。认为网上肯定有人也有相同的困惑，所以直接 Google。结果找到一堆没有帮助的网页，浪费了时间，最后还是要看文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实践是检验真理的唯一标准，到底行不行，写测试程序，在板子上跑跑，验证一下是最有力的证明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Verilog-2001 已经支持 signed 类型的 wire 和 reg，所以我们代码中如果涉及到有符号数，那么像 C 语言一样直接定义、赋值、使用即可，综合工具会综合出正确的有符号数的运算电路。不必再像以前一样手动进行补码转换，自己来处理有符号数的补码计算的细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合时的原则是按照寄存器的类型进行综合(即上面的分类讨论的结论)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仔细对比 signed 和 unsigned 类型的综合结果，可以发现 Technology Schematic 是一样的，之所以和 “理论上硬件电路是应该不一样” 矛盾，我认为原因在于 FPGA 的实现是基于查找表的。以上面的例子来说明，这个比较器的功能最终是在一个 LUT6 的查找表上实现的，所以，ASIC 上硬件电路的不同映射到 FPGA 中就是 LUT 的内容不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="FPGA"></category><category term="digital processing"></category></entry><entry><title>Sublime Text 2 和 Verilog HDL</title><link href="http://guqian110.github.io/pages/2014/07/04/sublime_text_2_and_verilog.html" rel="alternate"></link><updated>2014-07-04T23:31:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-07-04:pages/2014/07/04/sublime_text_2_and_verilog.html</id><summary type="html">&lt;h2 id="sublime-text"&gt;Sublime Text&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;代码编辑器之于程序员，就如同剑之于战士。程序员关于代码编辑器的争论从来就没有停止过，每个程序员都有自己熟悉的编辑器，他们热爱自己的 “武器”，甚至可以形成 “宗教”，比如 Vim 和 Emac 的战争。&lt;/p&gt;
&lt;p&gt;如今，这个无休止的争论中要加入一个新成员了，她就是 &lt;a href="http://www.sublimetext.com/"&gt;Sublime Text&lt;/a&gt; 。其实她也不是 “新” 成员了，早在 2011 年她就诞生了，不过经过不断的改进，终于人们不得不正视这个新人，不仅仅因为漂亮的外在美，还有强大的内在美 :-P&lt;/p&gt;
&lt;p&gt;个人感觉，ST 的出现恰到好处，她兼具了 Vim 的强大功能和普通编辑器的易用性。虽然 Vim 轻巧、强大，但是 Vim 的门槛比较高，要想用好 Vim 是需要长期练习的，而 ST 可以说是老少皆宜，你是小白，不会用 Vim？没关系，她可以像普通的编辑器一样，即使你 0 基础也可以使用；你是老手，习惯 Vim？也没关系，她可以 &lt;strong&gt;开启 Vim 模式&lt;/strong&gt;，还是原来的配方，还是熟悉的味道～&lt;/p&gt;
&lt;p&gt;虽然她不是开源项目，有收费，但是我们有免费无限制无限期的试用权，而且她绿色小巧，不用安装，解压即可使用，跨平台，支持各种编程语言的代码补全和语法高亮。如果对现有的插件不满意，我们甚至可以自己定制插件。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;简单说一下我在使用过程中的一些问题，更加详细的使用官方和非官方的网站上都有详细的说明，还有别人总结的技巧请自行 Google。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.sublimetext.com/docs/2/index.html"&gt;Official docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/sublime-text-2/"&gt;Unofficial docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.iplaysoft.com/sublimetext.html"&gt;Others: Sublime Text 2 - 性感无比的代码编辑器！程序员必备神器！跨平台支持Win/Mac/Linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P.S. 我使用的是 Sublime Text 2，虽然已经有 3 了，但是 3 还在 Beta 阶段，大家貌似对 3 不是很满意&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="vim-mode"&gt;Vim Mode&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;ST 是自带 Vim 模式的（Vintage Mode），但是这个模式默认是没有开启的，毕竟对于大多数普通人来说， Vim 实在是不太友好...&lt;/p&gt;
&lt;p&gt;打开 ST 的 &lt;code&gt;Preferences/Setting - Defalut&lt;/code&gt;，在最后一行有句&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="s"&gt;&amp;quot;ignored_packages&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Vintage&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只需要将方括号中的 Vintage 去掉就可以了。推荐在 Setting - User 中修改。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.sublimetext.com/docs/2/vintage.html"&gt;官方说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="package-control"&gt;Package Control&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;ST 的一个强大之处就在于可以安装各种插件，要安装插件有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;手动下载，解压到指定目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 &lt;code&gt;Package Control&lt;/code&gt; 插件，自动管理安装插件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一种方法虽然麻烦，但是在没有网络的环境下，我们可以从别人那拷贝过来即可；第二种方法最方便了，不过要求有网络。&lt;/p&gt;
&lt;h3 id="installation"&gt;Installation&lt;/h3&gt;
&lt;p&gt;ST 默认是没有安装 Package Control 的，需要我们手动安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl ~&lt;/code&gt; 调出控制台&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在控制台中粘贴以下命令&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Package&lt;/span&gt; &lt;span class="n"&gt;Control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sublime&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sublime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;installed_packages_path&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;makedirs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;None&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;install_opener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build_opener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ProxyHandler&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ipp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;wb&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//sublime.wbond.net/&amp;#39;+pf.replace(&amp;#39; &amp;#39;,&amp;#39;%20&amp;#39;)).read()); print &amp;#39;Please restart Sublime Text to finish installation&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装完成之后，重启 ST 即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="using"&gt;Using&lt;/h3&gt;
&lt;p&gt;按下 &lt;code&gt;Ctrl + Shift + P&lt;/code&gt;，在弹出的命令面板，输入 &lt;code&gt;package&lt;/code&gt;，就会自动弹出相关的命令，可以选择 &lt;code&gt;Install&lt;/code&gt;、&lt;code&gt;Remove&lt;/code&gt;、&lt;code&gt;Disable&lt;/code&gt;、&lt;code&gt;Enable&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Update&lt;/code&gt; 等命令。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sublime.wbond.net/"&gt;sublime wbond&lt;/a&gt; 上列出了 Package Control 可以找到的所有的插件，有详细的安装和使用说明。&lt;/p&gt;
&lt;p&gt;网上也有很多文章介绍了大量的常用插件，我们可以按照需求自己挑选需要的插件进行安装。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="verilog-hdl"&gt;Verilog HDL&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;常用的插件，比如括号匹配、智能补全、自动对齐、Tags、注释生成、Terminal、Build、Git 等插件就不再赘述了，说一下网上介绍的比较少，但我自己使用比较多的关于 Verilog 的插件。&lt;/p&gt;
&lt;p&gt;可以通过 Package 下载到两个插件，&lt;code&gt;Verilog&lt;/code&gt; 和&lt;code&gt;Verilog-Automatic&lt;/code&gt;。第一个插件主要功能是支持 Verilog 的代码高亮和补全，第二个插件可以帮助我们自动生成模块例化、端口添加连接等功能。&lt;/p&gt;
&lt;p&gt;其中，第一个插件的 Snippet 并不太让人满意，在原 Snippet 的基础上，我添加了一些我常用到的 Snippets。&lt;/p&gt;
&lt;h3 id="always"&gt;always&lt;/h3&gt;
&lt;p&gt;因为插件作者只添加了异步高有效复位方式的 &lt;code&gt;always&lt;/code&gt; 块，而我们同步和异步两种方式都可能会用到，所以，我添加同步复位的 Snippet&lt;/p&gt;
&lt;p&gt;ST 2 的 Package 都存放在 &lt;code&gt;/home/.config/sublime-text-2/Packages&lt;/code&gt; 目录下面，我们需要修改的就是这个目录下的 &lt;code&gt;Verilog/Snippets&lt;/code&gt; 下的 &lt;code&gt;.tmSnippet&lt;/code&gt; 文件。修改后的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;always_async.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always @(posedge clk or ${1:posedge} ${2:rst}) begin
    if ($2) begin
        // reset
        $3
    end
    else if ($4) begin
        $0
    end
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_async&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_async&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;always_sync.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always @(posedge clk) begin
    if (${1:rst}) begin
        // reset
        $2
    end
    else begin
        $0
    end
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_sync&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always_sync&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改之后的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="always" src="/images/sublime-text-2-and-verilog/always.gif" /&gt;&lt;/p&gt;
&lt;h3 id="if-else"&gt;if-else&lt;/h3&gt;
&lt;p&gt;原来的 if snippet 没有 else 分支，所以，添加了一个有 else 分支的 if 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if ($1) begin
    $0
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;if-else.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if ($1) begin
    $2
end
else begin
    $0
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if_else&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if_else&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改后的结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="if-else" src="/images/sublime-text-2-and-verilog/if-else.gif" /&gt;&lt;/p&gt;
&lt;h3 id="parameter"&gt;parameter&lt;/h3&gt;
&lt;p&gt;原来是没有 parameter 的snippets 的，拷贝一份其他的 snippet，修改其中的一些设置，即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parameter.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter   $1 = $2,
            $3 = $0
&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改后的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="parameter" src="/images/sublime-text-2-and-verilog/parameter.gif" /&gt;&lt;/p&gt;
&lt;h3 id="case"&gt;case&lt;/h3&gt;
&lt;p&gt;原来是没有 case 的 snippet，方法同上，可以修改出我们想要的 case snippet&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;case.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case ($1)
    $2: begin
        $3
    end
    $4: begin
        $5
    end
    $6: begin
        $7
    end
    $8: begin
        $9
    end
    default: begin
        $10
    end
endcase&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改后的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="case" src="/images/sublime-text-2-and-verilog/case.gif" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上面仅仅说了非常基本的几个设置，和我在写 Verilog 时自己添加的几个 snippet，其他的 ST 的使用技巧官方和非官方的 ref 有非常详细的介绍，另外其他人也有很多文章介绍～&lt;/p&gt;</summary><category term="FPGA"></category><category term="Sublime Text"></category></entry><entry><title>FPGA 中的复位设计</title><link href="http://guqian110.github.io/pages/2014/06/20/the_art_of_reset_design_in_fpga.html" rel="alternate"></link><updated>2014-06-20T00:22:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-06-20:pages/2014/06/20/the_art_of_reset_design_in_fpga.html</id><summary type="html">&lt;p&gt;复位信号在系统中的地位和时钟信号几乎同等重要，我们想尽量把系统设计为可控，那么最基本的控制信号就是复位信号了。&lt;/p&gt;
&lt;p&gt;复位信号的设计需要考虑的因素，各种书刊、论文、白皮书、网上论坛都有相关讨论，但是至今对于给定 FPGA 设计中使用哪种复位方案仍然没有明确答案。本文总结了一些大神的经典论文和网上的许多博客，尽可能用简单的图说明选择某种设计方案及其理由，涉及的更深入的原理请自行 Google :-P&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="think-local-or-think-global"&gt;Think Local or Think Global&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Xilinx 有个 White Paper，&lt;a href="http://www.xilinx.com/support/documentation/white_papers/wp272.pdf"&gt;Get Smart About Reset: Think Local, Not Global&lt;/a&gt;，提出一种新的复位思路： 能不用全局复位时，尽量不要使用。&lt;/p&gt;
&lt;p&gt;这个原则和我们平时的理解和习惯是相反的，不使用全局复位的原因主要有三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;随着时钟速率的提高，GSR 逐渐变为时序关键路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果电路中没有反馈环路，那么上电初始化已经足够了，很多设计中的 reset 信号都可以省去&lt;/p&gt;
&lt;p&gt;如果没有反馈环路，比如移位寄存器，即使开始状态是错误的，当数据流进入到一段时间，错误数据将被冲刷出去，所以没有必要保留 reset 信号。如果系统中有反馈环路，比如状态机，当初始状态不对或者状态跑飞时，无法回到正常状态，那么 reset 信号是有必要保留的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码中简单的添加一个 reset 端口，在底层实现时要消耗很多我们想不到的资源。&lt;/p&gt;
&lt;p&gt;全局复位会和设计中的其他单元竞争布线资源，全局复位一般来说肯定有非常高的扇出，因为它需要连接到设计中的每一个 FF。这样，它会消耗大量的布线资源，使芯片利用率下降，同时也会影响时序性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，有必要使用其他的不依靠全局复位的方法。&lt;/p&gt;
&lt;p&gt;如图所示，Xilinx FPGA 在配置/重配置的时候，每个 FF 和 BRAM 都会被初始化一个预先设定的值(大部分器件的默认值是 0, 也有例外)，所以，上电配置和全局复位有着类似的功能，将每个存储单元配置为一个已知的状态。&lt;/p&gt;
&lt;p&gt;&lt;img alt="configuration" src="/images/the-art-of-reset-design-in-fpga/configuration.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;系统在上电配置时，内部有个信号叫 &lt;code&gt;GSR&lt;/code&gt; (Global Set/Reset)，它是一种特殊的预布线的复位信号，能够在 FPGA 配置的过程中让设计保持初始状态。在配置完成后，GSR 会被释放，所有的触发器及其它资源都加载的是 INIT 值。除了在配置进程中运行 GSR，用户设计还可以通过实例化 STARTUP 模块并连接到 GSR 端口的方法来访问 GSR 网。使用该端口，设计可以重新断言 GSR 网，相应地 FPGA 中的所有存储元件将返回到它们的 INIT 属性所规定的状态。&lt;/p&gt;
&lt;p&gt;设定初值的语法很简单，只需要在定义变量时给它初始值就可以了：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和 reg 类似，BRAM 也可以在配置的时候初始化，随着嵌入式系统的 BRAM 逐渐增大，BRAM 初始化非常有用：因为预先定义 RAM 的值可以使仿真更容易，而且无需使用引导顺序为嵌入式设计清空内存。&lt;/p&gt;
&lt;p&gt;使用 GSR 的好处是 可以解决复位信号高扇出的问题，因为 GSR 是预布线的资源，它不占用每个 FF 和 Latch 的 set/reset 端口，如下图所示。很多资料都推荐将设计中的 reset 按钮连接到 GSR，以利用它比较低的 skew。&lt;/p&gt;
&lt;p&gt;&lt;img alt="gsr rset" src="/images/the-art-of-reset-design-in-fpga/gsr_reset.gif" /&gt;&lt;/p&gt;
&lt;p&gt;既然 GSR 这么好，那么是不是只使用 GSR 就可以了，不必再用 FF 和 Latch 的 set/reset 端口了呢？&lt;/p&gt;
&lt;p&gt;答案当然是否定的。由于 GSR 的释放是异步方式，所以，如果我们只使用 GSR 作为系统的唯一复位机制，那么可能导致系统不可靠。所以还是需要显示的使用同步复位信号来复位状态机、计数器等能自动改变状态的逻辑。&lt;/p&gt;
&lt;p&gt;所以，应该使用 &lt;strong&gt;GSR + explict reset&lt;/strong&gt; 的解决方案&lt;/p&gt;
&lt;p&gt;给系统中的 reg 赋初值，对于没有环路的电路节省 reset，利用 GSR 实现复位的功能；对于有环路的电路，使用显示的复位信号。&lt;/p&gt;
&lt;h3 id="upate-07012014"&gt;Upate: 07/01/2014&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关于 initialize 代替 reset&lt;/p&gt;
&lt;p&gt;这几天看 resest 相关问题时，又在 &lt;code&gt;stackoverflow&lt;/code&gt; 上发现一个关于&lt;a href="http://stackoverflow.com/questions/6363130/is-there-a-reason-to-initialize-not-reset-signals-in-vhdl-and-verilog"&gt;是否应该使用 initialize 代替 reset 的问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;支持用 initialize 代替 reset 的人提出的方案是尽量不要使用全局复位信号，使用初始化值代替复位，对于一些必须要求复位的模块，使用 &lt;em&gt;local&lt;/em&gt; 的复位信号。&lt;/p&gt;
&lt;p&gt;反对者认为，用 initialize 代替 reset 的想法只是学院派的不切实际的想法。一般只有基于 SRAM 的 FPGA 才会使用到初始化。而这样做的目的只是为了节省布线资源，降低时序要求，但是现代 FPGA 有很多布线资源和没有使用的全局网络，所以，复位信号一般不是时序关键路径。即使遇到问题，可以通过手动例化一个时钟 BUF 来解决。使用这种无复位的设计虽然在某些情况是可行的，但是当你把你的设计和其他系统连接起来时，通常会感到非常痛苦，因为大多数系统都会要求有个复位信号。在由 FPGA 转 ASIC 时也比较方便，因为只有基于 SRAM 的 FPGA 才可以使用这种 initialize 代替 reset 的技术，而 ASIC 不行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于 GSR&lt;/p&gt;
&lt;p&gt;网上有很多人都推荐将我们用户定义的复位信号连接到 GSR 信号上，以便利用 GSR 提供的低抖动性，包括下面提到的一篇文章 &lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 也推荐使用 GSR 信号。但是在 Xilinx 的另一份文档 &lt;a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/sim.pdf"&gt;UG626: Synthesis and Simulation Design Guide&lt;/a&gt; 中说不推荐使用 GSR 来作为系统的复位&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although you can access the GSR net after configuration, Xilinx does not recommend using the GSR circuitry in place of a manual reset. This is because the FPGA devices offer high-speed backbone routing for high fanout signals such as a system reset. This backbone route is faster than the dedicated GSR circuitry, and is easier to analyze than the dedicated global routing that transports the GSR signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而这个矛盾早就有人在 Xilinx Forum 上提问了 &lt;a href="http://forums.xilinx.com/t5/Virtex-Family-FPGAs/What-does-GSR-signal-really-mean-and-how-should-I-handle-the/td-p/35610"&gt;What does GSR signal really mean and how should I handle the reset signal properly&lt;/a&gt;，还有 &lt;a href="http://forums.xilinx.com/t5/Archived-ISE-issues/FPGA-Power-On-Reset/m-p/7027?query.id=134602#M2035"&gt;FPGA Power On Reset!&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt; Conclustion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下，应该优先选择有全局复位的设计方案，并且这个全局复位信号是用户定义的，不要使用 GSR 。&lt;/p&gt;
&lt;p&gt;P.S. 事实上没有一个通用的、适合所有器件的复位方案，我们应该首先了解所使用的器件和工具，针对它们的特点进行复位方案的设计。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="shift-register-reset"&gt;Shift Register Reset&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;并不是每一个设计，器件中的每一个寄存器都需要复位的。最好的做法是只将复位连接到那些需要复位的寄存器。&lt;/p&gt;
&lt;p&gt;如果一个模块内部含有一组触发器(移位寄存器)，这些寄存器可以分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;resetable flip-flops&lt;/p&gt;
&lt;p&gt;第一个 ff，它是需要复位信号的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;follower flip-flops&lt;/p&gt;
&lt;p&gt;后续的 ff，仅作为简单的数据移位寄存器，不含复位端&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么在设计时应该只复位第一个触发器，后续的触发器仅作为数据寄存器使用，不能对它们进行复位。
这里体现出来的一个原则就是：能节省 reset 时，尽量节省。&lt;/p&gt;
&lt;p&gt;原因就是 reset 作为一个实际存在的物理信号，需要占用 FPGA 内部的 route 资源，往往 reset 的fanout 又多得吓人。这就很容易造成 route 难度上升，性能下降，编译时间增加。因此，在 FPGA 设计中能省略的复位应尽量省略。&lt;/p&gt;
&lt;h3 id="principle"&gt;Principle&lt;/h3&gt;
&lt;p&gt;每个 &lt;code&gt;always&lt;/code&gt; 模块只对一种 FF 建模。也就是说，不要把这两种 FF 写在同一个 always 块中。&lt;/p&gt;
&lt;h3 id="code"&gt;Code&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Bad Style:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;BADSTYLE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如图，复位信号 &lt;code&gt;rst&lt;/code&gt; 对于第二个 ff 来说，是一个片选信号 &lt;code&gt;ce&lt;/code&gt;，这样的设计产生额外的逻辑，是不好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="bad style" src="/images/the-art-of-reset-design-in-fpga/bad_style.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Good Style:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;GOODSTYLE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如图，复位信号 &lt;code&gt;rst&lt;/code&gt; 对于两个 ff 来说，都是复位信号，不需要额外的逻辑，这样的设计是比较好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="good style" src="/images/the-art-of-reset-design-in-fpga/good_style.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="reset-distribution-tree"&gt;Reset Distribution Tree&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;复位信号的 &lt;code&gt;reset distribution tree&lt;/code&gt; 和 时钟信号的 &lt;code&gt;clock distribution tree&lt;/code&gt; 差不多同等重要，因为在设计中，几乎每个器件都有时钟端口和复位端口(同步/异步)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reset distribution tree&lt;/code&gt; 和 &lt;code&gt;clock distribution tree&lt;/code&gt; 最大的区别就是它们对 &lt;code&gt;skew&lt;/code&gt; 的要求不同。不像时钟信号的要求那么严格，复位信号之间的 skew 不需要那么严格，只要复位信号的延迟足够小，满足能在一个时钟周期内到达所有的复位负载端，并且满足各个寄存器和触发器的 &lt;code&gt;recovery time&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下图所示的方案是使用 时钟树 的一个叶子分支来驱动 &lt;code&gt;Reset Synchronizer&lt;/code&gt;。但是，大多数情况下，时钟频率都比较高，叶子分支的时钟无法在一个时钟周期内，既要穿过时钟树，还要驱动 &lt;code&gt;Reset synchroinzer&lt;/code&gt;，然后再将得到的复位信号穿过 复位树，输入到负载端口。&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree driven delayed clock" src="/images/the-art-of-reset-design-in-fpga/reset_tree_delayed_clock.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了加速 reset 信号到达触发器，触发器使用的时钟与 reset 信号是并行的。如图所示。但是，这时候 reset 和 clock 是异步的，所以必须在 &lt;code&gt;PAR&lt;/code&gt; 之后进行 &lt;code&gt;STA&lt;/code&gt;，保证异步复位信号释放(release)和使能(enable)时满足 &lt;code&gt;建立时间(setuo time)&lt;/code&gt; 和 &lt;code&gt;保持时间(hold time)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree driven delayed clock" src="/images/the-art-of-reset-design-in-fpga/reset_tree_parallel_clock.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="reset-glitch-filtering"&gt;Reset Glitch Filtering&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;使用异步复位信号时，考虑到异步复位信号对毛次比较敏感，所以在一些系统中需要处理毛次，下图显示了一种简单但是比较丑陋的方法(时延不是固定的，会随温度、电压变化)&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset glitch filtering" src="/images/the-art-of-reset-design-in-fpga/reset_glitch_filtering.png" /&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;毛刺 Glitch&lt;/code&gt; 是一个很重要的问题，不论是对于时钟、复位信号还是其他信号，详细讨论待续&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不是所有的系统都需要过滤毛次，设计者要先研究需求，再觉得是否使用延时来过滤毛次&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="multi-clock-reset"&gt;Multi-clock Reset&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;在一个系统中，往往有多个时钟，这时候有必要为每个时钟域分配一个复位信号。&lt;/p&gt;
&lt;p&gt;因为只有一个全局复位的话，它与系统的时钟都没有关系，是异步复位信号，要求这个信号满足所有时钟域的 recovery 和 removal 时序不是一件容易的事情，因为为每个时钟域分配复位是有必要的。&lt;/p&gt;
&lt;p&gt;根据实际情况的不同，有两种方案可以采用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-coordinated reset removal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于多时钟域的设计，很多时候不同时钟域之间复位信号的先后顺序没有要求，尤其是在有 &lt;code&gt;request-acknowledge&lt;/code&gt; 这样握手信号的系统中，不会引起硬件上的错误操作，这时候下图所示的方法就足够了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="non coordinated reset" src="/images/the-art-of-reset-design-in-fpga/non_coordination.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sequenced coordination of reset removal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一些设计，要求复位信号的释放顺序有一定顺序，这时候应该使用下图所示的方法&lt;/p&gt;
&lt;p&gt;&lt;img alt="sequenced rcoordination" src="/images/the-art-of-reset-design-in-fpga/sequenced_coordination.png" /&gt;&lt;/p&gt;
&lt;p&gt;Xilinx 的杂志上的一篇文章，&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt;，作者 Srikanth Erusla-gandi 是 Xilinx 的员工和培训人员。他在文中提供了一张图来说明典型的系统复位方案，图中 &lt;code&gt;MMCM&lt;/code&gt; 的 &lt;code&gt;lock&lt;/code&gt; 和外部输入的复位信号相与，目的是为了保证提供给后面的同步器的时钟信号是稳定的；每个时钟域都有一个同步器来同步复位信号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="typical reset implementation in FPGA" src="/images/the-art-of-reset-design-in-fpga/typical_reset.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="understanding-the-flip-flop-reset-behavior"&gt;Understanding the flip-flop reset behavior&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;在开始详细讨论之前，首先得理解 FPGA 的基本单元 Slice 中的 FF 的复位方式。Xilinx 的 Virtex 5 系列的芯片中的 FF 的类型都是 DFF (D-type flip flop)，这些 DFF 的控制端口包括一个时钟 CLK，一个高有效的使能 CE，一个高有效的置位/复位 SR。这个 SR 端口可以配置为同步的置位/复位，也可以配置为异步方式的置位/复位。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="dff" src="/images/the-art-of-reset-design-in-fpga/dff.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;我们写的 RTL 代码也会影响最终综合出来的 FF 类型。&lt;/p&gt;
&lt;p&gt;如果代码的敏感列表中包含了复位信号，那么就会综合出一个异步复位的 DFF，SR 端口将被配置为置位或者复位端口(FDPE &amp;amp; FDCE primitive)。当 SR 变高时，FF 的输出值立即变为代码中的复位时设定的值 SRVAL。&lt;/p&gt;
&lt;p&gt;同理，如果代码的敏感列表中不包含复位信号，那么就会综合出一个同步复位的 DFF，SR 端口将被配置为置位/复位端口(FDSE &amp;amp; FDRE primitive)。当 SR 变高时，FF 的输出值在下一个时钟的上升沿变为 SRVAL。&lt;/p&gt;
&lt;p&gt;如果我们在定义 reg 变量时给它一个初始值，那么 FPGA 在上电配置(GSR 变高)时，载入这个值。&lt;/p&gt;
&lt;p&gt;虽然 FPGA 的 FF 可以配额为 preset/clear/set/reset，但是一个单独的 FF 每次只能配置为其中的一种，如果在代码中多于一个 preset/clear/set/reset，那么就会产生其他的逻辑，消耗 FPGA 资源。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="active-low-vs-active-high"&gt;Active low  V.S.  Active high&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;大多数书籍和博客都推荐使用 “异步复位，低电平有效” 的复位方案，却没有明确说明为什么使用 “低电平有效”。&lt;/p&gt;
&lt;p&gt;目前大多数书籍中都使用 低电平复位，网上给出的理由是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ASIC 设计大多数是低电平复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大多数厂商使用低电平复位多一些 (Xilinx 基本全是高电平复位，这也叫大多数？)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低电平复位方式，在上电时系统就处于复位状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是从我找到的资料来看， Xilinx 的器件全部是高电平复位端口，他们的 white paper 中的例子也都是高电平复位方式。而且，从综合结果来看，如果非要使用低电平复位，那么就会额外添加一个反相器，然后将反向得到的高电平连接到 FF 的复位端口，从而导致复位信号的传输时延增加，芯片的利用率下降，同时会影响到时序和功耗。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 中也证实了这一点，文中提到对于 Xilinx 器件，尽可能使用高有效复位，如果实在没有办法控制系统的复位极性，那么最好在系统的顶层模块中将输入的低有效复位翻转极性，这样做的好处是反向器将被吸收到 IO logic 中，不会消耗 FPGA 内的逻辑和布线资源。&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;应该参考器件决定使用那种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 Xilinx 器件，应该使用高电平复位方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="synchronous-vs-asynchronous"&gt;Synchronous V.S. Asynchronous&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id="synchronous-reset"&gt;Synchronous Reset&lt;/h3&gt;
&lt;p&gt;模块的 &lt;code&gt;sensitivity list&lt;/code&gt; 中不包含 &lt;code&gt;rst&lt;/code&gt; 信号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sync reset" src="/images/the-art-of-reset-design-in-fpga/sync_reset.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;fdr&lt;/code&gt; 是 Xilinx 的原语，表示 &lt;code&gt;Singal Data Rate D Flip-Flop with Synchronous Reset and Clock Enable (posedge clk)&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and&lt;/span&gt;
&lt;span class="c1"&gt;//       Clock Enable (posedge clk).&lt;/span&gt;
&lt;span class="c1"&gt;//       All families.&lt;/span&gt;
&lt;span class="c1"&gt;// Xilinx HDL Language Template, version 13.3&lt;/span&gt;

&lt;span class="no"&gt;FDRE&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Initial value of register (1&amp;#39;b0 or 1&amp;#39;b1)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;FDRE_inst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Data output&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Clock input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;    &lt;span class="c1"&gt;// 1-bit Clock enable input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;R&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;R&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Synchronous reset input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 1-bit Data input&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// End of FDRE_inst instantiation&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有时候，有些器件不带同步复位专用端口，这时候一般会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。&lt;/p&gt;
&lt;h4 id="advantage"&gt;Advantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保证设计是 100% 同步，有利于时序分析，也利于仿真&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降低亚稳态出现的几率，时钟起到过滤毛刺的作用(如果毛刺发生在时钟沿附近，那么仍然会出现亚稳态的问题)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在某些设计中，复位信号是由内部逻辑产生的，推荐使用同步复位，因为这样可以避免逻辑产生的毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="disadvantage"&gt;Disadvantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;同步复位需要保证复位信号具有一定的脉冲宽度(脉冲延展器)，使其能被时钟沿采样到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在仿真过程中，同步复位信号可能被X态掩盖(?不懂...)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果设计中含有三态总线，为了防止三态总线的竞争，同步复位的芯片必须有一个上电异步复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果逻辑器件的目标库内的 FF 只有异步复位端口，那么使用同步复位的话，综合器会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。&lt;/p&gt;
&lt;p&gt;有很多教材和博客都直接说 “同步复位会产生额外的逻辑资源”，可能他们是基于 Altera 的 FPGA 这么做的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="extra logic" src="/images/the-art-of-reset-design-in-fpga/extra_logic.png" /&gt;&lt;/p&gt;
&lt;p&gt;但是根据我实际的测试结果，对于 Virtex 5 系列的芯片，它的原语里面已经含有各种带同步、异步复位端口的 FF，ISE 自带的 XST 也已经很智能了，它会根据代码分析，自动选择合适的 FF。所以上面同步复位综合出来的 RTL Schematic 中没有所谓的 “多余的逻辑资源”。&lt;/p&gt;
&lt;p&gt;所以，是否占用多余的资源，还得针对具体的板子分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="asynchronous"&gt;Asynchronous&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="aync reset" src="/images/the-art-of-reset-design-in-fpga/async_reset.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;fdc&lt;/code&gt; 是 Xilinx 的原语，表示 &lt;code&gt;Single Data Rate D Flip-Flop with Asynchronous Clear and Clock Enable (posedge clk)&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and&lt;/span&gt;
&lt;span class="c1"&gt;//       Clock Enable (posedge clk).&lt;/span&gt;
&lt;span class="c1"&gt;//       All families.&lt;/span&gt;
&lt;span class="c1"&gt;// Xilinx HDL Language Template, version 13.3&lt;/span&gt;

&lt;span class="no"&gt;FDCE&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Initial value of register (1&amp;#39;b0 or 1&amp;#39;b1)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;FDCE_inst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Data output&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;C&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Clock input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;    &lt;span class="c1"&gt;// 1-bit Clock enable input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;CLR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CLR&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  &lt;span class="c1"&gt;// 1-bit Asynchronous clear input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 1-bit Data input&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// End of FDCE_inst instantiation&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;异步复位的优缺点和同步复位是相对应的：&lt;/p&gt;
&lt;h4 id="advantage_1"&gt;Advantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;脉冲宽度没有限制，可以快速复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EDA 工具 route 起来更容易，对于大型设计，能显著减少编译时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有时钟的时候也可以将电路复位 (比如省电模式下，同步复位无法工作，而异步复位是可以的)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无需额外的组合逻辑 (同上，具体分析)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="disadvantage_1"&gt;Disadvantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不是同步电路，不利于时序分析，设计者要正确约束异步复位信号比同步复位复杂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复位信号容易收到毛刺的干扰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容易在复位信号撤销的时候(release)不满足 &lt;code&gt;removal time&lt;/code&gt; 时序要求，从而产生亚稳态 (关于亚稳态，网上有很多论文、博客都有详细说明)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="reset-synchronizer"&gt;Reset Synchronizer&lt;/h3&gt;
&lt;p&gt;两种复位方式各有优缺点，设计者应该根据实际情况选择合适的复位方法。目前，很多文献书籍中都推荐一种 “异步复位，同步释放” 的方法。这种方法可以将两者结合起来，取长补短。&lt;/p&gt;
&lt;p&gt;它的原理如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset synchronizer" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer.png" /&gt;&lt;/p&gt;
&lt;p&gt;针对 Xilinx 器件，用代码具体实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;SYSRST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sys_rst&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;rst_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;rst_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;sys_rst&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;sys_rst&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset synchronizer" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_rtl.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;rst_pb&lt;/code&gt; 是系统的复位按钮，&lt;code&gt;sys_rst&lt;/code&gt; 是同步化的结果。前面的原理图是按照低有效复位说明的，而 Xilnx 的 FPGA 都是高有效复位，所以综合出的 RTL 图则正好相反，复位按钮接到了 FF 的置位端，第一级 FF 的输入也由 &lt;code&gt;Vcc&lt;/code&gt; 变为 &lt;code&gt;GND&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 也证实了前面的 RTL Schematic 没有错：&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset_synchronizer_xilinx" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_xilinx.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Simulation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="simulation" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_simulation.png" /&gt;&lt;/p&gt;
&lt;p&gt;所谓 “异步复位”，如上图(由于连接到了置位端，叫 “异步置位” 更合适)，一旦复位信号 &lt;code&gt;rst_pb&lt;/code&gt; 有效，那么输出端口 &lt;code&gt;sys_rst&lt;/code&gt; 立即被置为 &lt;code&gt;1&lt;/code&gt;，否则输出为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所谓 “同步释放”。如上图，当复位信号 &lt;code&gt;rst_pb&lt;/code&gt; 释放时(从有效变为无效)，输出端口 &lt;code&gt;sys_rst&lt;/code&gt; 不是立即变化，而是被 FF 延迟了一个时钟输出，从而使其和时钟同步化。这个和时钟同步化的复位信号可以有效的驱动后面的逻辑，避免亚稳态。&lt;/p&gt;
&lt;p&gt;可以看到，所谓的这种 “异步复位，同步释放” 的方法，其本质就是要 &lt;strong&gt;利用异步复位来产生一个同步复位的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么不直接使用异步复位呢？因为异步复位容易产生亚稳态的问题。&lt;/p&gt;
&lt;p&gt;为什么不直接使用同步复位呢？因为很多器件只有异步复位端口，不支持同步复位端口，如果要使用同步复位，就会产生额外的逻辑，消耗资源。&lt;/p&gt;
&lt;p&gt;所以，这种方法的根本思想就是 &lt;strong&gt;异步信号同步化&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id="conclusion"&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;知道了这点，选择复位信号的策略就很明显了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尽可能使用同步复位，保持设计 “同步化”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果器件本身是带有同步复位端口的，那么在写代码时就直接使用同步复位就可以了(CummingsSNUG2002SJ 也说了如果如果生产商提供同步复位端口，那么使用异步复位是毫无有点的。Xilinx 就是个例子，它所有的芯片都带有同步/异步复位端口)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不带有同步复位端口，那么就需要使用这种异步复位同步化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_Resets.pdf"&gt;Synchronous Resets? Asynchronous Resets? I am so confused! How will I ever know which to use?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2003Boston_Resets.pdf"&gt;Asynchronous &amp;amp; Synchronous Reset Design Techniques - Part Deux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.xilinx.com/support/documentation/white_papers/wp272.pdf"&gt;Get Smart About Reset: Think Local, Not Global&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I rest my FPGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eefocus.com/coyoo/blog/13-12/301045_9c39f.html"&gt;FPGA复位电路的实现及其时序分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4893454/"&gt;深入浅出玩转 FPGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://item.jd.com/11337565.html"&gt;100 Power Tips for FPGA Designers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379"&gt;Advanced FPGA Design by Steve Kilts&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="reset"></category></entry></feed>