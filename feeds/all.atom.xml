<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Coding Life</title><link href="http://guqian110.github.io/" rel="alternate"></link><link href="http://guqian110.github.io/feeds/all.atom.xml" rel="self"></link><id>http://guqian110.github.io/</id><updated>2014-06-13T20:31:00+08:00</updated><entry><title>学习 Arduino #3 Intel Galileo Linux</title><link href="http://guqian110.github.io/pages/2014/06/13/learning_arduino_series_3_intel_galileo_linux.html" rel="alternate"></link><updated>2014-06-13T20:31:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-06-13:pages/2014/06/13/learning_arduino_series_3_intel_galileo_linux.html</id><summary type="html">&lt;h2&gt;Linux on Galileo Board&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Galileo 不是简单的 Arduino 板子，实际上它运行着一个 Linux 操作系统。把它看作是 “兼容 Arduibo 接口的板子” 或许更合适一些。&lt;/p&gt;
&lt;p&gt;Galileo 板子上容量为 8 MB 的 SPI Flash 中已经烧写了一个精简版的 Linux 系统，因为容量的限制，这个系统去掉了一些不常用的模块，比如 wi-fi 驱动，python 支持等。&lt;/p&gt;
&lt;p&gt;Galileo 也支持从 SD 卡启动系统，并且 Intel 提供了一个基于 Yocto 项目，已经制作好的完整版 Linux 系统。当精简版系统不能满足我们的要求时（添加外设等），我们可以下载这个完整版系统镜像，烧录到 SD 卡中，并从 SD 卡中启动即可。（也可以自己基于 Yocto 项目按照自己的需求制作系统镜像）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我们并不仅仅满足于通过 Arduino IDE 对 Galileo 进行操作，放着一个操作系统，为什么不去使用呢：-P 那么怎么才能登录到这个 Linux 系统中呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Using Ethernet&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Intel 论坛的一个帖子列举了几种登录到 Galileo Linux 的方法&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/thread/46335"&gt;Connecting to Galileo via Linux Console&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use the UART connector&lt;/li&gt;
&lt;li&gt;Use the LAN connection direct to your PC&lt;/li&gt;
&lt;li&gt;Use the LAN connection and connect to your local network &lt;/li&gt;
&lt;li&gt;You can also connect using WiFi&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考虑到我们目前有的材料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Galileo 开发板&lt;/li&gt;
&lt;li&gt;Galileo 电源&lt;/li&gt;
&lt;li&gt;micro USB 线&lt;/li&gt;
&lt;li&gt;5 类网线&lt;/li&gt;
&lt;li&gt;运行着 Linux (Ubuntu) 的 PC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为没有串口线，所以我们采用第 2 种方案，即直接连接 PC 和 Galileo，通过 Ethernet 登录。&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;Galileo 默认是不开启 &lt;code&gt;Lan&lt;/code&gt; 的，也不开启 &lt;code&gt;Telnet&lt;/code&gt; 服务，所以我们需要做的事就是写一个 &lt;code&gt;sketch&lt;/code&gt;，启动 Lan 连接服务和 Telnet 服务，然后分别给 PC 和 Galileo 一个属于同一子网的静态 IP 地址，这样就可以使用 PC 通过 Telnet 协议登录到 Galileo 上的 Linux 系统中。&lt;/p&gt;
&lt;h3&gt;Setp 1: Write sketch&lt;/h3&gt;
&lt;p&gt;代码需要完成的功能一共有 3 个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开启 telnet 服务&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;telnetd -l /bin/sh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 IP 地址&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ifconfig eth0 169.254.1.1 netmask 255.255.0.0 up&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将板子的以太网配置状态显示在 serial monitor 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ifconfig eth0 &amp;gt; /dev/ttyACM0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;全部代码如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// put your setup code here, to run once:&lt;/span&gt;
  &lt;span class="c1"&gt;// Initial serial prot&lt;/span&gt;
  &lt;span class="n"&gt;Serial&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9600&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;// Start telnet service on board&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;telnetd -l /bin/sh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;// Assign the IP address &amp;#39;169.254.1.1&amp;#39; to it&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ifconfig eth0 169.254.1.1 netmask 255.255.0.0 up&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// put your main code here, to run repeatedly: &lt;/span&gt;
  &lt;span class="c1"&gt;// Show the IP detial in the serial monitor of IDE&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ifconfig eth0 &amp;amp;&amp;gt; /dev/ttyGS0 &amp;amp;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Step 2: Connect，Upload&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网线直连 PC 和 Galileo，设置 PC 的 IP 地址为 &lt;code&gt;link-local only&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc_ethernet_config" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_ethernet_config.png" /&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给 Galileo 供电&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接 USB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 Arduino IDE，&lt;code&gt;Upload&lt;/code&gt; 上面的 sketch&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Step 3: Login&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开 IDE 的 serial monitor，可以看到 Galileo 的 ethernet 配置信息&lt;/p&gt;
&lt;p&gt;&lt;img alt="galileo_ethernet_quary" src="/images/learning-arduino-series-3-intel-galileo-linux/galileo_ethernet_quary.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 PC 的网络配置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ifconfig&lt;/span&gt; &lt;span class="n"&gt;eth0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查询结果&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc_ethernet_quary" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_ethernet_quary.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 PC 的终端 Terminal，使用 telnet 登录&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;telnet&lt;/span&gt; &lt;span class="mf"&gt;169.254.1.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;登录结果，如图&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc_ethernet_login" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_telnet_login.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这个精简版的 Linux 系统是不支持 Python 的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Using UART&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;About serial port&lt;/h3&gt;
&lt;p&gt;如果有串口线的话，我们也可以通过串口来登录，包括 SPI 和 SD 卡上的系统。&lt;/p&gt;
&lt;p&gt;关于串口线，说明一下。估计是为了节省板子的面积，Intel 在板子上设置的是音频接口(AV jack)，所以，这里需要额外的一个将音频接口转接为串口的器件。有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上网买一个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自己 DIY 一个&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果上网买的话，注意 Galileo 用的是 RS232 电平，不要买错成 TTL 电平的。如果是自己 DIY 的话，Intel Galileo Get Started 里面有介绍串口线的接法，他们的论坛上也有相关的讨论：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/message/208448#208448"&gt;UART cable pin-out&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pinouts.ru/SerialPorts/Serial9_pinout.shtml"&gt;RS 232 DE-9 port&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Linux Platform&lt;/h3&gt;
&lt;p&gt;我在 Ubuntu 下使用的终端软件是 &lt;code&gt;gtkterm&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;Step 1: Burn the full-linux sytem&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Intel 官网提供的完整版 Linux 镜像是基于 &lt;code&gt;Yocto&lt;/code&gt; 项目裁剪出来的，取名叫 &lt;code&gt;Claton&lt;/code&gt;，目前(2014-6-13)的版本号为 &lt;code&gt;1.0.0&lt;/code&gt;，但是这个版本在我的SD卡中是无法启动的，浪费了大量时间，最后终于发现 &lt;code&gt;0.7.5&lt;/code&gt; 版本可以...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有就是 Get Started 中推荐不要使用 PC 操作系统提供的格式化功能，更好的选择应该是专业格式化软件，比如 &lt;code&gt;SDFormatter&lt;/code&gt;。但是我实际使用时，发现反而是 &lt;code&gt;SDFormatter&lt;/code&gt; 制作的不能启动...&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Step 2: Connect&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入 SD 卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置串口&lt;/p&gt;
&lt;p&gt;选择正确的端口（因为我使用的串口线是 &lt;code&gt;AV-RS232-USB&lt;/code&gt;，所以下面选择的端口是 &lt;code&gt;ttyUSB0&lt;/code&gt;）；&lt;code&gt;Baud Rate = 115200&lt;/code&gt;，&lt;code&gt;Bits =8&lt;/code&gt;，&lt;code&gt;Stopbits = 1&lt;/code&gt;，&lt;code&gt;Parity = none&lt;/code&gt;，&lt;code&gt;Flow control = none&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先不要接 USB 下载线，给板子上电&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Step 3: Login&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这时候我们应该就可以从串口看到板子上电后 &lt;code&gt;grub&lt;/code&gt; 程序和系统启动的相关信息了。&lt;/p&gt;
&lt;p&gt;上电后，&lt;code&gt;grub&lt;/code&gt; 引导启动哪个系统&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm boot information" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_boot_information.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm grub" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_grub.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 SPI Flash 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，这个精简版的系统不支持 &lt;code&gt;python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_login_spi.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 mirco-SD card 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，SD 卡中的系统是支持 &lt;code&gt;python&lt;/code&gt; 的&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_login_sd_card.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Windows Platform&lt;/h3&gt;
&lt;p&gt;我在 Windows 下使用的终端软件是 &lt;code&gt;Putty&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;Step 1: Burn the full-linux system&lt;/h4&gt;
&lt;p&gt;与 Linux 平台下相同。&lt;/p&gt;
&lt;h4&gt;Step 2: Connect&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入 SD 卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置串口&lt;/p&gt;
&lt;p&gt;同样，选择正确的端口和波特率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先不要接 USB 下载线，给板子上电&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Step 3: Login&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这时候我们应该就可以从串口看到板子上电后 &lt;code&gt;grub&lt;/code&gt; 程序和系统启动的相关信息了。&lt;/p&gt;
&lt;p&gt;上电后，&lt;code&gt;grub&lt;/code&gt; 引导启动哪个系统&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm boot information" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_boot_information.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm grub" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_grub.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 SPI Flash 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，这个精简版的系统不支持 &lt;code&gt;python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_login_spi.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 mirco-SD card 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，SD 卡中的系统是支持 &lt;code&gt;python&lt;/code&gt; 的&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_login_sd_card.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Another method&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;如果你觉得插网线、配置 IP 地址太麻烦，甚至懒得自己 DIY 串口线，也没有钱去买一个，别担心，因为 “天空飘来五个字，这都不是事～” 因为你可以借鉴下面这位大神的方法，只需要像下载普通 sketch 一样，将他提供的 sketch 下载到 Galileo 中就可以了，然后通过 IDE 的 serial monitor 就可以登录到 Linux 系统中：&lt;/p&gt;
&lt;p&gt;&lt;a href="(https://communities.intel.com/message/222211)"&gt;Poor man's telnet for Galileo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;他的 sketch 的原理就是使用 &lt;code&gt;system()&lt;/code&gt; 函数将我们在 serial monitor 中的命令传到到 Linux shell 中 ，并将命令的结果返回到 serial monitor 中 。&lt;/p&gt;
&lt;p&gt;不过这种方法的缺点是每个命令传递到 Galileo 后会开辟一个新的进程，当命令执行完返回结果时，这个进程自动结束，所以会产生一些 “问题”：当我们 &lt;code&gt;cd&lt;/code&gt; 到某个子目录后，返回结果之后，我们又回到的之前的目录，举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;home&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;pwd&lt;/span&gt;

&lt;span class="c1"&gt;// result is root dirctory&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决方法就是将命令写在一行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pwd&lt;/span&gt;

&lt;span class="c1"&gt;// result is home directory&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/thread/46335"&gt;Connecting to Galileo via Linux Console&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/docs/DOC-22293"&gt;Tutorial 3: Connecting to Linux through telnet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/message/208564#208564"&gt;Using Galileo Linux over Ethernet(Telnet)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="(https://communities.intel.com/message/222211)"&gt;Poor man's telnet for Galileo&lt;/a&gt;&lt;/p&gt;</summary><category term="Arduino"></category><category term="Linux"></category></entry><entry><title>有限状态机设计</title><link href="http://guqian110.github.io/pages/2014/06/05/fsm_design.html" rel="alternate"></link><updated>2014-06-05T17:55:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-06-05:pages/2014/06/05/fsm_design.html</id><summary type="html">&lt;p&gt;有限状态机是数字电路中经常出现、非常重要的电路，设计一个安全、高效的状态机有一套程序化的方法，我们在数字电路课中就学习过了。搬运以前写的博客，总结一下相关知识，温故而知新～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面的废话：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇博客是在我以前在 CSDN 上写的两篇博客的基础上，参考了其他各位大神、博主的文章，写的总结。欢迎批评、讨论，毕竟写博客的意义就在于给自己一个总结知识的机会、并且在和别人讨论的过程中进步 :-D&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;What is FSM&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Finite-state_machine"&gt;FSM on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有限状态机 (Finite State Machine, FSM)&lt;/strong&gt; 有时候也简称为&lt;strong&gt;状态机 (state machine)&lt;/strong&gt;，它是一种数学模型，通常用来设计电脑程序或者时序电路。它被构思设计为一个抽象的机器，并且某个时刻只能处于一个有限数字代表的状态之下。&lt;/p&gt;
&lt;p&gt;有限状态自动机在很多不同领域中是重要的，包括电子工程、语言学、计算机科学、哲学、生物学、数学和逻辑学。有限状态机是在自动机理论和计算理论中研究的一类自动机。在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。(这里讨论的只限于电子工程里的状态机)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组成元素：&lt;/strong&gt;输入、状态、状态转移条件、输出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态转移图&lt;/li&gt;
&lt;li&gt;状态转移表&lt;/li&gt;
&lt;li&gt;HDL 描述&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;分类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照输出的产生方式，可以将状态机分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Moore_machine"&gt;Moore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="moore diagram" src="/images/fsm-design/moore.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;(&lt;a href="http://homepages.ius.edu/JFDOYLE/c421/html/Chapter8.htm"&gt;图片来源&lt;/a&gt;，homepages.ius.edu)&lt;/p&gt;
&lt;p&gt;一种状态机，它的输出只取决于当前状态，而与输入无关。Moore 状态机最重要的特点就是将输入与输出信号隔离开来，而且输出与时钟信号同步的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Mealy_machine"&gt;Mealy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mealy diagram" src="/images/fsm-design/mealy.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;(&lt;a href="http://homepages.ius.edu/JFDOYLE/c421/html/Chapter8.htm"&gt;图片来源&lt;/a&gt;，homepages.ius.edu)&lt;/p&gt;
&lt;p&gt;另外一种状态机，它的输出不仅和当前状态有关，而且和输入也有关。Mealy 有限状态机对输入的响应发生在当前时钟周期，比 Moore 有限状态机对输入信号的响应要早一个周期。因此，输入信号的噪声可能影响在输出的信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;How to Design a FSM&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;关于如何设计一个状态机，这在数字电路和逻辑设计的书里有详细介绍。简单地总结一下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逻辑抽象，建立原始状态转移图：确定输入、输出、状态变量、画状态转移图&lt;/li&gt;
&lt;li&gt;状态简化，得到最简的状态转移图(卡诺图)&lt;/li&gt;
&lt;li&gt;状态分配，选择编码方案(Binary、Gray、One-Hot)&lt;/li&gt;
&lt;li&gt;画逻辑图，检查能否自启动，得到了最终的状态机模型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;How to implement a FSM&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;当设计好之后，就要使用 HDL 语言来实现这个 FSM 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语言：&lt;/strong&gt; Verilog HDL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综合工具：&lt;/strong&gt; XST (Xilinx Synthesis Tools)&lt;/p&gt;
&lt;p&gt;下面讨论了一些 FSM 实现时需要注意的问题&lt;/p&gt;
&lt;h3&gt;Coding Style&lt;/h3&gt;
&lt;p&gt;状态机一般有三种写法，他们在速度、面积、代码可维护性等各个方面互有优劣。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一段式：&lt;/strong&gt;只有一个always block，把所有的逻辑（输入、输出、状态）都在一个always block中实现；这种写法 &lt;em&gt;看起来很简洁&lt;/em&gt;，但是 &lt;em&gt;不利于维护&lt;/em&gt;。如果状态复杂一些就很容易出错。不推荐这种方法，但是在简单的状态机可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二段式：&lt;/strong&gt;有两个always block，把时序逻辑和组合逻辑分隔开来。时序逻辑里进行当前状态和下一状态的切换，组合逻辑实现各个输入、输出以及状态判断。这种写法 &lt;em&gt;不仅便于阅读、理解、维护，而且利于综合器优化代码，利于用户添加合适的时序约束条件，利于布局布线器实现设计。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在两段式描述中，当前状态的输出用组合逻辑实现，可能存在竞争和冒险，产生毛刺。则要求对状态机的输出用寄存器打一拍，但很多情况不允许插入寄存器节拍，此时使用三段式描述。其优势在于能够根据状态转移规律，在上一状态根据输入条件判断出当前状态的输出，从而不需要额外插入时钟节拍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三段式：&lt;/strong&gt;有三个always block，一个时序逻辑采用同步时序的方式描述状态转移，一个采用组合逻辑的方式判断状态转移条件、描述状态转移规律，第三个模块使用同步时序的方式描述每个状态的输出。&lt;em&gt;代码容易维护，时序逻辑的输出解决了两段式组合逻辑的毛刺问题&lt;/em&gt;，但是从资源消耗的角度上看，&lt;em&gt;三段式的资源消耗多一些，且输出比另外两种会延时一个时钟周期。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;三段式代码模板&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;IDLE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0000_0001&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;WAIT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0000_0010&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;STRT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0000_0100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;  &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;//初始化寄存器，避免生成latch&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="nl"&gt;S1:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="n"&gt;end&lt;/span&gt;
       &lt;span class="nl"&gt;default:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 注意&lt;/span&gt;
       &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// ...          //初始化一组值，避免latch&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;           &lt;span class="c1"&gt;//注意为NS&lt;/span&gt;
            &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;S1:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;default:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="n"&gt;end&lt;/span&gt;
        &lt;span class="n"&gt;endcase&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;一段 or 三段？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说，三段式的效果更好，唯一的缺点是占用的资源稍微多一点(对于拥有丰富的触发器资源的 FPGA 来说，这个缺点可以忽略吧)。所以除非是非常简单的状态机用一段式实现，其他情况下三段式更简单。&lt;/p&gt;
&lt;p&gt;对于上面的三段式模板，按代码顺序解释一下相关的注意事项&lt;/p&gt;
&lt;h3&gt;参数使用 parameter&lt;/h3&gt;
&lt;p&gt;尽量使用 &lt;code&gt;parameter&lt;/code&gt; 而不是 &lt;code&gt;define&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个原则不仅仅限于 FSM，其他模块也应该遵守。因为使用 &lt;code&gt;define&lt;/code&gt; 定义的参数是全局变量，而 &lt;code&gt;parameter&lt;/code&gt; 定义的是局部变量。如果设计中包含多个 FSM，包含多个同名的变量，显然使用 &lt;code&gt;parameter&lt;/code&gt; 是更好的选择。&lt;/p&gt;
&lt;h3&gt;FSM 复位&lt;/h3&gt;
&lt;p&gt;FPGA 上电时，GSR(Global Set/Reset) 拉高，对所有 寄存器/RAM 进行复位，此时配置于 FPGA 的逻辑并未生效，所以不能保证 FSM 进入正确的初始化状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般，FSM 使用其他的复位(同步 or 异步)。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Asynchronous Reset&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有一种方法，是将初始状态编码为全 0 (带 0 的 One-Hot 编码方式)，这样当 GSR 复位后，状态机自动进入初始状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;编码方式&lt;/h3&gt;
&lt;p&gt;状态机的状态的编码，通常有 &lt;code&gt;Binary&lt;/code&gt;、&lt;code&gt;One-Hot&lt;/code&gt;、&lt;code&gt;Gray&lt;/code&gt; 码等几种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Binary 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用最简单的递增的编码方式对状态进行编码，对于 n 个状态的状态机，共需要 log2(n) 个触发器表示所有的状态。&lt;/p&gt;
&lt;p&gt;优点：在状态很多的情况下，可以大大减少触发器的数量，对设计的面积有积极的作用。&lt;/p&gt;
&lt;p&gt;缺点：但是在状态跳转过程中，很可能出现多位同时变化的情况，容易在 next state 的生成逻辑上产生毛刺。同时，输出也是所有状态位的译码，译码逻辑多数很复杂，往往成为整个设计的关键路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gray 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似 Binary，但是采用了格雷码的编码方式，每两个相邻的状态只有一位信号变化。&lt;/p&gt;
&lt;p&gt;有点：避免了 next state 上毛刺的产生。同时两个相邻状态的输出译码变得简单了，避免了复杂组合逻辑的产生。&lt;/p&gt;
&lt;p&gt;缺点；格雷码的这些优点都是建立在状态跳转是顺序执行的基础上的。如果状态机有很多随机跳转和分支，格雷码的实际效果和二进制码相差无几，优势荡然无存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;One-Hot 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前设计中最常用的状态机编码方式。One-Hot 编码在一组 0 中只有一个 1，对一个 n 个状态的 FSM 设计，需要 n 个触发器。&lt;/p&gt;
&lt;p&gt;优点：在任意两个状态之间跳转都只有两位状态位变化，不会产生非常复杂的组合逻辑。各个状态之间的译码也相对简单。&lt;/p&gt;
&lt;p&gt;缺点：对状态编码需要的寄存器比其他方式多，不过这个缺点基本可以忽略吧 :-P&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Binary、Gray 编码使用最少的触发器，较多的组合逻辑。而 One-Hot  编码反之。由于 CPLD 更多的提供组合逻辑资源，而 FPGA 更多的提供触发器资源，所以 CPLD 多使用 Gray，而 FPGA  多使用 One-Hot 编码。另一方面，对于小型设计使用 Gray 和 Binary 编码更有效，而大型状态机使用 One-Hot 更高效。&lt;/p&gt;
&lt;p&gt;(XST 的选项 &lt;code&gt;FSM encoding algorithm&lt;/code&gt; 值默认为 &lt;code&gt;auto&lt;/code&gt;，编写程序测试发现，它会根据代码中状态的多少，FSM 的复杂度，自动选择合适的编码方式对状态进行编码。)&lt;/p&gt;
&lt;h3&gt;安全的 FSM&lt;/h3&gt;
&lt;p&gt;所谓 “安全” 的状态机，就是说即使因为某些意外原因，状态机跑飞了，仍然可以自动回复到正常状态。&lt;/p&gt;
&lt;p&gt;如果我们对状态向量的所有取值情况都显式地进行了说明，那么这个状态机就是安全的，否则就是不安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可能出现的不安全情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，我们在 One-Hot 方式中，对于 8 个状态，总共使用了 8 bit 的寄存器，那么这个状态寄存器向量可以取到的值一共有 &lt;code&gt;2^8 = 256&lt;/code&gt; 种。如果我们只对需要的 8 种状态进行了说明，而忽略了剩余的 248 种，此时综合工具(Synplify、XST)会对设计进行 “优化”，将没有用到的状态去掉。但是，有时候这种 “优化” 反而不好，如果状态机进入未定义的全 0 状态，那么它就会卡在这个未定义的状态，无法自动回复正常工作状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;书写完备的 &lt;code&gt;case&lt;/code&gt; 语句。在代码中对每一种可能的取值对进行描述，对于不使用的状态编码，一定要有 &lt;code&gt;default&lt;/code&gt; 分支进行说明。&lt;/p&gt;
&lt;p&gt;在第二段 &lt;code&gt;always&lt;/code&gt; 中，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;begian&lt;/span&gt;
    &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里应该赋值 &lt;code&gt;8'bx&lt;/code&gt; 更合理，因为状态机上电时处于未知状态，所以应该赋值 &lt;code&gt;x&lt;/code&gt; 更符合实际，但是这样赋值必须有个条件，就是必须所有的状态编码都全部被使用了，不然就会出现锁死现象，FSM 无法返回工作状态。我们前面使用的是 One-Hot 编码方式，有大量无效状态，所以这里不能赋值为 &lt;code&gt;x&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XST支持状态机编码的完备属性 —— &lt;code&gt;case implementation style&lt;/code&gt;，虽然可以打开这个设置，但是一般我们应该在代码中满足条件，而不是依靠综合工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使使用第一种方法，似乎我们的状态机已经是 perfect 了，但是真的是这样么？考虑这种情况：一个状态机有 8 个状态，采用 One-Hot 编码方式，代码含有 &lt;code&gt;default&lt;/code&gt; 分支处理未定义的状态向量可能取到的值。现在把这个状态机放在卫星中，接受宇宙射线的辐射，导致状态向量的值发生了变化，进入了无效状态，然后状态机自动恢复到正常状态(Good Job)，但是！状态机的外围电路并没有随着状态机恢复，它还在等 FSM 输出某个信号呢。所以，仅仅是回到正常状态并不够，最好的设计应该有个错误状态专门来与外围电路通信，当 FSM 自动恢复时，它会通知外围电路 reset 。&lt;/p&gt;
&lt;p&gt;(XST 的选项 &lt;code&gt;safe implementation&lt;/code&gt; 值默认为 &lt;code&gt;None&lt;/code&gt;，如果应用环境要求 FSM 必须能恢复任何错误，比如航天、医疗、汽车等，这时我们可以打开这个设置，这时综合工具会添加额外的逻辑，保证 FSM 可以从无效状态恢复过来。)&lt;/p&gt;
&lt;h3&gt;检查状态完备性&lt;/h3&gt;
&lt;p&gt;在第二个 &lt;code&gt;always block&lt;/code&gt; 中，第一句是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是个很有用的小技巧，它可以帮助我们在综合前发现状态是否完备：如果状态完备，则在下面的 &lt;code&gt;case&lt;/code&gt; 中会给 &lt;code&gt;NS&lt;/code&gt; 合适的值；如果状态不完备，则状态机会进入错误状态，输出不定，仿真时可以很快的发现。而且，综合工具对于 &lt;code&gt;x&lt;/code&gt; 采取的态度是 &lt;code&gt;don't care&lt;/code&gt;，综合时会自动将其忽略，生成的电路最简洁。&lt;/p&gt;
&lt;h3&gt;避免 Latch&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在第三个 &lt;code&gt;always&lt;/code&gt; 中，在 &lt;code&gt;case&lt;/code&gt; 前，所有的输出都有默认的值，这样做的好处是可以消除 &lt;code&gt;Latch&lt;/code&gt; 的出现，而且，可以减少在后面每种状态下重复相同的赋值，而且强调显示了 case 内哪个输出发生了变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;书写完备的 &lt;code&gt;if-else&lt;/code&gt; 和 &lt;code&gt;case&lt;/code&gt; 语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;消除输出毛刺&lt;/h3&gt;
&lt;p&gt;对于三段式，因为输出是寄存器输出，所以解决了输出毛次。&lt;/p&gt;
&lt;p&gt;讨论一下采用寄存器输出的方式对设计的影响&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输出采用寄存器驱动可以优化 FSM 的时序性能&lt;/p&gt;
&lt;p&gt;影响一个时序电路运行速度的主要因素是两个寄存器之间的组合逻辑路径的长度，越长的组合逻辑路径，其时序性能越差。一个电路中的最长组合逻辑路径决定了这个电路最高运行速率，该路径就是这个电路的关键路径（&lt;code&gt;critical path&lt;/code&gt;）。所以，切断最长的组合逻辑路径可以提高局部电路的运行速度，切断多个较长的组合逻辑路径可以提高整体电路的运行速度。切断组合逻辑路径的工具就是寄存器。所以，添加寄存器可以提高电路的性能，但是会增加资源的消耗，这也是速度（speed）和面积（area）互为矛盾的原因。&lt;/p&gt;
&lt;p&gt;在考虑FSM的时序问题时，不能独立的考虑FSM本身，需要综合考虑FSM模块和下游模块构成的电路。在FSM不采用输出寄存时，在FSM模块和下游模块的接口处，是两部分组合逻辑直接相连。关键路径由两部分组合逻辑构成；在FSM采用输出寄存时，两个模块的组合逻辑被分隔成两部分，可能的关键路径被切断了。同步寄存器输出和组合逻辑输出就是采用资源优化还是速度优化的问题。组合逻辑表面上会提高电路的速度，看似节省了资源而且提高了速度，其实不然（对FPGA结构来说，节省寄存器不等于节省LE；对同步设计来说，异步输出速度上的优势是可以忽略的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出采用寄存器驱动会降低输出队输入信号变化的响应速度？&lt;/p&gt;
&lt;p&gt;到底应不应该采用FSM输出寄存器？是否必须在时序性能和响应速度之间做出取舍？在同步设计中，答案是必须牺牲一定的响应速度以换取更佳的时序性能，只考虑响应速度会带来潜在的时序性能损失。&lt;/p&gt;
&lt;p&gt;在考虑FSM的响应速度时，不能独立的考虑FSM本身，需要综合考虑FSM模块和上、下游模块构成的电路。采用输出寄存器的电路可以运行在更高的时钟频率下，所引入的响应时延与更高的运行频率相比是可以牺牲的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;case (NS) vs case (CS)&lt;/h3&gt;
&lt;p&gt;采用二段式实现状态机，它的输出是组合逻辑，可能存在竞争和冒险，产生毛刺，要消除毛刺就要对输出用寄存器打一拍，但是很多时候，是不允许插入寄存器节拍的。&lt;/p&gt;
&lt;p&gt;这时候可以采用三段式实现，三段式的输出是寄存器输出，所以消除了毛次；同时，如果三段式的第三段判断输出采用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// ....&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="nl"&gt;default:&lt;/span&gt; &lt;span class="n"&gt;begian&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就可以提前判断下一状态的输出，节省了一个节拍，使输出和状态变化同步。&lt;/p&gt;
&lt;p&gt;设计一个简单的 FSM，测试使用 &lt;code&gt;case(CS)&lt;/code&gt; 和 &lt;code&gt;case(NS)&lt;/code&gt; 的结果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FSM 设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一共有 4 个状态(IDLE、S1、S2、S3)，只有一个输入(&lt;code&gt;jump&lt;/code&gt; 信号)，两个输出(&lt;code&gt;dout_p&lt;/code&gt;、&lt;code&gt;dout_q&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跳转规律&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态机开始处于 IDLE 状态，当 jump 变高时，从 IDLE 跳转到 S1 状态，同时内部的一个 4 bit 计数器开始计数，当计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时，跳转到 S2，当再次计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时跳转到 S3，当再次计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时，跳转到 IDLE，等待 jump 再次变高。状态转移图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="diagram" src="/images/fsm-design/diagram.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态机源文件&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/fsm.v"&gt;fsm.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试平台 testbench&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/tb_fsm.v"&gt;tb_fsm.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;NS&lt;/code&gt; 判断，结果如下图，可以看到，当 &lt;code&gt;CS&lt;/code&gt; 发生变化时，输出同时改变。&lt;/p&gt;
&lt;p&gt;&lt;img alt="case ns" src="/images/fsm-design/case_ns.png" /&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;CS&lt;/code&gt; 判断，结果如下图，可以看到，当 &lt;code&gt;CS&lt;/code&gt; 发生变化时，输出变化相对于状态变化延时一个时钟周期。&lt;/p&gt;
&lt;p&gt;&lt;img alt="case ns" src="/images/fsm-design/case_cs.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG1998SJ_FSM.pdf"&gt;Clifford E. Cumming     State Machine Coding Styles for Synthesis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsICU2002_FSMFundamentals.pdf"&gt;Clifford E. Cumming     The Fundamentals of Efficient Synthesizable Finite State Machine
Design using NC-Verilog and BuildGates&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.trilobyte.com/pdf/golson_snug94.pdf"&gt;Steve Golson                State machine design techniques for Verilog and VHDL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/freeny/archive/2012/04/14/2447612.html"&gt;Verilog HDL学习心得&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;foreveryoung 《状态机设计》&lt;/p&gt;
&lt;p&gt;云创工作室     《Verilog HDL程序设计与实践》&lt;/p&gt;</summary><category term="FPGA"></category><category term="FSM"></category><category term="Verilog"></category></entry><entry><title>学习 Arduino #2 初识 Intel Galileo 开发板</title><link href="http://guqian110.github.io/pages/2014/05/29/learing_arduino_series_2_intel_galileo_development_board.html" rel="alternate"></link><updated>2014-05-29T23:27:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-05-29:pages/2014/05/29/learing_arduino_series_2_intel_galileo_development_board.html</id><summary type="html">&lt;h2&gt;Preface&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Arduino 有很多开发板，分别针对不同的应用环境含有不同的模块。学习一款 Intel 推出的开发板 —— &lt;em&gt;Intel Galileo Development Board&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;Intel Gailileo Development Board 是 Intel 进入 Arduino 领域的试水产品，它含有一颗 Quark Soc X1000 CPU，这是一款 32 位、x86 构架、低功耗的 SoC 芯片，它的主频可以达到 400 MHz，内部有 512 KB 的 SRAM，同时 Galileo 有丰富的接口(USB, JTag, RS232, Ethernet, mPCIE...)，支持很多外围设备。&lt;/p&gt;
&lt;p&gt;Galileo 试图达到的目标是融合 Arduino 对硬件操作的便利和 Linux 系统对硬件操作完整支持。所以，Galileo 也兼容 Arduino 接口，你可以很方便的把 Arduino 项目移植到 Galileo 上运行，使用常用的一些 Arduino 库(Ethernet, Wi-Fi, SD, EEPROM...)也可以获得内部 Linux 系统的完整功能(Python, SSH, Telnet， OpenCV...)。&lt;/p&gt;
&lt;p&gt;总结一下我学习这块板子的知识，不仅仅为 Arduino 开发做准备，也为后面的一个竞赛(基于Yocto 项目)开发积累知识～&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Official Arduino Boards&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Arduino 官网上列出所有了官方开发板，其中也包含了官方认证过的开发板(Intel Galileo)，和一些推荐的第三方产品&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Main/Products"&gt;Arduino Products&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还详细列出了这些开发板上的微控制器的区别&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Products.Compare"&gt;Compare boards specs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;官方的开发板的核心都是 Atmel 的微控制器，基于市场战略的需求，看到数莓派、Arduino发展的热火朝天，Intel 也坐不住了(瞎猜的 =.=)，推出了新的基于 Intel 架构(x86)、可以和 Arduino 兼容的开发板。Galileo 是这个家族中的第一款，目前 Intel 又推出了一款新的开发板，取名叫 Edison。(Intel 这是要把所有科学家的名字都取个遍么)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Intel Galileo Board&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Arduinco.cc&lt;/h3&gt;
&lt;p&gt;在 Arduino 官网上有一篇简单介绍 Galileo 的网页&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/ArduinoCertified/IntelGalileo"&gt;Intel Galileo on arduino.cc&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Intel Official Introduction&lt;/h3&gt;
&lt;p&gt;Arduino 官网上的介绍只是非常简单的介绍，Intel 自己的官网上有关于 Galileo 全部的详细资料&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.intel.cn/content/www/cn/zh/do-it-yourself/galileo-maker-quark-board.html"&gt;Galileo Maker Quark Board&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于 Galileo 的全部文档，包括 Datasheet、Schematic、Quick Start、User Guide 等：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/community/makers/documentation/galileodocuments"&gt;Intel Galileo Development Board Documents&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Other Introductions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt; 送上一篇非常好的介绍文章（来自 Ifanr.com），介绍了在 Maker 眼中，这个板子到底可以 hack 到什么程度～&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ifanr.com/388835"&gt;x86 版的 Arduino 来了，Intel Galileo 开发板的体验、分析和应用【超长文多图】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再&lt;/strong&gt; 附上一篇完爆我的总结的教程～&lt;/p&gt;
&lt;p&gt;&lt;a href="https://learn.sparkfun.com/tutorials/galileo-getting-started-guide"&gt;Galileo Getting Started Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇教程基本就是按照 Intel 官方的 Getting Started 流程写的，总结一下我遇到的问题 (Windows 7 &amp;amp; Linux Ubuntu)。&lt;/p&gt;
&lt;p&gt;Arduino 官方的 IDE 中 &lt;code&gt;Board&lt;/code&gt; 选项中没有 Galileo，所以我们应该从 Intel 下载定制过的 IDE。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows IDE 闪退&lt;/p&gt;
&lt;p&gt;这个 IDE 在部分 Windows 下有闪退的现象。&lt;/p&gt;
&lt;p&gt;原因 是 Intel 的 IDE 版本采用的是未发布的 1.5.3, 它会检测系统的语言设置，当系统不是 En/US 时，就会退出。&lt;/p&gt;
&lt;p&gt;解决方法 更改系统语言设置 或者 使用一款名为 Locale Emulator 的软件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IDE 解压路径&lt;/p&gt;
&lt;p&gt;Windows 下的解压路径 &lt;em&gt;必须是顶层目录&lt;/em&gt;，比如 &lt;code&gt;D:\arduino-1.5.3&lt;/code&gt;，否则在 &lt;code&gt;Verify&lt;/code&gt; 时会提示找不到特定的文件/目录。Linux 下无此问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux 连接板子和 PC&lt;/p&gt;
&lt;p&gt;在 Windows 下第一次连接系统自动安装驱动肯定会失败的，需要我们手动指定驱动文件的路径。&lt;/p&gt;
&lt;p&gt;在 Linux 终端下，必须以 &lt;code&gt;sudo&lt;/code&gt; 权限运行 IDE，否则即使板子已经连接了 PC，在 IDE 下的 &lt;code&gt;Tools\Serial Port&lt;/code&gt; 是 disable 的，不能选择端口&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;arduino&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux 下 disable modem manager&lt;/p&gt;
&lt;p&gt;前面的教程中提到，在大多数 Linux 发行版下，都需要 disable modem manager 才能 &lt;code&gt;Upload&lt;/code&gt; 成功，不过我在 Ubuntu 下没有遇到这个问题...&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;然后&lt;/strong&gt; 扯几句&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;硬件配置&lt;/p&gt;
&lt;p&gt;从 Board Guide 中找到的截图如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="key_componets_1" src="/images/learning-arduino-series-2-intel-galileo-development-board/key_components_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="key_componets_2" src="/images/learning-arduino-series-2-intel-galileo-development-board/key_components_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;从它的配置中可以看到，Galileo 并不是一款简单的 Arduino 开发板，它的硬件系统其实是按照 PC 来设计的，如果我们只是简单的把它当作 Arduino 开发板来应用，有点大材小用了，这样子完全没有体现出 Galileo 的优势，只是一个速度更快的 Arduino 罢了。&lt;/p&gt;
&lt;p&gt;事实上，如果功能上没有比传统的 Arduino 更强大的功能，估计 Intel 也不会推出这个产品了～Galileo 的真正强大的地方在于：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;背后基于 UEFI/Linux 的软件平台以及 Galileo 自身的硬件配置。为此，Intel 提供了丰富的开发文档、软件代码支持，方便开发人员真正的发挥出 Galileo 的所有潜力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件构架&lt;/p&gt;
&lt;p&gt;Galileo 不仅仅是硬件上按照 PC 设计的，事实上，它的软件构架也和 PC 一样。和普通的单片机不同，它并不是简单的运行用户开发的程序那么简单。它实际上运行着一个操作系统 —— 包含 UEFI(BIOS 的替代者)、Grub、嵌入式 Linux 系统，用户编写的 &lt;code&gt;Sketch&lt;/code&gt; 只是一个在 Linux 上面运行的应用而已。&lt;/p&gt;
&lt;p&gt;Galileo 启动时可以从 ISP Flash 中启动一个微型的 Linux 系统，也可以从 MicroSD 卡中启动一个完整版的 Linux 系统。我们 &lt;code&gt;Upload&lt;/code&gt; 时，Arduino IDE 将程序编译链接成一个标准的 Linux ELF 文件，并且下载到 Arduino 板子上运行，如图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="target_software" src="/images/learning-arduino-series-2-intel-galileo-development-board/target_software.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发嵌入式 Linux 设备&lt;/p&gt;
&lt;p&gt;或许这才是 Galileo 的 "正经" 用途吧...基于 Yocto Project，我们可以开发属于自己的 Linux 系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，送上一个别人的 Galileo 开箱视频&lt;/p&gt;
&lt;p&gt;&lt;embed src="http://player.youku.com/player.php/sid/XNjQ0NTMzMjYw/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"&gt;&lt;/embed&gt;&lt;/p&gt;</summary><category term="Arduino"></category><category term="Intel Galileo"></category></entry><entry><title>学习 Arduino #1 Arduino 入门</title><link href="http://guqian110.github.io/pages/2014/05/27/learing_arduino_series_1_getting_started.html" rel="alternate"></link><updated>2014-05-27T12:34:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-05-27:pages/2014/05/27/learing_arduino_series_1_getting_started.html</id><summary type="html">&lt;h2&gt;What is Arduino&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="logo" src="/images/learning-arduino-series-1-getting-started/logo.png" /&gt;&lt;/p&gt;
&lt;p&gt;版权所有：Arduino.cc&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/"&gt;Arduino 官网&lt;/a&gt; 首页的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ARDUINO IS AN OPEN-SOURCE ELECTRONICS PROTOTYPING PLATFORM BASED ON FLEXIBLE, EASY-TO-USE HARDWARE AND SOFTWARE. IT'S INTENDED FOR ARTISTS, DESIGNERS, HOBBYISTS AND ANYONE INTERESTED IN CREATING INTERACTIVE OBJECTS OR ENVIRONMENTS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Guide/Introduction"&gt;官方网站最权威的答案：&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Arduino is a tool for making computers that can sense and control more of the physical world than your desktop computer. &lt;strong&gt;It's an open-source physical computing platform based on a simple microcontroller board, and a development environment for writing software for the board.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino can be used to develop interactive objects, taking inputs from a variety of switches or sensors, and controlling a variety of lights, motors, and other physical outputs. Arduino projects can be stand-alone, or they can communicate with software running on your computer (e.g. Flash, Processing, MaxMSP.) The boards can be assembled by hand or purchased preassembled; the open-source IDE can be downloaded for free.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Development Language：&lt;/strong&gt; &lt;a href="http://arduino.cc/en/Reference/HomePage"&gt;Arduino programming language&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IDE：&lt;/strong&gt; &lt;a href="http://arduino.cc/en/Main/Software"&gt;Arduino IDE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt; &lt;a href="http://en.wikipedia.org/wiki/Arduino"&gt;Wikipedia 上的介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单的说：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino 是一个开放源代码的单片机，它使用了 Atmel AVR 单片机，采用了基于开放源代码的软硬件平台，构建于开放源代码 simple I/O 接口板。开发语言为 Arduino programming language（基于 Wiring 语言），开发环境基于 Processing 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Story of Arduino&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;wikipedia 上的&lt;a href="http://zh.wikipedia.org/wiki/Arduino"&gt;小故事&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Arduino的核心开发团队成员包括：Massimo Banzi，David Cuartielles，Tom Igoe，Gianluca Martino，David Mellis 和 Nicholas Zambetti。&lt;/p&gt;
&lt;p&gt;据说 Massimo Banzi 之前是意大利 Ivrea 一家高科技设计学校的老师。他的学生们经常抱怨找不到便宜好用的微控制器。2005年冬天， Massimo Banzi 跟 David Cuartielles 讨论了这个问题。David Cuartielles 是一个西班牙籍芯片工程师，当时在这所学校做访问学者。两人决定设计自己的电路板，并引入了 Banzi 的学生 David Mellis 为电路板设计编程语言。两天以后，David Mellis 就写出了程式码。又过了三天，电路板就完工了。这块电路板被命名为 Arduino。几乎任何人，即使不懂电脑编程，也能用 Arduino 做出很酷的东西，比如对传感器作出回应，闪烁灯光，还能控制马达。随后 Banzi，Cuartielles，和 Mellis 把设计图放到了网上。保持设计的开放源码理念，因为版权法可以监管开源软件，却很难用在硬件上，他们决定采用共享创意许可。共享创意是为保护开放版权行为而出现的类似 GPL 的一种许可（license）。在共享创意许可下，任何人都被允许生产电路板的复制品，还能重新设计，甚至销售原设计的复制品。你不需要付版税，甚至不用取得 Arduino 团队的许可。然而，如果你重新发布了引用设计，你必须说明原始 Arduino 团队的贡献。如果你调整或改动了电路板，你的最新设计必须使用相同或类似的共享创意许可，以保证新版本的 Arduino 电路板也会一样的自由和开放。唯一被保留的只有 Arduino 这个名字。它被注册成了商标。如果有人想用这个名字卖电路板，那他们可能必须付一点商标费用给 Arduino 的核心开发团队成员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Why is Arduino&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Guide/Introduction"&gt;官网介绍&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are many other microcontrollers and microcontroller platforms available for physical computing. Parallax Basic Stamp, Netmedia's BX-24, Phidgets, MIT's Handyboard, and many others offer similar functionality. All of these tools take the messy details of microcontroller programming and wrap it up in an easy-to-use package. &lt;strong&gt;Arduino also simplifies the process of working with microcontrollers, but it offers some advantage for teachers, students, and interested amateurs over other systems:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inexpensive&lt;/li&gt;
&lt;li&gt;Cross-platform (Windows, Linux, Macintosh OSX)&lt;/li&gt;
&lt;li&gt;Simple, clear programming environment&lt;/li&gt;
&lt;li&gt;Open source and extensible software&lt;/li&gt;
&lt;li&gt;Open source and extensible hardware&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;How-to Develope&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;IDE installation&lt;/h3&gt;
&lt;p&gt;官网上有 Windows, Linux, Mac 的详细安装步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://arduino.cc/en/Guide/Windows"&gt;for Windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://playground.arduino.cc/Learning/Linux"&gt;for Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Linux 安装过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;解决包依赖关系：安装 openjdk-7-jre (openjdk-6-jre, sun's java 6 runtime, the sun-java6-jre package, the oracle JRE 7 应该也可以)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;openjdk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;jre&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载合适的 &lt;a href="http://arduino.cc/en/Main/Software"&gt;Arduino IDE&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;解压、切换到解压路径，运行目录下的 &lt;code&gt;arduino&lt;/code&gt; 脚本&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zxvf&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0.5&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux32&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tgz&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0.5&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;arduino&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方法二 (for Ubuntu)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载 &amp;amp; 安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Dev&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IDE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino IDE 是用 Java 写的跨平台的程序，它源自 &lt;a href="http://en.wikipedia.org/wiki/Processing_(programming_language)"&gt;Processing programming language&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Wiring_(development_platform)"&gt;Wiring&lt;/a&gt; 项目的 IDE 。它是为艺术家和其他不熟悉软件开发的新手而设计的。它包含一个有语法高亮、括号匹配、自动缩进功能的代码编辑器，还可以通过一个按键完成编译程序(compile)和烧录至电路板(upload)的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Programming&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个 Arduino 程序/代码 称为 "&lt;em&gt;Sketch&lt;/em&gt;"。Arduino 程序是用 C/C++ 写成的，Arduino IDE 含有一个名叫 "Wiring" 的代码库(源自于 Wiring 项目)，这样子可以大幅度简化常用 I/O 操作，用户只需要定义两个函数就可以写出一个可以运行的程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;setup()&lt;/em&gt; : 系统上电或者复位时启动，只运行一次，初始化配置&lt;/li&gt;
&lt;li&gt;&lt;em&gt;loop()&lt;/em&gt; : 一直循环被调用，直到断电&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Arduino 的示例程序 "Blink"：(等同于 C 的 hello world，对于硬件最简单就是控制一个 LED 的亮灭)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;Blink&lt;/span&gt;
&lt;span class="cm"&gt;Turns on an LED on for one second, then off for one second, repeatedly.&lt;/span&gt;

&lt;span class="cm"&gt;This example code is in the public domain.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="c1"&gt;// Pin 13 has an LED connected on most Arduino boards.&lt;/span&gt;
&lt;span class="c1"&gt;// give it a name:&lt;/span&gt;
&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;13&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// the setup routine runs once when you press reset:&lt;/span&gt;
&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                
  &lt;span class="c1"&gt;// initialize the digital pin as an output.&lt;/span&gt;
  &lt;span class="n"&gt;pinMode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;OUTPUT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// the loop routine runs over and over again forever:&lt;/span&gt;
&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;digitalWrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;HIGH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// turn the LED on (HIGH is the voltage level)&lt;/span&gt;
  &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;               &lt;span class="c1"&gt;// wait for a second&lt;/span&gt;
  &lt;span class="n"&gt;digitalWrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;LOW&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// turn the LED off by making the voltage LOW&lt;/span&gt;
  &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;               &lt;span class="c1"&gt;// wait for a second&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的这段代码对于一个标准 C++ 编译器来说是无效的，事实上当我们按下 IDE 界面上的 "Upload to I/O board" 按钮时，IDE 会拷贝一份代码，在开头加上 &lt;code&gt;include&lt;/code&gt; 指示，在结尾加上一个很简单的 &lt;code&gt;main()&lt;/code&gt; 函数，这样它就是一个有效的 C++ 程序了。&lt;/p&gt;
&lt;p&gt;Arduino 使用 &lt;a href="http://en.wikipedia.org/wiki/GNU_toolchain"&gt;GNU toolchain&lt;/a&gt; 和 AVR Libc 来编译程序的，使用 AVRdude 把程序下载到板子上。因为 Arduino 平台采用的是 Atmel 的微控制器，所以 Atmel 的开发环境 AVR Studio 或者更新的 Atmel Studio 应该也可以作为 Arduino 的开发环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习资源&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Arduino 的联合创始人 Massimo Banzi 的 Tutorial Series Vedio&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youku.com/playlist_show/id_19440139.html"&gt;优酷视频地址&lt;/a&gt;，一共 11 课，涵盖最基本的面包板搭电路、I/O 接口控制、传感器控制、网络应用等方面，如果有编程基础，很快就可以上手制作自己的设备了～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/"&gt;Arduino 中文社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/thread-1066-1-1.html"&gt;论坛教程汇总帖&lt;/a&gt;，因为 Arduino 诞生的一个很大的目的就是为设计师、艺术家、业余爱好者提供更加方便的开发环境，所以，Arduino 的教程对于有编程基础的同学来说是很容易的 ：-P&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Reference/HomePage"&gt;Arduino Language Reference en&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网上关于 Arduino 编程语言的介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/reference/"&gt;Arduino Language Reference zh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Arduino 中文社区翻译的 编程语言介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Tutorial/HomePage"&gt;Arduino Core Functions, Libraries&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网上关于 IDE 中 &lt;code&gt;File/Examples/&lt;/code&gt; 下示例程序的说明&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/"&gt;Arduino official website&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Arduino"&gt;Arduino on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/"&gt;Arduino 中文社区&lt;/a&gt;&lt;/p&gt;</summary><category term="Arduino"></category><category term="Open-source Hardware"></category></entry><entry><title>BUPT MITC lab Verilog HDL coding style guide</title><link href="http://guqian110.github.io/pages/2014/05/19/bupt_mitc_lab_verilog_hdl_coding_style_guide.html" rel="alternate"></link><updated>2014-05-19T10:12:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-05-19:pages/2014/05/19/bupt_mitc_lab_verilog_hdl_coding_style_guide.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Version&lt;/strong&gt; : 1.1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Date&lt;/strong&gt; : 2014-5-24&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Author&lt;/strong&gt; : Chien Gu (guqian110@gmail.com)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt; : This is a brief Verilog HDL coding style guide for BUPT MITC lab to design circuits on FPGA. This guide is only concerned about code format and dose not involve principles for writing synthesisable codes.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;总则&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码模块化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;顶层模块只有子模块的例化，不包含任何逻辑 ；常用、通用功能模块化，避免在多个模块中重复实现多次；模块内容过多时考虑分解为多个模块；模块按照功能、信号传递流程原则划分 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块结构化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分节书写，合理使用空格、括号，使代码更容易查看 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用缩写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;约定命名规则、大小写规则、常用单词缩写规则，避免过长的信号名 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;分述&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;head of file&lt;/h3&gt;
&lt;p&gt;Xilinx ISE 自动生成的标准文件头部，添加 &lt;code&gt;Email&lt;/code&gt;、&lt;code&gt;File Name&lt;/code&gt; 两个信息，最终结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Company: &lt;/span&gt;
&lt;span class="c1"&gt;// Engineer: &lt;/span&gt;
&lt;span class="c1"&gt;// Email:&lt;/span&gt;
&lt;span class="c1"&gt;// &lt;/span&gt;
&lt;span class="c1"&gt;// Create Date:    20:43:36 11/12/2013 &lt;/span&gt;
&lt;span class="c1"&gt;// Design Name: &lt;/span&gt;
&lt;span class="c1"&gt;// Module Name:    CLKMGN&lt;/span&gt;
&lt;span class="c1"&gt;// File Name:      clkmgn.v&lt;/span&gt;
&lt;span class="c1"&gt;// Project Name: &lt;/span&gt;
&lt;span class="c1"&gt;// Target Devices: &lt;/span&gt;
&lt;span class="c1"&gt;// Tool versions: &lt;/span&gt;
&lt;span class="c1"&gt;// Description: &lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// Dependencies: &lt;/span&gt;
&lt;span class="c1"&gt;// &lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// Revision: &lt;/span&gt;
&lt;span class="c1"&gt;// Revision 0.01 - File Created&lt;/span&gt;
&lt;span class="c1"&gt;// Additional Comments: &lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;module&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;模块命名大小写：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件名：xxx.v (小写)&lt;/li&gt;
&lt;li&gt;模块名：XXX (大写)&lt;/li&gt;
&lt;li&gt;例化名：U_XXX (大写)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;模块端口定义顺序：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入&lt;/li&gt;
&lt;li&gt;输出&lt;/li&gt;
&lt;li&gt;双向&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;模块调用规范：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;em&gt;信号映射法&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;举例说明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Module Declaration                                                            //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="no"&gt;MODULE_NAME&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="c1"&gt;// input ports&lt;/span&gt;
    &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;port_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="c1"&gt;// output ports&lt;/span&gt;
    &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;port_m&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;////////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Port Declarations                                                              //&lt;/span&gt;
&lt;span class="c1"&gt;////////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;//input ports&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// comments&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;port_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//output ports&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// comments&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="n"&gt;port_m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Parameter Declarations                                                        //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;DIN&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTA&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTE&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTCTR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Wire &amp;amp; Reg Declarations                                                       //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="k"&gt;wire&lt;/span&gt;    &lt;span class="n"&gt;wire_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;wire&lt;/span&gt;    &lt;span class="n"&gt;wire_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;wire&lt;/span&gt;    &lt;span class="n"&gt;wire_x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;reg_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;reg_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;reg_y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Main Body of Code                                                             //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;

    &lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;// Instantiate sub module                                //&lt;/span&gt;
    &lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="no"&gt;MODULE_NAMW_A&lt;/span&gt; &lt;span class="no"&gt;U_MODULE_NAMW_A&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="no"&gt;B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;posdge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negdege&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// do something&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;wire_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wire_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;FSM&lt;/h3&gt;
&lt;p&gt;有限状态机(Finite State Machine) 使用三段式格式。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// FSM-1&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// next state&lt;/span&gt;
        &lt;span class="no"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// FSM-2&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="no"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="nl"&gt;S1:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="no"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// FSM-3&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;posdge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;

    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// default output&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;defaut:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;endcase&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;always&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个 &lt;code&gt;always&lt;/code&gt; 中不要同时含有 &lt;em&gt;组合逻辑&lt;/em&gt; 和 &lt;em&gt;时序逻辑&lt;/em&gt;，分开写在不同的 &lt;code&gt;always&lt;/code&gt; 块中。&lt;/li&gt;
&lt;li&gt;组合逻辑使用 &lt;em&gt;阻塞赋值(=)&lt;/em&gt;，时序逻辑使用 &lt;em&gt;非阻塞赋值(&amp;lt;=)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;不要在多个 &lt;code&gt;always&lt;/code&gt; 中对同一信号赋值，也不要在一个 &lt;code&gt;always&lt;/code&gt; 中对一个信号进行多次赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;标准 &lt;code&gt;always&lt;/code&gt; 格式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posdge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;

    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// do somethig&lt;/span&gt;

    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;parameter&lt;/h3&gt;
&lt;p&gt;parameter 全部大写，用 parameter 定义有实际意义的常数，比如 LED 亮灯状态、状态机状态等，避免 "magic number"。举例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Parameter Declarations                                                        //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="no"&gt;DIN&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTA&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTE&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="no"&gt;DOUTCTR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;if-else&lt;/h3&gt;
&lt;p&gt;标准 &lt;code&gt;if-else&lt;/code&gt; 格式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;

&lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;

&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;case-default&lt;/h3&gt;
&lt;p&gt;标准 &lt;code&gt;case&lt;/code&gt; 格式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;variable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nl"&gt;vaule1:&lt;/span&gt; &lt;span class="n"&gt;begian&lt;/span&gt;
        &lt;span class="c1"&gt;// do something&lt;/span&gt;

    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="nl"&gt;value2:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// do something&lt;/span&gt;

    &lt;span class="n"&gt;end&lt;/span&gt;
    &lt;span class="nl"&gt;default:&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// do something&lt;/span&gt;
    &lt;span class="n"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;naming&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单词首字母缩写，大写。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DMI&lt;/span&gt;     &lt;span class="c1"&gt;// Data Memory Interface&lt;/span&gt;
&lt;span class="n"&gt;DEC&lt;/span&gt;     &lt;span class="c1"&gt;// Decoder&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块间信号名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分为两部分，第一部分表示信号方向，大写，第二部分表示信号意义，小写，下划线连接。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;CPUMMU_wr_req&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// write request form CPU to MMU&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块内命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单词缩写，下划线连接，小写。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;sdram_wr_en&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// SDRAM write enable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统级命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时钟信号、置位信号、复位信号等需要输送到各个模块的全局信号，以 &lt;code&gt;SYS_&lt;/code&gt; 前缀开头。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_clk_100MHz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// system clock&lt;/span&gt;
&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_set_cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// system counter set&lt;/span&gt;
&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_rst_cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// system counter reset&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;低电平有效信号命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;低电平有效信号加后缀 &lt;code&gt;_n&lt;/code&gt;，举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// low valid reset&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;经过锁存器的信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过锁存器的信号加后缀 &lt;code&gt;_r&lt;/code&gt;，以和锁存前区别。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// latch input data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际意义缩写，大写。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;IDLE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;WAIT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;常用信号名缩写：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;acknowledge&lt;/td&gt;
&lt;td&gt;ack&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;err&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;ready&lt;/td&gt;
&lt;td&gt;rdy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;adress&lt;/td&gt;
&lt;td&gt;addr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;enable&lt;/td&gt;
&lt;td&gt;en&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;receive&lt;/td&gt;
&lt;td&gt;rx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arbiter&lt;/td&gt;
&lt;td&gt;arb&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;frame&lt;/td&gt;
&lt;td&gt;frm&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;request&lt;/td&gt;
&lt;td&gt;req&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;check&lt;/td&gt;
&lt;td&gt;chk&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;generate&lt;/td&gt;
&lt;td&gt;gen&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;resest&lt;/td&gt;
&lt;td&gt;rst&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clock&lt;/td&gt;
&lt;td&gt;clk&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;grant&lt;/td&gt;
&lt;td&gt;gnt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;segment&lt;/td&gt;
&lt;td&gt;seg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;td&gt;cfg&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;increase&lt;/td&gt;
&lt;td&gt;inc&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;source&lt;/td&gt;
&lt;td&gt;src&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;control&lt;/td&gt;
&lt;td&gt;ctrl&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;statistic&lt;/td&gt;
&lt;td&gt;stat&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;counter&lt;/td&gt;
&lt;td&gt;cnt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;length&lt;/td&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;switcher&lt;/td&gt;
&lt;td&gt;sf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data in&lt;/td&gt;
&lt;td&gt;din&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;out&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;timer&lt;/td&gt;
&lt;td&gt;tmr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data out&lt;/td&gt;
&lt;td&gt;dout&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;packet&lt;/td&gt;
&lt;td&gt;pkt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;tmporary&lt;/td&gt;
&lt;td&gt;tmp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decode&lt;/td&gt;
&lt;td&gt;de&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;priority&lt;/td&gt;
&lt;td&gt;pri&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;transmit&lt;/td&gt;
&lt;td&gt;tx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decrease&lt;/td&gt;
&lt;td&gt;dec&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;ptr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;valid&lt;/td&gt;
&lt;td&gt;vld&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delay&lt;/td&gt;
&lt;td&gt;dly&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;read&lt;/td&gt;
&lt;td&gt;rd&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;write enable&lt;/td&gt;
&lt;td&gt;wr_en&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disable&lt;/td&gt;
&lt;td&gt;dis&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;read enbale&lt;/td&gt;
&lt;td&gt;rd_en&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;write&lt;/td&gt;
&lt;td&gt;wr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;incedent&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;tab&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的 &lt;code&gt;tab&lt;/code&gt; 全部用 &lt;em&gt;4 个 &lt;code&gt;space&lt;/code&gt;&lt;/em&gt; 代替！不同层次之间用 &lt;code&gt;tab(4 sapce)&lt;/code&gt; 缩进 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;space&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;信号端口定义，关键字、宽度说明、信号名之间对齐。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;input&lt;/span&gt;          &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;input&lt;/span&gt;          &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;input&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二元运算符用 &lt;code&gt;space&lt;/code&gt; 隔开&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dout_en&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;comments&lt;/h3&gt;
&lt;p&gt;采用英文，合理注释。修改代码一定要注释，添加 Revision 信息 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;建议&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;开发工具：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理工程： Xilinx ISE&lt;/li&gt;
&lt;li&gt;综合工具： Xilinx Synthsis Tools&lt;/li&gt;
&lt;li&gt;仿真平台： ModelSim SE&lt;/li&gt;
&lt;li&gt;代码编辑： Sublime Text 2 + Verilog 插件&lt;/li&gt;
&lt;/ul&gt;</summary><category term="FPGA"></category><category term="Verilog"></category><category term="coding style"></category></entry><entry><title>FPGA 数字处理基础</title><link href="http://guqian110.github.io/pages/2014/05/14/fpga_digital_processing_basic.html" rel="alternate"></link><updated>2014-05-14T23:25:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-05-14:pages/2014/05/14/fpga_digital_processing_basic.html</id><summary type="html">&lt;h2&gt;数字处理基础&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;数字处理基础&lt;/strong&gt;主要包括两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数的表示&lt;/li&gt;
&lt;li&gt;常用算术运算的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分别讨论&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;数的表示&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;这部分讨论对于计算机(PC)、数字信号处理器件(DSP)、数字芯片(包括 FPGA) 都是成立的。&lt;/p&gt;
&lt;h3&gt;人类如何计数&lt;/h3&gt;
&lt;p&gt;最早我们的祖先采用的是结绳计数，经过几千年的发展，现在我们使用的 10 进制位置计数法 。那么我们为什么偏偏选择 10 这个数字呢？&lt;/p&gt;
&lt;p&gt;大名鼎鼎的 &lt;a href="http://en.wikipedia.org/wiki/Charles_Petzold"&gt;Charles Petzold&lt;/a&gt; 在他的著作 &lt;a href="http://book.douban.com/subject/4822685/"&gt;code&lt;/a&gt; 中分析了我们的计数进制现象 。原因其实很简单，10 这个数字对于我们如此特别只是因为我们有 10 个手指(脚趾)，于是我们采用了 10 进制，并且逐渐习惯了它 。他在书中模拟了一下进制系统的演化过程，让我们逐渐从人类的 10 进制思维逐渐转化到计算机的 2 进制系统中：&lt;/p&gt;
&lt;p&gt;假设我们是卡通动画中的人物，比如米老鼠 Mickey，仔细观察它就会发现，他的每个手只有 4 个手指，理所当然，他采用 8 进制来计数。如果更进一步，假设我们是龙虾，那么我们的每一只钳子上有两个 “手指”，一共有 4 个手指，所以，我们会采取 4 进制计数系统。最后，假设我们是海豚，那么我们只有两个鳍来计数了，这时候的计数系统就是 2 进制数字系统了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;r 进制 to 10 进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需要按权值展开就可以了，比如： &lt;/p&gt;
&lt;p&gt;2 进制数 &lt;code&gt;110101&lt;/code&gt; 对应的 10 进制数为 &lt;code&gt;32 + 16 + 4 + 1 = 53&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;8 进制数 &lt;code&gt;B65F&lt;/code&gt; 对应的 10 进制数为 &lt;code&gt;11 × 16^3 + 6 × 16^2 + 5 × 16 + 15 × 1 = 46687&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10 进制 to r 进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整数部分：基数连除，逆序取余&lt;/p&gt;
&lt;p&gt;小数部分：基数连乘，顺序取余&lt;/p&gt;
&lt;h3&gt;计算机如何计数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;正数 &amp;amp; 负数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人类和计算机的计数原理是完全不同的，所以采用的方法也是完全不同的。对于人来说，区分正负数只需要在数字绝对值前添加一个符号 &lt;code&gt;+&lt;/code&gt; 或者 &lt;code&gt;-&lt;/code&gt; 即可，但是计算机只有 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 这两个符号可以使用；对于人来说，减法借位很容易，但是对于计算机硬件电路来说这是一件很麻烦的事。&lt;/p&gt;
&lt;p&gt;常用的表示方法有 3 种：&lt;strong&gt;原码&lt;/strong&gt;、&lt;strong&gt;反码&lt;/strong&gt;、&lt;strong&gt;补码&lt;/strong&gt; 。对于计算机而言，硬件上最容易实现的是补码，这也是大多数计算机采用补码系统的原因 。&lt;/p&gt;
&lt;p&gt;以前总结过一篇博客，&lt;a href="http://guqian110.github.io/pages/2014/03/19/signed_number_representations.html"&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整数 &amp;amp; 小数&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;整数&lt;/p&gt;
&lt;p&gt;对于整数而言，不存在小数点的问题，所以自然地将我们人类所熟悉的 10 进制数转化为计算机熟悉的 2 进制数，分配足够的空间存储起来就 ok 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小数&lt;/p&gt;
&lt;p&gt;在计算机中，整数和小数之间并不是很容易转换的的，而且小数的存储和处理要比整数复杂。对于小数，可以有两种方法来表示：&lt;strong&gt;定点数&lt;/strong&gt; &amp;amp; &lt;strong&gt;浮点数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定点数的意思是小数点在数中的位置是固定不变的。整数可以看作是一种特殊的定点数，小数点在数的末尾。值得注意的是小数点的位置信息并没有和数字存储在一起，所以，使用定点数的程序必须知道小数点的位置。&lt;/p&gt;
&lt;p&gt;浮点数的意思是小数点在数中的位置是变化的。当代大部分计算机处理浮点数的标准是 IEEE 在 1985 年制定的 ANSI/IEEE Std 754-1985 。&lt;/p&gt;
&lt;p&gt;==============================跑题分割线========================&lt;/p&gt;
&lt;p&gt;在计算机出现不久的年代，计算机处理浮点数是一件很重要但也让人头疼的事。最早，还没有专门处理浮点数的硬件，所以程序猿必须编写软件来完成浮点数的计算。浮点数在科学运算和工程类程序中极为重要，因此常常被赋予很高的优先级，在计算机发展的早期，为新制造的计算机做的第一项工作就是为其编写浮点数运算程序。&lt;/p&gt;
&lt;p&gt;如果可以直接利用计算机机器码指令来实现浮点数的计算，类似于 16 位处理器上进行乘法和除法运输，那么这台机器上所有的浮点数运算都会变得更快。IBM 公司在 1954 年发布了 IBM 704，它是第一台将浮点数运算硬件作为可选配件的商用计算机。该机器的浮点运算硬件可以直接进行加法、减法、乘法和除法，其他的浮点运算必须通过软件来实现。&lt;/p&gt;
&lt;p&gt;从 1980 年开始，浮点运算硬件开始应用于桌面计算机，这起始于 Intel 当年发布的 8087 数字协同处理(Numberic Data Coprocessor)芯片，当时这种集成电路被称为 &lt;strong&gt;数学协同处理器(math coprocessor)&lt;/strong&gt; 或者 &lt;strong&gt;浮点运算单元(floating-point,FPU)&lt;/strong&gt;。8087 不能独立工作，必须和 8086 或者 8088 一起工作，所以被称为 “&lt;strong&gt;协处理器&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;在最初版本的 IBM PC 主板上，位于 8080 芯片的右边有一个 40 个管脚的插槽供 8087 芯片接入，但是，这个插槽是空的，如果用户需要浮点运算则必须单独购买一块 8087 芯片。数字协处理器并不能加速所有的程序的运行速度，比如文字处理程序几乎用不到浮点运算，而电子表格处理程序对浮点数运算依赖程度很高。&lt;/p&gt;
&lt;p&gt;安装了数学协处理器，程序员必须使用协处理器的机器码指令来编写特定的程序，因为数学协处理器不是标准硬件。最后就出现了这样的局面：如果机器上安装了数学协处理器，程序员就要学会编写相应的应用程序以支持它的运行；如果没有安装，程序员必须通过编程来模拟它进行浮点数的运算。&lt;/p&gt;
&lt;p&gt;在 1989 年发布的 486DX 芯片中，FPU 已经内建在 CPU 的结构里，但是在 1991 年发布的 486SX 中，又没有内建 FPU，到了 1993 年发布的奔腾芯片中，CPU 内置 FPU 再次成为标准，并且是永远的标准。在 1990 年发布的 68040 芯片中，摩托罗拉首次将 FPU 集成到 CPU 中，在此之前是使用 68881 和 68882 数学协处理器来支持 68000 家族的微处理器。PowerPC 芯片同样使用了内置 FPU 的技术。&lt;/p&gt;
&lt;p&gt;==============================跑题分割线结束========================&lt;/p&gt;
&lt;p&gt;FPGA 不同于微处理器，它内部没有内置 FPU(不包括硬核)，对于FPGA，浮点数可以克服定点数动态范围小的缺点，但是在运算时，实现浮点数的硬件实时成本高，处理速度慢，所以在非实时运算中有广泛的应用。对于通信系统中的信号，一般都是实时处理的，所以在 FPGA 开发中，一般只使用定点数 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;常用算术运算的 FPGA 实现&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;加法&lt;/h3&gt;
&lt;p&gt;在 Verilog HDL 中，直接使用运算符 &lt;code&gt;+&lt;/code&gt;，其本质上是一种并行加法器，应该保证两边的数位宽是一致的。举个栗子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;add_4&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;output&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;output&lt;/span&gt;          &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;乘法&lt;/h3&gt;
&lt;p&gt;第一种方法，最简单，直接使用运算符 &lt;code&gt;*&lt;/code&gt;，如下所示 。但是这种方法写出来的代码效率很低，甚至有时候是不可综合的，实际应用中基本不会采用这种方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二种方法是自己写代码实现乘法运算，或者是使用 IP COre。一般 FPGA 中都集成了硬核的乘法器，所以可以有两种方案来实现乘法器，DSP48 硬核 或者是 Slice 搭建 。&lt;/p&gt;
&lt;h3&gt;除法&lt;/h3&gt;
&lt;p&gt;除法是四则基本运算中最复杂的，也是最难实现的。除法可以看作是乘法的逆运算，但除法要复杂的多，最大的区别是乘法中的一些操作可以并行支持，通过流水线提高计算速度，但是除法必须顺序执行，运算最耗时间。&lt;/p&gt;
&lt;p&gt;Verilog 提供了除法运算符 &lt;code&gt;/&lt;/code&gt;，如下所示。但是只有在除数为 2 或者 2 的整幂次时才是可综合的，其余情况都不可综合 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;常用的方法是采用 IP Core，可以完成定点数和浮点数两类算法。&lt;/p&gt;
&lt;h3&gt;Cordic 算法&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/CORDIC"&gt;Cordic 算法&lt;/a&gt; 算法即坐标旋转数字计算方法，是J.D.Volder1于1959年首次提出，主要用于三角函数、双曲线、指数、对数的计算。该算法通过基本的加和移位运算代替乘法运算，使得矢量的旋转和定向的计算不再需要三角函数、乘法、开方、反三角、指数等函数。&lt;/p&gt;
&lt;p&gt;它通常应用在没有硬件乘法器的应用中，比如微控制器、FPGA 中，进行的所有操作只有加法、移位和查表 。&lt;/p&gt;
&lt;p&gt;Coridc 算法可以自己编写代码实现，也可以使用 IP Core 。(事实上，所有的 IP 软核理论上都可以自己写，因为这些软核实际上就是别人写好的代码和文档，类似于C语言中的库函数)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3795386/"&gt;《无线通信的 Matlab 和 FPGA 实现》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4822685/"&gt;code&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="digital processing"></category></entry><entry><title>麦田里的守望者 书评</title><link href="http://guqian110.github.io/pages/2014/05/14/the_catcher_in_the_rye_review.html" rel="alternate"></link><updated>2014-05-14T00:41:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-05-14:pages/2014/05/14/the_catcher_in_the_rye_review.html</id><summary type="html">&lt;p&gt;&lt;img alt="the catcher in the rye" src="/images/the-catcher-in-the-rye-review/the_catcher_in_the_rye.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;如何认识这本书&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;以前就听说过这本书的名字，真正感兴趣是在《我爱摇滚乐》上看到的一篇文章，介绍了枪杀传奇乐队披头士 The Beatles 的主唱约翰·列侬(John Winston Lennon) 的凶手马克·查普曼 (Mark David Chapman)，他被捕时身上就带着一本《麦田里的守望者》。当查普曼被捕时，警方从他的副本中发现了这样的话：“亲爱的霍尔顿·考尔菲德，自霍尔顿·考尔菲德，这是我的陈述。”&lt;/p&gt;
&lt;p&gt;后来才发现，其实这本书很有争议，它和几起枪击案与小说有关，这包括罗伯特·约翰·巴窦枪击丽贝卡·谢弗，约翰·欣克利刺杀罗纳德·里根未遂。马克·大卫·查普曼枪击了约翰·列侬。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;这是一本曾样的书&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E9%BA%A5%E7%94%B0%E6%8D%95%E6%89%8B"&gt;麦田里的守望者 on wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该书于1951年出版之后，立刻引起巨大的轰动，受到读者——特别是青年人——的热烈的欢迎，被翻译为多国语版。小说每年大约有250,000本售出、总计为6500万本。时代杂志将《麦田里的守望者》列在“2005年度百大英语小说（自1923年起）”榜上，现代图书馆及其读者也将其列在20世纪百大英文小说榜上。赞赏者认为本书用青少年的口吻平铺直叙，增加了作品的感染力，传神地描写主角的内心思维，并说出了青少年不满成年世界充满虚伪欺瞒的心声。批评者则认为书中主角离经叛道，逃学、吸烟、喝酒又满嘴粗话，会给年轻读者带来不良影响。当时许多图书馆及学校将之列为禁书，并被列在美国最具挑战性图书榜上。但现在这本书却是许多美国学校的指定读物。有的评论家说，它“大大地影响了好几代美国青年”。而且有学者认为，霍尔顿是当代美国文学中最早出现的反英雄形象之一。&lt;/p&gt;
&lt;p&gt;《麦田里的守望者》位列20世纪最佳小说之林。小说出版后不久，纳什·K·伯格（Nash K. Burger）写给《纽约时报》称小说为“少见的杰作”，詹姆斯·斯特恩（James Stern）则模仿霍尔顿的语气，为小说送上钦佩之词。.美国前总统乔治·赫伯特·沃克·布什称小说为“了不起的作品”，并称它启迪了自己。2009年6月，BBC的芬洛·卢勒（Finlo Rohrer）写道小说问世已有58年之久，但依然是“青春期的定义之作”。霍尔顿常常愤世嫉俗、郁郁寡欢、离群索居、与世隔绝、迷失方向、玩世不恭”。亚当·戈普尼克认为小说与美国文学中的《了不起的盖茨比》、《哈克历险记》并列为“三部完美之作”，称“在对纽约50年代的捕捉上，没有哪一部作品可以与《麦田里的守望者》并驾齐驱。”&lt;/p&gt;
&lt;p&gt;并非所有评论都是积极的；与其他评论家一样，卢勒写道：“笼罩在神秘之中的小说并没有满足读者的期待，这让人感到失望。塞林格助长了这种神秘感，或者说，他什么都没做。”。。论道小说风靡与争议的背后缘故时，称小说“捕捉到了青春期存在的焦虑”、“中心人物复杂”、“对话风格平易近人”；与此同时，一些读者可能会对“纽约40年代的俗语”、“人物的自恋”、“过多的牢骚”表示反感。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;每个人心中都有一个霍尔顿&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;花费了三天时间看完了全书，默默无语，不知道该说些什么...&lt;/p&gt;
&lt;p&gt;这本书描写的对象是上世纪 50 年代，美国战后一代人的精神状态，他们酗酒、抽烟、吸毒，被称为 “垮掉的一代”，破破烂烂的T恤衫和牛仔裤，开着父母给的昂贵的跑车，抽一支接一支的大麻香烟，在公共场所旁若无人地亲吻，挑战社会传统和道德底线。因为时代背景、文化背景不同，很多中国小孩刚开始看前几章时，不是很有共鸣（比如我），甚至可能读到一半就想放弃。但是如果你坚持看完，相信我，你会不由自主的喜欢上这个满口脏话、叛逆、成绩不及格的问题少年——霍尔顿。&lt;/p&gt;
&lt;p&gt;每个人都有不同的成长经历，或顺利，或坎坷，但是没有人永远一帆风顺，每个人都有不开心、孤独、寂寞、迷茫的时候，如果你坚持看下去，你会从这个叛逆少年身上发现自己的影子，触动内心那温柔的一角。&lt;/p&gt;
&lt;h3&gt;青少年 &amp;amp; 成年人&lt;/h3&gt;
&lt;p&gt;这本书描写的对象是美国 “垮掉的一代”，和他们联系在一起的是酗酒、大麻、吸毒、叛逆等词，作为中国人，作为 90 后，我们似乎和他们没有任何交集和共同点 。但是仔细回顾历史，就会发现其实不光美国这一代人，在人类社会发展历史中，每一代人在前辈口中都是几乎一样的一无是处 。我们的父辈似乎总在对我们挑刺，认为我们叛逆、不听话，但是他们在批评我们时，却忘了他们当年也是这样过来的，就像 70 后看不顺眼 80 后，80 后看不顺眼 90 后，现在，我们90 后也看不顺眼 00 后，认为这帮熊孩子屁事不懂，一天只知道火星文、非主流、45度仰望天空 。&lt;strong&gt;而这说白了就是青少年和成年人世界的代沟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;青少年的困境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;美国硅谷创业之父 Paul Graham 的著作《黑客与画家》中第一篇文章：为什么书呆子不受欢迎，就讨论了青少年和成人世界的隔阂 。&lt;/p&gt;
&lt;p&gt;关于校园暴力，成年人不是不知道孩子们内部发生的这些事，他们知道孩子的行为有时候是极端残酷的，正如我们知道贫穷国家的人们生活极端艰难，但是，像所有人一样，成年人不喜欢揪住不放这种令人不快的事实 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学校就像是监狱一样，老师就像是狱卒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个比喻是作者形容美国公立学校的，或许在中国，即使一个学校再烂，大多数中国人都不会这么描述，中国的 “标准答案” 是学校是花园，老师辛勤的园丁。如今的成年人根本不接受青少年，他们在上班的路上顺便把孩子送到学校关着，就像周末出门时把狗送到寄养的地方。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;而在工业社会以前，青少年的角色则更加积极，他们是学徒，不是在作坊里，就是在农庄里，或者是在某艘军舰上，他们是成年人社会的低级成员。青少年尊重成年人，成年人也接受青少年。而现在，青少年在生产活动中，根本毫无用处，只能在快餐店充当廉价劳动力。所以，成年人不得不把他们集中到一起，让几个成年人看守所有的孩子 —— 学校诞生了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很新奇的看法，和中国传统意见完全不同，我们不妨保持 open mind，某种程度上这个分析是有道理的 :-P&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔阂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们总是固执己见，尤其是青少年，谁没有从逃课准备去西部生活的霍尔顿身上看到自己的影子呢？但愿不要有一天，像 Eason 在 《shall we talk》 中唱的一样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;孩童只盼望歡樂　大人只知道寄望&lt;/p&gt;
&lt;p&gt;為何都不大懂得努力體恤對方&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;陪我講　陪我講出我們最後何以生疏&lt;/p&gt;
&lt;p&gt;誰怕講　誰會可悲得過孤獨探戈&lt;/p&gt;
&lt;p&gt;難得　可以同座　何以　要忌諱赤裸&lt;/p&gt;
&lt;p&gt;如果心聲真有療效　誰怕暴露更多　你別怕我&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;成人只寄望收穫　情人只聽見承諾&lt;/p&gt;
&lt;p&gt;為何都不大懂得努力珍惜對方&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;陪我講　陪我講出我們最後何以生疏&lt;/p&gt;
&lt;p&gt;誰怕講　誰會可悲得過孤獨探戈&lt;/p&gt;
&lt;p&gt;難得　可以同座　何以　要忌諱赤裸&lt;/p&gt;
&lt;p&gt;如果心聲真有療效　誰怕暴露更多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Hold on&lt;/h3&gt;
&lt;p&gt;面对这个世界，你需要的是保持一个善良的心，并且坚持下去。每个人都有不开心、孤独、寂寞、迷茫的时候，保持一颗善良朴实的心灵，坚守住我们心中的那片麦田才是真正难能可贵的事。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有那么一群小孩子在一大块麦田里做游戏。几千几万个小孩子，附近没有一个人——没有一个大人，我是说 —— 除了我。
我呢，就站在那混帐的悬崖边。我的职务是在那儿守望，要是有哪个孩子往悬崖边奔来，我就把他捉住——我是说孩子们都在狂奔，也不知道自己是往哪儿跑，我得从什么地方出来，把他们捉住。
我整天就干这样的事。我只是想当个麦田里的守望者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;To-Do List&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;麦田里的守望者(The Catcher in the Rye)、在路上(On the Road)、了不起的盖茨比(The Great Gatsby)并称 “美国xxx小说”，盖茨比看过电影了，小说没有看过，以后有时间了再看～&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On the Road&lt;/li&gt;
&lt;li&gt;The Great Gatsby&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E9%BA%A5%E7%94%B0%E6%8D%95%E6%89%8B"&gt;麦田里的守望者 on wikipedia&lt;/a&gt;&lt;/p&gt;</summary><category term="The Catcher in The Rye"></category><category term="review"></category></entry><entry><title>学习 OFDM 及其 FPGA 实现 1 —— OFDM Basic</title><link href="http://guqian110.github.io/pages/2014/05/13/learning_ofdm_on_fpga_1_ofdm_basic.html" rel="alternate"></link><updated>2014-05-13T23:16:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-05-13:pages/2014/05/13/learning_ofdm_on_fpga_1_ofdm_basic.html</id><summary type="html">&lt;h2&gt;Why OFDM&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;移动通信的信道模型一般建立为 &lt;strong&gt;时变多径信道模型&lt;/strong&gt;，描述信道多径时延特性的一个重要统计参量是 &lt;strong&gt;均方根时延扩展&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;经过无线信道的时变多径传输，接收到的信号幅度会有起伏变化（瑞利分布 or 莱斯分布），这种现象称为 &lt;strong&gt;信号衰落&lt;/strong&gt; 。按照已调信号的带宽可以将衰落分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;窄带信号受到 &lt;strong&gt;平坦性衰落&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;宽带信号受到 &lt;strong&gt;频率选择性衰落&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;判断信号受到何种衰落：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义信道的 &lt;strong&gt;相干带宽&lt;/strong&gt; 。当数字信号的带宽越小于信道的相干带宽，则经过时变多经信道后，在信号带宽内的不同频率分量的幅度的相关性越大，不同的频率分量近似经历相同的衰落，即平坦性衰落，平坦性衰落对接收信号的波形无明显影响，码间干扰可以忽略，该系统称为 &lt;strong&gt;窄带系统&lt;/strong&gt; 。当数字信号的带宽相对于信道的相干带宽越大时，信号带宽内的不同频率分量通过信道传输时会受到不同的衰落，即频率选择性衰落，频率选择性衰落使信号中的不同频率分量产生不同的幅度变化，造成接收信号的严重失真，引起吗见干扰，产生误码，该系统称为 &lt;strong&gt;宽带系统&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3&gt;Problem&lt;/h3&gt;
&lt;h4&gt;需求&lt;/h4&gt;
&lt;p&gt;无线信道的频率资源是有限的，要求数字通信系统有效利用信道频带。希望数据传输速率越高越好。&lt;/p&gt;
&lt;h4&gt;瓶颈&lt;/h4&gt;
&lt;p&gt;在系统设计选择数字调制方式时，必须兼顾 &lt;strong&gt;频带利用率&lt;/strong&gt; 和 &lt;strong&gt;误码性能&lt;/strong&gt; 。在 AWGN 信道下，在满足误码性能的前提下，应该尽可能采用频带利用率高的数字调制方式。&lt;/p&gt;
&lt;p&gt;然而，在以衰落为特征的移动通信系统中，影响误码性能的不仅仅是 &lt;strong&gt;加性噪声&lt;/strong&gt;，还包括 &lt;strong&gt;衰落&lt;/strong&gt; 和 &lt;strong&gt;码间干扰&lt;/strong&gt; 。实现高速无线通信并非易事。&lt;/p&gt;
&lt;p&gt;为避免码间干扰，数字调制信号的最大符号速率受到很大的限制 。&lt;/p&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;信道均衡&lt;/strong&gt; 是一种经典的对抗码间干扰的技术，许多移动通信系统都采用信道均衡技术消除码间干扰。但是如果数据速率非常高，采用单载波传输数据，需要设计几十审计上百个抽头的均衡器，这简直是硬件设计的噩梦 。&lt;/p&gt;
&lt;p&gt;既要对抗码间干扰，又要满足低复杂度且高效的手段传输高速数据业务，我们可以采用另外一种技术 —— &lt;strong&gt;OFDM&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;OFDM History&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;多载波调制技术早在 20 世纪 50年代末至 60 年代初就已经应用于军事高频无线通信中，由于实现复杂，没有被广泛应用 。OFDM 就是一种多载波调制，其子载波间隔是子载波符号间隔的倒数，各子载波的频谱是重叠的，这种重叠可以使频谱效率显著提高 。&lt;/p&gt;
&lt;p&gt;20 世纪 70 年代，Weinstein 和 Ebert 提出用 &lt;strong&gt;离傅里叶变换(DFT)&lt;/strong&gt; 及其 &lt;strong&gt;逆变换(IDFT)&lt;/strong&gt; 进行 OFDM 多载波调制方式的运算。&lt;/p&gt;
&lt;p&gt;DFT 和 IDFT 的快速计算方法：FFT 和 IFFT 使 OFDM 能够以低成本的数字方式实现 。&lt;/p&gt;
&lt;p&gt;在 20 世纪 80 年代，随着 OFDM 理论的不断完善、数字信号处理及微电子技术的不断快速发展，OFDM 技术也逐步走向实用化 。&lt;/p&gt;
&lt;p&gt;大约从 20 世纪 90 年代起，OFDM 技术开始应用于各种有线及无线通信中，包括：DSL、DAB、DVB、WLAN等。OFDM 已经成为下一代蜂窝移动通信空中接口的候选技术 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;OFDM Theory&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Orthogonal frequency-division multiplexing (OFDM) 的基本原理是将高速的数据流分解为多路并行的低速数据流，在多个载波上同时进行传输。&lt;/p&gt;
&lt;p&gt;通过将高速数据分解为多个并行低速速率，克服了信道时延扩展对数据速率的限制，其中各个子载波之间是相互正交的关系，如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="carrier wave" src="/images/learning-ofdm-basic/carriers.png" /&gt;&lt;/p&gt;
&lt;p&gt;OFDM 每个子载波的调制方式可以相互不同，比如 BPSK、QPSK、QAM 等方式 。&lt;/p&gt;
&lt;p&gt;(OFDM 系统的内容可以写一本书了，简单写写 :-P )&lt;/p&gt;
&lt;h3&gt;OFDM 基带数字实现&lt;/h3&gt;
&lt;h4&gt;发送端 Transmitter&lt;/h4&gt;
&lt;p&gt;基带系统发送端要实现的功能是将待发送序列 {A1,A2,A3...} 变换，得到复包络的采样值 {a1,a2,a3...} 。&lt;/p&gt;
&lt;p&gt;为了实现 OFDM 调制的基带数字实现，首先要将 OFDM 信号的复包络进行采样，成为离散时间信号 。根据公式(《通信原理》)，采样结果正好是对发送序列进行离散傅里叶反变换(IDFT)的结果，所以，我们可以 &lt;em&gt;借助 IDFT 即可得到 OFDM 复包络的时间采样 。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;发送端框图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="transmitter" src="/images/learning-ofdm-basic/transmitter.png" /&gt;&lt;/p&gt;
&lt;h4&gt;接收端 Receiver&lt;/h4&gt;
&lt;p&gt;基带系统接收端要实现的功能是对采样序列 {a1,a2,a3...} 进行变换，得到发送端发送过来的信息序列 {A1,A2,A3...} 。&lt;/p&gt;
&lt;p&gt;接收端通过 I/Q 正交解调可以恢复 OFDM 信号的复包络，将其采样得到的时间序列 。因为发送端采用的 IDFT 是可逆变换，所以对采样结果进行 DFT 就可以得到发送序列 。&lt;/p&gt;
&lt;p&gt;当序列的点数为 2 的整幂次时，DFT 和 IDFT 存在快速算法： FFT 和 IFFT 。&lt;/p&gt;
&lt;p&gt;接收端框图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="receiver" src="/images/learning-ofdm-basic/receiver.png" /&gt;&lt;/p&gt;
&lt;h3&gt;循环前缀 cyclic prefix&lt;/h3&gt;
&lt;p&gt;为了有效对抗多径信道的时延扩展，OFDM 系统由多个子载波构成，只要子载波的取值可以满足符号周期远大于信道的时延扩展，就可以达到目标。在此基础上，还需要采取措施消除前后两个 OFDM 符号之间的 &lt;strong&gt;码间干扰 ISI&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;一种方法是在每个 OFDM 符号之间插入 &lt;strong&gt;保护间隔 Guard Interval&lt;/strong&gt; 。为了对抗信号因信道延迟的影响，Gurad interval(Tg) 长度要大于最大的 Delay spread，即 Tg &amp;gt; delay spread time。&lt;/p&gt;
&lt;p&gt;在保护区间未放信号的 OFDM 系统称 ZP-OFDM(zero padding)。ZP-OFDM 有比较低的传输功率，但在接收端接收于 zero padding 区域信号时，会破坏载波的正交性造成 “&lt;strong&gt;载波间的干扰（ICI）&lt;/strong&gt;”，所以复制 OFDM symbol 后半段信号并摆放于保护区间内，称之为 &lt;strong&gt;循环字首(cyclic prefix)&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3&gt;加窗技术&lt;/h3&gt;
&lt;p&gt;前面介绍了 OFDM 符号的生成、循环前缀消除码间干扰，但是此时符号边界有尖锐的相位跳变，由此可知，OFDM 的带外衰减是比较慢的 。虽然随着载波数目的增大，OFDM 信号的带外衰减会增加，但是仍然不够快 。&lt;/p&gt;
&lt;p&gt;为了使 OFDM 信号的带外衰减更快，可以采用对单个 OFDM 符号加窗的方法 。OFDM 的窗函数可以使信号的幅度在u符号边界更平滑地过渡到 0 。常用的窗函数是 &lt;strong&gt;升余弦滚降窗&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;增大滚降因子虽然能够使带外衰减更快，但降低了 OFDM 系统对多经实验的容忍能力，所以 &lt;em&gt;在实际系统设计中，应当选择较小的滚降因子 。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;OFDM 系统设计&lt;/h3&gt;
&lt;p&gt;OFDM 系统框图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ofdm-system" src="/images/learning-ofdm-basic/ofdm_system.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;交织&lt;/strong&gt; 是为了克服深衰落发生突发差错的影响，如果交织器的长度足够大，解交织后可将突发差错改造为独立差错，再通过纠错译码来纠正 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在发送端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;二进制数据&lt;/em&gt; 通过纠错编码、交织后映射到 QAM 星座得到 &lt;em&gt;一个 QAM 复数符号序列&lt;/em&gt;，再经过并串转换，得到 &lt;em&gt;N个并行 QAM 符号&lt;/em&gt;，每个符号进行 IFFT，将 OFDM 复包络的频域样值变换为 &lt;em&gt;时域样值&lt;/em&gt;，进行并串转换，将时域样值变换为按时间顺序排列的 &lt;em&gt;时域样值&lt;/em&gt;，然后在每个 OFDM 符号前插入前缀，通过 D/A，将离散的复包络变成 &lt;em&gt;连续时间的复包络&lt;/em&gt; 。再将复包络的 I(t) 和 Q(t) 正交调制得到 &lt;em&gt;OFDM信号&lt;/em&gt;，将基带信号上变频到射频，经过功放，发送出去 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在接收端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收端于发送端进行相反的变换，恢复出原数据 .&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1446684/"&gt;《通信原理》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4130536/"&gt;《移动通信原理》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Orthogonal_frequency-division_multiplexing"&gt;OFDM wikipedia&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="OFDM"></category></entry><entry><title>Yocto 从零单排 1 —— 入门</title><link href="http://guqian110.github.io/pages/2014/05/12/learning_yocto_from_zero_1_getting_started.html" rel="alternate"></link><updated>2014-05-12T12:46:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-05-12:pages/2014/05/12/learning_yocto_from_zero_1_getting_started.html</id><summary type="html">&lt;p&gt;最近做嵌入式，开始学习 Yocto 项目相关的知识。网上关于 Yocto 的介绍、博客不少，但是大多数都是英文的。中文博客也有，不过都是一些大牛写的笔记，对于新手来说，并不是很容易懂,于是，就有了我的 “Yocto 从零单排” ^_^&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Yocto 从零单排第 1 期 —— 入门，了解什么是 Yocto&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习一个新事物，当然是官网的东西最权威最简洁明了，不易出错（避免二次理解），以下内容来自 &lt;a href="(https://www.yoctoproject.org/)"&gt;Yocto 官网&lt;/a&gt; 和对其的翻译，本文只是我的学习笔记，详细内容见官网：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="(https://www.yoctoproject.org/)"&gt;Yocto Project 官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;What &amp;amp; Why Yocto&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;What is Yocto&lt;/h3&gt;
&lt;p&gt;官网上的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The Yocto Project is an open source collaboration project that provides templates, tools and methods to help you create custom Linux-based systems for embedded products regardless of the hardware architecture. &lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 &lt;em&gt;“Yocto 是一个开源协作项目，它通过提供模板、工具和方法来帮助开发者为嵌入式产品订制基于 LInux 的系统，而不用关注硬件结构。”&lt;/em&gt; 这样，它就可以极大地简化开发过程，因为你不用再从头裁剪一个完整的Linux发布版本，后者通常包括许多你并不需要的软件。&lt;/p&gt;
&lt;p&gt;它由许多硬件制造商、开源操作系统提供商和电子器件公司一起合作于 2010 年建立，目的是为了使混乱的嵌入式 Linux 开发更简单有序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; Yocto 项目有时也被称为 "Umbrella" 项目&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.P.S.&lt;/strong&gt; yocto 的名字是委员会决定的，这个词本来是国际单位中的最小的单位，表示 10^-24，也就是千万亿分之一，在此寓意 “基本的粒子” —— 贯穿嵌入式 Linux 开发过程的工具。&lt;/p&gt;
&lt;h3&gt;Why using Yocto&lt;/h3&gt;
&lt;p&gt;它是一个完整的嵌入式 Linux 开发环境，包含工具(tools)、元数据(metadata)和文档(documentation)——你需要的一切。这些免费工具(包含仿真环境emulation environments、调试器debuggers、应用程序开发工具Application Toolkit Generator)很容易上手，功能强大，并且它们可以让系统开发以最优化的方式不断前进，而不用担心在系统原形阶段的投资损失。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Yocto Project Charter&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Yocto 作为一个开源项目，其本质就是欢迎大大小小的参与者。&lt;/p&gt;
&lt;p&gt;Yocto 的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为进一步的开发、定制 LInux 平台，基于 Linux 系统的开发提供一个写作平台&lt;/li&gt;
&lt;li&gt;鼓励 Linux 平台开发的标准化和组建的重利用&lt;/li&gt;
&lt;li&gt;专注于创造一个构建系统的基础设施和技术，能够满足所有用户的需求，并增加了缺失的功能——来自于 OpenEmbedded 架构&lt;/li&gt;
&lt;li&gt;文档化可以用到的工具和方法，使开发人员更容易使用它们&lt;/li&gt;
&lt;li&gt;尽可能地保证这些开发工具和系统架构无关&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Governance &amp;amp;  Administration&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Yocto 是一个开源项目，它由维护者和 &lt;a href="(https://www.yoctoproject.org/about/governance/advisory-board)"&gt;Yocto Project Advisory Board&lt;/a&gt; 领导。&lt;/p&gt;
&lt;h3&gt;Technical Leadership&lt;/h3&gt;
&lt;p&gt;Yocto 项目的 &lt;a href="(https://www.yoctoproject.org/about/governance/technical-leadership)"&gt;technical leadership&lt;/a&gt; 和 Linux Kernel 的类似，是一个分级的、任人唯贤的，由一个 “仁慈的独裁者”(benevolent dictator) 领导的组织。组织的上层负责决策，同时也是下层子系统的领导者，下层维护者负责处理细节问题，比如bug 和补丁。&lt;/p&gt;
&lt;p&gt;Yocto 项目架构师：Richard Purdie&lt;/p&gt;
&lt;p&gt;子系统/ BSP 层维护者：...&lt;/p&gt;
&lt;h3&gt;The Yocto Project Community&lt;/h3&gt;
&lt;p&gt;Yocto 是由社区的专家和志愿者共同协助设计、开发的，他们统称为贡献者(contributors)，贡献者包括任何可能对 Yocto 有贡献的人，比如代码开发人员、文档编写者、兴趣小组、管理小组、维护者和技术领导小组等。&lt;/p&gt;
&lt;p&gt;下图简明说明了 Yocto 项目社区的各个成员之间的相互影响的关系：&lt;/p&gt;
&lt;p&gt;&lt;img alt="yocto-community" src="https://www.yoctoproject.org/sites/yoctoproject.org/files/page/os63yoctodev.org-diagramv11.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Linux Foundation&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="(http://www.linuxfoundation.org/)"&gt;Linux Foundation&lt;/a&gt; 是一个致力于促进 Linux 发展的非盈利组织，关于它的主要事实：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赞助 Linux 的创造者 Linus Torvalds 的工作&lt;/li&gt;
&lt;li&gt;持有 Linux 商标&lt;/li&gt;
&lt;li&gt;经营着 Linux.com，每个月拥有活跃的 2000,000 的 Linux 开发人员和用户 &lt;/li&gt;
&lt;li&gt;主持着多个推进或标准化 Linux 的工作小组&lt;/li&gt;
&lt;li&gt;举行世界上顶尖的 Linux 会议，包括 LinuxCon&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;The Linux Foundation and the Yocto Project&lt;/h3&gt;
&lt;p&gt;Linux Foundation 是业界最大的非盈利组织，作为 Linux 的维护者和 Linux 创造者 Linus Torvalds 的雇主，没有比它更适合 Yocto 项目生存的了。Linux Foundation 主持 Yocto 项目作为一个开源项目，它提供了一个厂商中立的协作环境。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Yocto Project 简介&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Yocto 项目中有很多独立的子项目，这些子项目在嵌入式 Linux 开发中扮演着重要的角色，Yocto 项目则整合它们使它们可以相互协同工作。&lt;/p&gt;
&lt;h3&gt;Openembedded Core&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Metadata Set&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;元数据集(Metadata Set) 按 "层" 进行排列，这样一来每一层都可以为下面的层提供单独的功能。基层是 OpenEmbedded-Core 或 oe-core，提供了所有构建项目所必需的常见配方(recipes)、类和相关功能。&lt;/p&gt;
&lt;p&gt;Openembedded Core 包含了 核心方法(recipes)的基础层、类(classes) 和 相关文档，它们是各种嵌入式 Linux 系统(包含 Yocto 在内)的共同基础。Openembedded Core 由 Yocto Project 和 OpenEmbedded 项目共同维护，将 Yocto 和 Openembedded 分开的层是 meta-yocto 层，该层提供了 Pocky 发行版配置和一组核心的参考BSP。&lt;/p&gt;
&lt;p&gt;Openembedded 项目本身是一个ie独立的开源项目，具有可与 Yocto 项目交换的配方(recipes)，但两者具有不同的治理和范围。&lt;/p&gt;
&lt;h3&gt;Swabber&lt;/h3&gt;
&lt;p&gt;Swabber 可以提供一种检测主机系统的机制，一旦检测到问题，你就可以分析这是否真的是个问题。&lt;/p&gt;
&lt;h3&gt;Application Development Toolkit (ADT)&lt;/h3&gt;
&lt;p&gt;Application Development Toolkit (ADT) 能够让系统开发人员为他们使用 Yocto Project 工具创建的发行版提供软件开发工具包 (SDK)，为应用程序开发人员提供了一种针对系统开发人员提供的软件栈进行开发的方法。ADT 包含一个交叉编译工具链、调试和分析工具，以及 QEMU 仿真和支持脚本。ADT 还为那些喜欢使用集成开发环境 (IDE) 的人提供了一个 Eclipse 插件。&lt;/p&gt;
&lt;h3&gt;AutoBuilder&lt;/h3&gt;
&lt;p&gt;AutoBuilder 是一款能够不断自动构建 Yocto 的工具，它启用自动化的 Quality Assurance(QA) 活动。&lt;/p&gt;
&lt;h3&gt;BitBake&lt;/h3&gt;
&lt;p&gt;BitBake 是一个构建引擎。它读取配方(recipes)并按照配方来获取、构建程序包，并将结果导入可启动的系统映像中。BitBake 是 Yocto 项目的核心组件。&lt;/p&gt;
&lt;h3&gt;Build Appliance&lt;/h3&gt;
&lt;p&gt;Build Applicance 是一台运行 Hob 的虚拟机，它可以让你在非 Linux 环境下构建启动一个基于 Yocto 的嵌入式系统镜像。并不建议在日常开发中使用 Build Applicance，应该将其用在测试和体验 Yocto 项目上。&lt;/p&gt;
&lt;h3&gt;Cross-Prelink&lt;/h3&gt;
&lt;p&gt;Cross-Prelink 为交叉编译开发环境提供预链接，这样可以在应用程序启动时提高其性能表现。&lt;/p&gt;
&lt;h3&gt;Eclipse IDE Plug-in&lt;/h3&gt;
&lt;p&gt;Eclipse IDE Plug-in 把 Yocto ADT 和工具链集成到 Eclipse IDE 中。&lt;/p&gt;
&lt;h3&gt;EGLIBC&lt;/h3&gt;
&lt;p&gt;Embedded GLIBC (EGLIBC) 是 GNU C Library (GLIBC) 的一个变体，旨在能够在嵌入式系统上运行。EGLIBC 的目标包括减少内存占用、让组件可配置、更好地支持交叉编译和交叉测试。EGLIBC 是 Yocto Project 的一部分，但在它自己的治理结构内加以维护。&lt;/p&gt;
&lt;h3&gt;Hob&lt;/h3&gt;
&lt;p&gt;Hob 是 BitBake 的图形前端，它的主要目的是使常用命令更加方便使用。&lt;/p&gt;
&lt;h3&gt;Matchbox&lt;/h3&gt;
&lt;p&gt;Matchbox 是 一个基于 X Window 系统的开源环境，主要用于非桌面系统、屏幕大小、输入方式或系统资源有限的嵌入式设备中，比如手持设备、机顶盒、电话亭等。&lt;/p&gt;
&lt;h3&gt;Poky&lt;/h3&gt;
&lt;p&gt;Poky 是 Yocto Project 的一个参考构建系统。它包含 BitBake、OpenEmbedded-Core、一个板卡支持包 (BSP) 以及整合到构建过程中的其他任何程序包或层。Poky 这一名称也指使用参考构建系统得到的默认 Linux 发行版，它可能极其小 (core-image-minimal)，也可能是带有 GUI 的整个 Linux 系统 (core-image-sato)。&lt;/p&gt;
&lt;p&gt;你可以将 Poky 构建系统看作是整个项目的一个参考系统，即运行中进程的一个工作示例。在下载 Yocto Project 时，实际上也下载了可用于构建默认系统的这些工具、实用程序、库、工具链和元数据的实例。这一参考系统以及它创建的参考发行版都被命名为 Poky。你还可以将此作为一个起点来创建您自己的发行版，当然，你可以对此发行版随意命名。&lt;/p&gt;
&lt;p&gt;构建一个系统必须有工具链(toolchain)：一个编译器(compiler)、汇编器(assembler)、链接器(linker)以及为给定架构创建二进制可执行文件所需的其他二进制实用程序(other binary utilities)。Poky 使用了 GNU Compiler Collection (GCC)，不过你也可以指定其他工具链。Poky 使用了一种名为交叉编译(cross-compilation) 的技术：在一个架构上使用工具链为另一个架构构建二进制可执行文件（例如，在基于 x86 的系统上构建 ARM
发行版）。开发人员常常在嵌入式系统开发中使用交叉编译来利用主机系统的高性能。&lt;/p&gt;
&lt;h3&gt;Pseudo&lt;/h3&gt;
&lt;p&gt;构建一个系统时，有时候有必要把自己模拟为系统管理员进行一些操作，比如定义某个文件的归属权和权限配置等。Pseudo 是一个可以模拟 root 的程序，使普通用户也可以具有 root 权限。&lt;/p&gt;
&lt;h3&gt;Toaster&lt;/h3&gt;
&lt;p&gt;Toaster 是一个 API，它基于 web 界面来使用 BitBake，你可以通过浏览器来查阅 Toaster 收集到的你的系统的相关信息。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="(https://www.yoctoproject.org/)"&gt;Yocto Project 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/linux/library/l-yocto-linux/index.html?ca=dat"&gt;Build custom embedded Linux distributions with the Yocto Projec&lt;/a&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="Yocto"></category></entry><entry><title>我的 PKM</title><link href="http://guqian110.github.io/pages/2014/05/06/my_pkm.html" rel="alternate"></link><updated>2014-05-06T15:57:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-05-06:pages/2014/05/06/my_pkm.html</id><summary type="html">&lt;h2&gt;PKM&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;什么是 PKM&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;个人知识管理(Personal Knowledge Management)是一种新的知识管理的理念和方法，能将个人拥有的各种资料、随手可得的信息变成更具价值的知识，最终利于自己的工作、生活。通过对个人知识的管理，人们可以养成良好的学习习惯,增强信息素养，完善自己的专业知识体系,提高自己的能力和竞争力，为实现个人价值和可持续发展打下坚实基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知乎上的&lt;a href="http://www.zhihu.com/question/19576595"&gt;回答&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;个人知识管理的概念最早是由Paul Dorsey教授提出的,原文为” Personal Knowledge Management should be viewed as a set a problem-solving skills that have both a logical or conceptual as well as physical or hands-on component. ”,中文意思就是: 个人知识管理应该被看作既有逻辑概念层面又有实际操作层面的一套解决问题的技巧与方法。所以个人知识管理主要讲的是一种方法论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Personal_knowledge_management"&gt;Personal knowledge management on wikipedia&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;为什么写这篇 blog&lt;/h3&gt;
&lt;p&gt;从小到大，上了这么多年的学，每个人都有自己的学习习惯和知识管理方法。这篇 blog 是在我 Google、知乎问答、参考相关博客内容的基础上，总结出的学习习惯和使用各种工具的经验，写这篇博客的目的不是秀逼格有多高（估计很多人都看不上），也不是所谓的教程（根本不够资格），而是&lt;strong&gt;为了分享和讨论&lt;/strong&gt; :-D&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;获取知识&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;总结我的知识来源，大致可以分为 3 类：纸质书籍、网络资源、其他 。分别总结如下&lt;/p&gt;
&lt;h3&gt;书籍&lt;/h3&gt;
&lt;p&gt;书籍上的知识占到了我总来源的 50% 。相比于电子读物，我更喜欢阅读纸质书籍。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;纸质书籍更适合深度阅读&lt;/p&gt;
&lt;p&gt;这就是为什么很多码农桌子上都有那么几本经典著作，虽然他们的电脑里面也保存着相应的电子版。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;纸和笔是最原始的阅读工具，但是也是最有效，或者 &lt;em&gt;最自由的&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这是目前电子书籍/笔记最大的缺点，写一段标注文字，画一个草图，列一个表格，插入一个公式，不仅需要花费很多时间，而且操作很繁琐，结果也往往差强人意 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阅读体验&lt;/p&gt;
&lt;p&gt;毫无疑问纸质书籍的阅读体验更好一些，不然 Kindle 也就不会出现了 :-D&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至于读书笔记，我的方法很原始 =.=&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;书边笔记，这样笔记和书是一体的，如果空白不够大，有便利贴&lt;/li&gt;
&lt;li&gt;标记符号，简单的标记，比如 &lt;code&gt;？&lt;/code&gt; 表示疑问、&lt;code&gt;！&lt;/code&gt; 表示注意、&lt;code&gt;||&lt;/code&gt; 表示分层、&lt;code&gt;*&lt;/code&gt; 表示重要内容、圈出关键名词/定义 etc&lt;/li&gt;
&lt;li&gt;整理笔记，定期将书本上的笔记整理到 Blog / Evernote 中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;网络&lt;/h3&gt;
&lt;p&gt;互联网时代，善于利用互联网上的资源，相当于守着一座 “知识金山”&lt;/p&gt;
&lt;p&gt;每天面对海量的信息，如果不加以过滤，我们就会被淹没在信息的海洋之中，浪费了大量时间而毫无收益。我的信息来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RSS 订阅&lt;/p&gt;
&lt;p&gt;以前使用 Google Reader，自从 GR 死了之后，转到了 &lt;a href="http://cloud.feedly.com"&gt;Feedly&lt;/a&gt; 。主要是搜集一些大牛的博客，订阅 &lt;em&gt;真正&lt;/em&gt; 感兴趣的内容。&lt;/p&gt;
&lt;p&gt;RSS 订阅是个时间黑洞，曾经我的 RSS 订阅长期 1000+，而且我从来没有看完过，作为处女座强迫症患者，有时候花费了很多时间，甚至占用上课学习时间。后来看到 &lt;a href="http://mindhacks.cn/"&gt;刘未鹏&lt;/a&gt; 在 &lt;a href="http://book.douban.com/subject/6709809/"&gt;《暗时间》&lt;/a&gt; 中有一篇文章讲自己的学习习惯，才明白原来这是源自人不肯 “关上一扇门” 的心理。&lt;strong&gt;事实上，真正宝贵的信息，在其他来源你也可以接触到。&lt;/strong&gt;于是，我退订了很多从来不看或者很少看的源，从此，告别阅读焦虑。:-D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Google / Wiki&lt;/p&gt;
&lt;p&gt;拒绝做伸手党，我们遇到的很多问题实际上别人都遇到过了，并且提供了解决方法。在网上发帖问别人的时候，很多问题都可以从 FAQ、官方文档中都能找到答案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;知乎 / Quora / Stack Overflow&lt;/p&gt;
&lt;p&gt;这绝对是一个值得一生相伴的好东西 :-P 长期混迹于此，瞬间高大上的境界、令人仰视的逼格不再是梦想，相信我，你的人生因此而改变！（利益相关：非广告，深度沉迷者）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;论坛 / 豆瓣小组&lt;/p&gt;
&lt;p&gt;当然是讨论知识的论坛，而非八卦娱乐主题的论坛。长期泡论坛，不仅可以寻找答案，帮助别人，还可以扩展自己的见识，结识大牛，论坛里面的老油条个个都是大神。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用到的工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://cloud.feedly.com"&gt;feedly&lt;/a&gt; 是一款 RSS 阅读器&lt;/p&gt;
&lt;p&gt;同类产品还有很多，比如国外的 Diggo、国内的鲜果、豆瓣九点等 。feedly 在国内访问并不是很稳定，即使这样，我仍然选择它是因为舒服的排版、另外功能上有些源 Diggo 无法抓取到 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://getpocket.com/a/"&gt;pocket&lt;/a&gt; 是一个用于管理互联网文章的应用程序&lt;/p&gt;
&lt;p&gt;PC 上有 chrome 插件，手机上也有相应的客户端，这样我们就可以很方便地在各个平台上、把各个源的文章都收集到一起，稍后阅读（比如排队、休息时）。&lt;/p&gt;
&lt;p&gt;我还它当作汇聚资料的容器使用，比如我写这篇博客，从网上搜集到很多相关内容，把我认为重要的保存在 pocket 当中，然后再做整理 。&lt;/p&gt;
&lt;p&gt;P.S. 还有另外一个方法，feedly 上的文章可以直接保存到 Evernote 中，但是这是付费功能，虽然可以用 ifttt 解决，但是这种方法无法收集其他地方的文章，而且，不知道是不是因为天朝的原因，ifttt 收集的速度并不快，一般要 30 分钟左右才能在 Evernote 中看到收集的文章，最重要的一点，在 Evernote 中看文章，眼睛一直盯着屏幕的右下角，都快成斜眼了 T_T，so 还是 pocket 好！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;p&gt;所谓其他，就是在其它地方，看到的、想到的，使用手机肯定是最方便的。我只使用过两款应用 Google Keep 和 Evernote 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/Google_Keep"&gt;Google Keep&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google 发布的笔记软件，和其他各种笔记类软件相比，Keep 的功能实在是 “弱爆了”，或许称之为 &lt;em&gt;便签 sticker&lt;/em&gt; 更合适 .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://evernote.com"&gt;Evernote&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大名鼎鼎的笔记软件，功能非常强大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有很多人把这两个软件做比较&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20869752"&gt;Google Keep VS Evernote，你还会继续使用 Evernote 吗？为什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20859926"&gt;刚宣布 Reader 关停，Google Keep 随即上线，这是用来跟 Evernote 竞争的产品吗？谷歌做这个有什么优势？谷歌如何让用户有安全感地放心使用旗下产品？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;事实上，这两个产品的定位根本就不一样，引用里面的某个答案&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Google Keep 偏重于随时随地记录碎片知识, 建立待办事项, 是个效率工具.完成的事情就随手一滑存档掉, 并没有提供更一步的存储整理的途径. 所以 &lt;strong&gt;Google Keep并不是知识的终点&lt;/strong&gt;,它只是用来记录临时想法的,这恰恰和它的logo形象十分契合(想想卡通里面人物突然奇思妙想了...灯泡就亮了- -). 它就是用来存储这些"灯泡"的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般，我使用 Keep 来记录平时的想法，也把它当作便签来使用，记录杂事，有部分 to-do-list 的作用。毕竟，Evernote 缓慢的启动速度和不方便的操作实在是太影响心情了 。&lt;/p&gt;
&lt;p&gt;还有一个答案，不能同意更多：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;归根到底，&lt;strong&gt;keep是一个轻量级GTD系统，它要解决的问题和evernote是不同的。那些认为keep可以取代evernote的用户，他们本身就不需要evernote&lt;/strong&gt; ——对他们而言，evernote的强大反而太过繁冗，已是多余。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;整理知识&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;获取到知识，下一步就是整理和吸收它们了。&lt;/p&gt;
&lt;h3&gt;Evernote&lt;/h3&gt;
&lt;p&gt;说道 PKM，就不得不提 Evernote 。这么一款大名鼎鼎的笔记软件，有很多人在使用，分享使用技巧 。搜集到一个很全的资源帖：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.douban.com/group/topic/28544265/"&gt;印象笔记 Evernote 教程 (douban)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面总结了官方的教程、民间高手的使用心得。基本上花费一下午的时间在豆瓣 &amp;amp; 知乎上逛一逛，就可以成为高手了 。&lt;/p&gt;
&lt;p&gt;我不是 EN 的高级用户，也没有专门去探索进阶用法，我只是把它当作单纯的电子笔记本，不代替便签（Google Keep），也不代替知识管理软件（Wiz、OneNote），一般也就以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存博客草稿，毕竟 Keep 这样的便签不适合于写大段文字&lt;/li&gt;
&lt;li&gt;记录私人笔记&lt;/li&gt;
&lt;li&gt;摘抄网络上的精彩内容（也是为写 blog 服务），EN 在 chrome 上的 web clipper 插件真心不错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;忍不住跑题说一下我的使用感受：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：全平台、全功能、云同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：大而无当，这是一款变形金刚一样的软件，功能强大到有人为此写出一本厚厚的&lt;a href="http://book.douban.com/subject/24524405/"&gt;使用教程&lt;/a&gt; 。但是，强大的功能也就意味着软件的笨重和操作的繁琐。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和便签类应用相比&lt;/p&gt;
&lt;p&gt;它太笨重了！ 与 Keep 简洁的操作（快速新建、左右滑动归档、撤销），这货简直慢的让人无法忍受。知乎上有个贴子专门讨论这个问题：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20820355"&gt;为什么有人对印象笔记没有任何兴趣呢？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中有个回答，也是我的感受：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你明知道它的功能正是你需要的，但打開它就是不想用，也不知道從何用起。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和知识管理类应用相比&lt;/p&gt;
&lt;p&gt;仅个人意见，EN 并不适合作知识管理 。它只有 笔记本 和 笔记本组 这两个概念，也就是说，它最多支持 2 级目录，而实际上，我们的知识体系应该是和树一样，不断地分支增长的 。其他笔记类应用比如 Wiz 笔记就要比它好很多 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 我曾经也为用 Keep 还是 EN 纠结过，最终我选择了 Keep，直到后来我看到这句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那些认为keep可以取代evernote的用户，他们本身就不需要evernote&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我才明白，我根本就不需要 EN！我曾经尝试过在 EN 中建立一个完备正交的目录，后来发现，其中最重要的部分和我的博客目录是一模一样的 。我已经有个博客了，为什么还要 EN 呢？（个人认为 blog 比 EN 更好，原因后文解释）&lt;/p&gt;
&lt;p&gt;事实上很多人根本就没有管理知识的必要，因为他们没有那么多知识需要整理。使用 Evernote 的动机无非就是人类的天性 ——“收藏” 癖好，看到什么东西都想收藏，比如用过的袋子，小本子，现在轮到网页，图片，链接了。可是我们收藏了以后还会去看么？就像我们硬盘里面收集的 “世界一百部名著” 一样，它静静地躺在硬盘中，积累了厚厚的灰 。&lt;/p&gt;
&lt;p&gt;EN 的 logo 是一只大象，寓意来自美国谚语 “An elephant never forgets”，大象的记忆力很强，这和它的宣传 “Evernote 是你的第二个大脑” 是一致的，而且是一个永远不会忘记的大脑。&lt;/p&gt;
&lt;p&gt;所以，为什么不就这么用呢？在 EN 中新建几个笔记本，把我们不需要记住但是以后可能会用到的 “知识” 丢进去，加上简单的标签，然后我们只需要记住在笔记里有这么个记录，然后其他的全都可以忘掉了，需要的时候去搜索一下就可以了。利用它强大的接口功能，记录杂事、美食、私人日记、生活小感悟、小常识，但是对于体系结构化的知识，个人认为写一个技术博客是更优的选择（理由在后文） :-P&lt;/p&gt;
&lt;p&gt;漫长的跑题终于结束了，总之就是，&lt;strong&gt;把 EN 当作收集小知识的笔记本即可，个人知识管理选择其他软件/写博客是更优的选择。给它做做减法，使用你需要的功能，不要成为工具的奴隶。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;XMind&lt;/h3&gt;
&lt;p&gt;目前还处于用笔和纸的阶段，大概了解了一些 XMind 的用途，感觉很好很强大。尤其是用它建立的结构化的提纲，对于整理文章、知识体系结构有巨大的帮助。还在探索中，更加进阶的功能和使用心得以后再总结。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;使用/分享知识&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;月光博客中的一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知识共享和传播，是为了让别人知道你知道的知识，并得到信息的反馈，为什么要分享，不在于你认识什么人，而在于什么人认识你，不在于什么人影响了你，而在于你影响了什么人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;获取、整理知识，接下来就是使用/分享知识。只有把别人的东西转化为自己的，才算是掌握了。我觉得最好的方法就是写 Blog。&lt;/p&gt;
&lt;h3&gt;为什么要写 Blog&lt;/h3&gt;
&lt;p&gt;这个问题曾经我也问过自己，以前只是看到学长学姐们写的 Blog，感觉很厉害，认为自己也应该有这样一个。后来看到 &lt;a href="http://book.douban.com/subject/6709809/"&gt;暗时间&lt;/a&gt; 里面的两篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking/"&gt;《书写是为了更好的思考》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/"&gt;《为什么你从现在开始就应该写博客》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;认真总结了一下写博客的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;总结知识&lt;/p&gt;
&lt;p&gt;这是我写 Blog 最直接的一个动机。只有把别人的东西转化为自己的，才算是真正掌握了。记录下自己某段时间的学习收获，思考感悟，不仅可以帮助自己回忆以前的知识，说不定还可以帮助到别人（我就是受益者，从别人的博客中学习到了很多知识）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;帮助思考&lt;/p&gt;
&lt;p&gt;这是写 Blog 最大的好处。这个好处不仅仅局限于写 Blog 这种形式，无论以什么方式，只要写下你的思考过程和内容，就可以帮助你思考问题，也就是 &lt;strong&gt;书写&lt;/strong&gt; 的好处。&lt;a href="http://book.douban.com/subject/6709809/"&gt;《暗时间》&lt;/a&gt; 里面有个很形象的比喻：&lt;em&gt;人的思考就像是在黑暗中打着手电筒前行。&lt;/em&gt;因为人的脑力资源是有限的，所以我们经常遇到想问题想岔了，然后回不到原点的情况。书写不仅可以帮助我们缓存手电筒照到的区域，还可以帮助我们扩大手电筒的照亮直径。比如我写这篇博客，开始只是记录下别人的 PKM 的方法和工具的关键字，然后在大纲和简记的基础上，补充自己的心得完成的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到交流帮助&lt;/p&gt;
&lt;p&gt;Blog 相比于 EN 的最大的优势。写 Blog 是开放的，别人可以随意看，而写 EN 我们只能自己看（EN 的共享笔记体验并不好）。每个人的思考都有盲点，你的盲点可以在别人那里得到补充，知识和思考在讨论得到提炼升华。&lt;/p&gt;
&lt;p&gt;还有一个好处是，敦促你必须认真思考。想象你在给一个玩偶小熊讲一个原理、技术，那么你必须 &lt;em&gt;“彻底反思整个知识体系，弄清这座大厦的根基在什么地方，弄清它的骨架在什么地方，一砖一瓦到底是怎么垒起来的。设想自己在 11 层，给处于 1 层的小熊讲明白一件事。”&lt;/em&gt; 现在你不需要小熊了，因为有更挑剔的的对手 —— 你的博客的读者。你偷懒不写/写出无意义的文章，他们不会像小熊一样包容你，只有写出高质量的博客才对得起观众，否则就是浪费他们的时间了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锻炼心智&lt;/p&gt;
&lt;p&gt;激励你去坚持学习和思考：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了让你的博客有价值，你必须不断地总结自己学习的结果，比必须不断思考，给出比别人深刻、读到的见解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让你学会持之以恒地做一件事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;理性地书写的时候，大脑逐渐进入推理分析模块，一切不愉快的情绪，烦躁感都会逐渐消隐下去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述体验在写代码时也能体会到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锻炼文字功底&lt;/p&gt;
&lt;p&gt;对于码农，这算是优点么？反正没有坏处 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;写在最后&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;总结一下总的流程就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取知识&lt;/strong&gt;：书籍 + feedly + pocket + Google Keep&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整理知识&lt;/strong&gt;：Evernote + XMind&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 / 分享知识&lt;/strong&gt;：Blog&lt;/p&gt;
&lt;p&gt;总结出来并且在实际行动中加以利用才是王道。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sand-ox.com/2011/02/pkm-tools/"&gt;我，和我的知识工具们 (2011-02-15 更新)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.williamlong.info/archives/3388.html"&gt;我的知识管理工具列表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/topic/19557303"&gt;Evernote on zhihu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/topic/19558457"&gt;PKM on zhihu&lt;/a&gt;&lt;/p&gt;</summary><category term="PKM"></category></entry><entry><title>把时间当作朋友 书评</title><link href="http://guqian110.github.io/pages/2014/04/25/make_friends_with_time_review.html" rel="alternate"></link><updated>2014-04-25T15:50:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-25:pages/2014/04/25/make_friends_with_time_review.html</id><summary type="html">&lt;h2&gt;如梦初醒&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;突然发现自己已然变成了学校里面的老人，还有不多时日，就要离开在这片我生活了7年的土地，还来不及伤感，更多的是惊慌和不安 。从来没有这么感觉时间不够用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每天都在忙碌，但是不知道在忙碌什么；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;论文貌似总在和我捉迷藏，连影子都不显露；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静心思考自己的 “核心战斗力”。才发现自己还是当年的那个 “战五渣”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生活中有那么多美好的事物，等着我去发现、去体验，比如健身、阅读、骑行...还有写不完的代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;归结起来就是一句话：&lt;strong&gt;时间不够用&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;解决方法也很简单：&lt;strong&gt;管理时间&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;“管理时间” 这个话题当初我是如此的不屑，因为我 &lt;em&gt;自信&lt;/em&gt; 自己的自制力，现在看来，更确切的说法应该是我的 &lt;em&gt;自负&lt;/em&gt; 。亡羊补牢，为时未晚！于是，从豆瓣、大神们的博客上搜集到了几本书，甚至还有平时买书是赠送的 “心灵鸡汤” ...是时候认真规划一下了，学会管理时间 。&lt;/p&gt;
&lt;p&gt;暂时手头有以下几本书，后续还有很多计划看的书单 :-D（关于时间管理，正在学习ing，以后再总结）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3609132/"&gt;把时间当作朋友&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6709809/"&gt;暗时间&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1958547/"&gt;How to Get Things Down&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523251/"&gt;超级时间整理术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;花费了将近两周的时间，在闲时看完了这本 《与时间做朋友》 。写写心得体会吧～&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;把时间当作朋友&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;关于作者 &lt;a href="http://lixiaolai.com/"&gt;李笑來&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先来点正面的：（&lt;a href="http://baike.baidu.com/view/664966.htm?fr=wordsearch"&gt;某度百科&lt;/a&gt;，没有搜到 wiki）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上大学学的是会计，出来做的却是销售。再后来加盟新东方，任教至今已有N年。其间学生数万。著有畅销 TOEFL 辅导书籍《TOEFL核心词汇21天突破》、《TOEFL高分作文》、《把时间当作朋友》、《SAT官方指南全程导学》、《新托福iBT词汇分类突破》，常年位于同类图书销售排行榜首。授课风格以朴实、有效为长。格外注重培养学生的独立思考能力，凡事都从独特的视角出发，而不限于书本知识。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;李笑来最大的贡献是《TOEFL核心词汇21天突破》，这本词汇书里面的很多词汇出现的频率都很高，里面共有2140个单词，可以很快的背一遍然后重复很多遍，这样容你有时间把所有单词都记住；如果说背那种有10000多个单词的书恐怕难以坚持到最后。 因为这种优点，笑来成为托福考试旗帜性的人物。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;于2007年2月前后开始动手写的大约八九十篇文章的集合。2009年6月 出版《把时间当做朋友》，至次年6月已经重印11次，深受读者喜爱。这本书从心智成长的角度来谈时间管理，指出时间管理是成功的关键所在。作者引述自己从事的职业中所遇到的事例，告诉我们：如何打开心智，如何运用心智来和时间做朋友，如何理解时间管理的意义，在时间管理上取得突破，进而用心智开启自己的人生成功之旅。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;再来点负面的～&lt;/p&gt;
&lt;p&gt;从买到书，然后知道了这个人，关注到了一些李笑來老师的言论（博客、twitter、微薄），再结合对这本书的感受，个人对李老师不是很感冒 =.=&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20367798"&gt;李笑来有哪些明显错误的观点？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://lixiaolai.com/archives/10529.html"&gt;臭不要脸的流氓都一个德行&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/19596976"&gt;对李笑来的有关知乎《臭不要脸的流氓都一个德行》一文有什么看法？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;李笑來老师在书中一直强调 “开启心智，获得解放”，但就我从网络上他的言论来看，他远远没有达到这个标准，我认为，任何一个达到开启心智的人，不会在网上撒破，写 blog 破口大骂，武断地下结论，在 twitter 上和网友通宵争论 。一个人连自己的嘴巴都管不好，竟然也写书教导别人 “开启心智”.&lt;/p&gt;
&lt;p&gt;我阴暗地猜测一下，或许是因为他在新东方当老师的经历的后遗症（是的，我对新东方老师存有偏见，结合身边的一些同学的感受，或许称新东方老师为推销员更合适...）；也许和他的学历有关，这里不是对学历的歧视，学历低的牛人多了去了，只是有时候学历会限制一个人的眼界和修养，这本书的第一版出版人 &lt;a href="http://www.zhihu.com/people/yeka/about"&gt;周筠&lt;/a&gt; 在知乎上评论李笑來时就如是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若李笑来当年的求学环境更好，可能思维会比现在灵活而视野宽广。基本上靠自学、野路子出身、容易剑走偏锋的他，最需要的还是对自己的反思。这种反思，还尤其包括对自己优势和短处的清晰判断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有一种可能，这是他的营销手段，毕竟他在创业，使自己时刻处于舆论之中，就是绝佳的免费广告 。&lt;/p&gt;
&lt;h3&gt;读书心得&lt;/h3&gt;
&lt;p&gt;首先，不得不承认，这本书的口碑相当不错，在豆瓣上评分为8.8 分，在书的扉页介绍中也是特意提到了这一点 。而且被列为 “中国书刊发行协2010年度全行业优秀畅销品种”，但是于我而言，看这本书的过程是 “惊喜——还可以——一般”  。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管理自己&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“要管理的不是时间，而是自己 。” 可能这是我从本书中学习到的最有用的观点吧 。时间不会因为我们管理减缓流逝速度，我们能做的只有管理自己 。&lt;/p&gt;
&lt;p&gt;事实上，这本书关于管理自己，争取时间的内容并不多，甚至没有占到总篇幅的一半 .书名是 “把时间当作朋友”，开篇说 “你是不是很缺时间？你想不想和时间做朋友？相信我，你并不孤独，只要看下去就能找到和时间做朋友的方法！”，然后在草草介绍了时间管理方面的内容之后，文章开始转向另外一个话题——运用心智获得解放 ... 甚至类似跑题问在具体每一小节中都有不同程度的复现 。&lt;/p&gt;
&lt;p&gt;关于管理自己、规划时间的内容，目前还在看 GTD 相关的书，看完再总结～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成功学&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这本书在序言中就在抨击 “成功学”，并且申明本书绝对不是一本成功学，也不是心灵鸡汤，也不是讲大道理的书，也不是一本随便翻翻就可以的书 。尽管作者尽量以朴素的方式总结自己的经验，并且以朴素的语言表达出来，但是正如自己所言， “不可避免地透漏出说教的神态” 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Critical Thinking&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在读这本书前，我对 &lt;a href="http://en.wikipedia.org/wiki/Critical_thinking"&gt;critical thinking&lt;/a&gt; 只是有所了解，于是运用自己理解的方法，来审视这本书的内容，不失为一个绝佳的练习方法 :-D 然后我发现文章中很多地方的逻辑并不严密，甚至有些结论无中生有，或者过于武断，牵强附会 。&lt;/p&gt;
&lt;p&gt;P.S. 关于 critical thinking ，阅读更多的书以后再总结 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论点、论据、论证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这本书一开始描绘的问题让我仿佛找到知己，因为我就是这样一个时间不够用患者，顺带 拖延症晚期，看到李老师说可以 “开启心智，获得解放，和时间做朋友” 时，可以想想我是多么的激动，差点就泪流满面了 T_T&lt;/p&gt;
&lt;p&gt;然后我就抱着 “开启心智” 的伟大目标开始了后面的阅读，但是让人失望的是，作者在后面的论述并没有表现出和前言相当的精彩内容。首先，他的某些结论或许是他长期思考总结出来的，适合于他，但是并不能作为普适的经验，甚至有些结论过于武断，只是他的生活经验，缺乏科学的支持；其次，作为一个典型的工科学生，对他的论点、论据、论证方法实在无法赞同，很多时候感觉是想到哪里写到哪里，到后面都忘了前文的目的，转而说下一个问题，就像是聊天一样，扯到十万八里之外了。完全没有达到 “critical thinking” 的标准 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;总之，抛开对作者的映像，就这本书而言，还是比较值得一读的（只是没有像宣传的那么唬），作为一本心理学、时间管理、自我实现方面的入门级书，看看总是没有错的 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;其他人的评价&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;豆瓣上有篇书评，个人感觉相当精髓，不能同意更多：&lt;a href="http://book.douban.com/review/5598312/"&gt;李氏“中医”？&lt;/a&gt;，其中有一句&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我相信这本书是有阶段性意义的，对我个人而言，甚至可以说相当大。 就是在这本书里，我看到一个勇于面对自己的缺点的人，一个认同个人奋斗改变人生的人，令人遗憾的是，我也看到一个仅仅是文笔简洁的人，一个至今仍局限于个人经验而不愿意走出来的人。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/people/yeka/about"&gt;周筠&lt;/a&gt;老师评价：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我是李笑来《把时间当作朋友》第一版的出版人，他的书中的好些观点对我都有触动，给我不少帮助，为此很感谢他。&lt;strong&gt;至今，我还是认为《把时间当作朋友》对很多迷途中的年轻人会有较大帮助，不能因为其中有些观点经不起推敲，就否定这本书的价值。&lt;/strong&gt;对我来说，这本书是有营养的，所以我才会热心出版。&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="时间管理"></category><category term="review"></category></entry><entry><title>学习 Linux 软件包依赖管理</title><link href="http://guqian110.github.io/pages/2014/04/21/learning_linux_package_management.html" rel="alternate"></link><updated>2014-04-21T13:43:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-21:pages/2014/04/21/learning_linux_package_management.html</id><summary type="html">&lt;h2&gt;Linux 软件包依赖问题&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;早期的 Linux 系统上的软件是通过源码方式发布的，大家下载下来，在自己的机器上编译，得到可执行程序 。&lt;/p&gt;
&lt;p&gt;但是，任何程序员写程序都有可能会依赖一些别人已经写成的库，所以几乎一定规模的程序必然有依赖 。尤其是对于 Linux 系统，因为它是 &lt;strong&gt;free（自由，not 免费）&lt;/strong&gt;，开源软件的开发者不是在一个体系下，软件包的依赖关系就比较伤脑筋了， 尤其是当我们的系统里有成百上千的软件时，软件包管理的必要性就更明显了 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;比如我们需要安装 package_a，而 package_a  依赖于 package_b 才能运行，但是我们的系统没有安装 package_b，如果强制安装 package_a，软件很可能不能正常运行 。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;  其实在 Windows 下也存在相似的问题，只是因为有微软统一的体系，很多 &lt;code&gt;dll&lt;/code&gt; 被集成在系统中，所以这个问题不明显 。&lt;/p&gt;
&lt;p&gt;不同的系统对于这个问题有不同的处理方法，这也体现出它们不同的处理问题的哲学：&lt;/p&gt;
&lt;p&gt;知乎上的问题：&lt;a href="http://www.zhihu.com/question/20443067"&gt;Unix 的包依赖是如何形成的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有个回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GNU/Linux：通常这个系统大多数软件是自由软件，换句话说，他们通常依赖的库也是自由的，所以软件开发者认为你可以自由的获取这些依赖库，自然就不需要自己再提供了。由系统“发行版”负责维护属于这个系统的所有依赖库，并且安装软件时确定依赖
&lt;br&gt;
这个体系的特点是：
&lt;br&gt;
1. 系统依赖通常是统一的，如果有多个程序依赖同一个库，在这个系统中通常是同一份
&lt;br&gt;
2. 具有庞大的资源。例如 Debian 系现成的可依赖软件多达 30G，所以通常不可能预先把所有依赖都安装全，但庞大的依赖库给编程人员提供了很多方便
&lt;br&gt;
3. 你安装的软件越多，共同依赖所体现出的价值越高，解决依赖问题就越简单（因为当你安装足够多软件时，主流的依赖已经全部在你系统了）
&lt;br&gt;
4. 由于巨大的共同依赖库存在，软件本身可以很小
&lt;br&gt;
&lt;br&gt;
Windows：通常而言，这个系统的软件是商业软件，因此，他们依赖的库也很有可能是商业软件，所以，不可能要求用户自行获取这些依赖，这些依赖通常在发布软件的时候提供。如果你安装的软件少，这个体系很方便 。
&lt;br&gt;
不过这造成了一些缺点：
&lt;br&gt;
1. 没有一个庞大的公共库，很多功能以及基础库都是每个公司自己实现一套，浪费很多劳动力，编程人员到每个公司得学习一套不同的库，给编程人员带来不便
&lt;br&gt;
2. 所有应用程序都自己带依赖，因此很可能有许多程序同时附带了相同的依赖，并且这些相同依赖还有可能是不同的版本，这会造成许多混乱
&lt;br&gt;
3. 由于所有应用程序都自己提供所有依赖，每个软件体积都很庞大
&lt;br&gt;
4. 系统中安装的软件越多，越容易出问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Linux 包管理系统&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Package_management_system"&gt;Package management system on wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;package management system&lt;/strong&gt;, also called &lt;strong&gt;package manager&lt;/strong&gt;, is a collection of software tools to automate the process of installing, upgrading, configuring, and removing software packages for a computer's operating system in a consistent manner. It typically maintains a database of software dependencies and version information to prevent software mismatches and missing prerequisites.
&lt;br&gt;
&lt;br&gt;
Package management systems are designed to save organizations time and money through remote administration and software distribution technology that eliminate the need for manual installs and updates. This can be particularly useful for large enterprises whose operating systems are based on Linux and other Unix-like systems, typically consisting of hundreds or even thousands of distinct software packages; in the former case, a package management system is a convenience, in the latter case it becomes essential.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Linux 发行版中，几乎每一个发行版都有自己的软件包管理系统 。&lt;/p&gt;
&lt;h3&gt;Dpkg&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Dpkg"&gt;Dpkg on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dpkg 是基于 Debian 系统的包管理软件 。&lt;code&gt;dpg&lt;/code&gt; 可以用来安装、删除、提供&lt;code&gt;.deb&lt;/code&gt; 格式软件包相关信息的文件 。&lt;/p&gt;
&lt;p&gt;dpkg 由 Matt Welsh、Carl Streeter、 Ian Murdock 用 Perl 语言编写，后来在 1994 年。 Ian Jackson 改用 C 重写了大部分内容 。&lt;/p&gt;
&lt;p&gt;dpkg 是 “Debian package” 的缩写，它最初是为 Debian 系统编写的，也可以在使用 &lt;code&gt;.deb&lt;/code&gt; 格式的 Ubuntu 系统上使用 。&lt;/p&gt;
&lt;h4&gt;常用语法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dpkg&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;peackage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deb&lt;/span&gt;        &lt;span class="c1"&gt;// install&lt;/span&gt;
&lt;span class="n"&gt;dpkg&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deb&lt;/span&gt;         &lt;span class="c1"&gt;// remove&lt;/span&gt;
&lt;span class="n"&gt;dpkg&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;// list installed package&lt;/span&gt;
&lt;span class="n"&gt;dpkg&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;    &lt;span class="c1"&gt;// configure package&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;详细用法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dpkg&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;
&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;dpkg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Apt&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Advanced_Packaging_Tool"&gt;Advanced Packaging Tool on wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Advanced Packaging Tool, or APT, is a free software user interface that works with core libraries to handle the installation and removal of software on the Debian GNU/Linux distribution and its variants. APT simplifies the process of managing software on Unix-like computer systems by automating the retrieval, configuration and installation of software packages, either from precompiled files or by compiling source code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;apt 最初是设计为 dpkg 的前端，用来处理 &lt;code&gt;.deb&lt;/code&gt; 格式的文件，后来它被 &lt;code&gt;APT-RPM&lt;/code&gt; 组织改造可以支持 RPM 包管理系统 。&lt;/p&gt;
&lt;p&gt;apt 由 &lt;code&gt;apt-get&lt;/code&gt;、&lt;code&gt;apt-cache&lt;/code&gt; 和 &lt;code&gt;apt-config&lt;/code&gt; 等小工具组成&lt;/p&gt;
&lt;h4&gt;常用语法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;             &lt;span class="c1"&gt;// install&lt;/span&gt;
&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;              &lt;span class="c1"&gt;// remove&lt;/span&gt;
&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;            &lt;span class="c1"&gt;// search&lt;/span&gt;
&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;                      &lt;span class="c1"&gt;// update source list&lt;/span&gt;
&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;upgrade&lt;/span&gt;                     &lt;span class="c1"&gt;// upgrade installed software&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;详细用法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;
&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;
&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;
&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;upgrade&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;彩蛋&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 terminal 中输入 &lt;code&gt;apt-get -h&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;help 内容结束的最后一样会有一句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This APT has Super Cow Powers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 terminal 中输入 &lt;code&gt;apt-get moo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会显示一头牛 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="o"&gt;/------&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; 
   &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="o"&gt;||&lt;/span&gt;   
  &lt;span class="o"&gt;*&lt;/span&gt;  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;---/&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; 
     &lt;span class="o"&gt;~~&lt;/span&gt;   &lt;span class="o"&gt;~~&lt;/span&gt;   
   &lt;span class="p"&gt;....&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Have you mooed today?&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;h3&gt;Aptitude&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Aptitude_(software)"&gt;aptitude on wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;aptitude is a front-end to the Advanced Packaging Tool (APT). It displays a list of software packages and allows the user to interactively pick packages to install or remove. It has an especially powerful search system utilizing flexible search patterns. It was initially created for Debian, but has appeared in RPM Package Manager (RPM) based distributions as well (such as Conectiva).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;aptitude 是 APT 的文本界面客户端，它的交互性比 apt 好，似乎在处理依赖问题上也更好一些（我遇到的问题，用 aptitude 可以很方便地解决而 apt 不行 ）&lt;/p&gt;
&lt;h4&gt;常用语法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;clean&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;详细用法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;aptitude&lt;/span&gt;
&lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;彩蛋&lt;/h4&gt;
&lt;p&gt;&lt;img alt="aptitude" src="/images/learning-linux-package-management/aptitude.png" /&gt;&lt;/p&gt;
&lt;h3&gt;YUM&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/Yum"&gt;Yellowdog Updater, Modified on wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Yellowdog Updater, Modified (yum) is an open-source command-line package-management utility for Linux operating systems using the RPM Package Manager. Though yum has a command-line interface, several other tools provide graphical user interfaces to yum functionality.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;YUM 是一个基于 RPM 包管理的字符前端软件包管理器。能够从指定的服务器自动下载 RPM 包并且安装，可以处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装 。被 Yellow Dog Linux 本身，以及 Fedora、Red Hat Enterprise Linux 采用 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;举个栗子&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;有些软件要求的库的版本高于(&amp;gt;=)xx.xxx，有些软件要求库的版本必须是(=)xx.xxx，如果我们的库不能满足要求则无法安装软件 。一般 &lt;code&gt;apt-get&lt;/code&gt; 会处理比较简单的依赖关系，但是有些依赖关系 &lt;code&gt;apt-get&lt;/code&gt; 并不能解决 。这时候可以试试 &lt;code&gt;aptitude&lt;/code&gt; 。&lt;/p&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;为新安装的 Ubuntu 安装开发环境时，遇到了库版本过高的问题，执行下面的命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;essential&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果 apt-get 提示有不满足依赖关系的包&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reading package lists... Done
&lt;br&gt;
Building dependency tree
&lt;br&gt;
Reading state information... Done
&lt;br&gt;
Some packages could not be installed. This may mean that you have
&lt;br&gt;
requested an impossible situation or if you are using the unstable
&lt;br&gt;
distribution that some required packages have not yet been created
&lt;br&gt;
or been moved out of Incoming.
&lt;br&gt;
The following information may help to resolve the situation:
&lt;br&gt;
&lt;br&gt;
The following packages have unmet dependencies:
&lt;br&gt;
&lt;strong&gt;build-essential : Depends: dpkg-dev (&amp;gt;= 1.13.5) but it is not going to be installed&lt;/strong&gt;
&lt;br&gt;
E: Unable to correct problems, you have held broken packages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是我们手动安装特定的库&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;dpkg&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果提示我们库版本过高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reading package lists... Done
&lt;br&gt;
Building dependency tree
&lt;br&gt;
Reading state information... Done
&lt;br&gt;
Some packages could not be installed. This may mean that you have
&lt;br&gt;
requested an impossible situation or if you are using the unstable
&lt;br&gt;
distribution that some required packages have not yet been created
&lt;br&gt;
or been moved out of Incoming.
&lt;br&gt;
The following information may help to resolve the situation:
&lt;br&gt;
&lt;br&gt;
The following packages have unmet dependencies:
&lt;br&gt;
 &lt;strong&gt;dpkg-dev : Depends: libdpkg-perl (= 1.16.10ubuntu1) but 1.16.12ubuntu1 is to be installed&lt;/strong&gt;
&lt;br&gt;
Recommends: build-essential but it is not going to be installed
&lt;br&gt;
           Recommends: fakeroot but it is not going to be installed
&lt;br&gt;
           Recommends: libalgorithm-merge-perl but it is not going to be installed
&lt;br&gt;
E: Unable to correct problems, you have held broken packages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;解决问题 —— 使用 &lt;code&gt;aptitude&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;解决方法就是降级&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;方法有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;apt-get 直接指定安装特定的版本&lt;/p&gt;
&lt;p&gt;首先查询是否提供低版本的包&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="n"&gt;showpkg&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;若有则指定安装某个版本&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 aptitude 自动处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我采用的第二种方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;aptitude&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;essential&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following NEW packages will be installed:
&lt;br&gt;
 build-essential dpkg-dev{ab} 
&lt;br&gt;
The following packages are RECOMMENDED but will NOT be installed:
&lt;br&gt;
fakeroot libalgorithm-merge-perl 
&lt;br&gt;
0 packages upgraded, 2 newly installed, 0 to remove and 18 not upgraded.
&lt;br&gt;
Need to get 718 kB of archives. After unpacking 1,636 kB will be used.
&lt;br&gt;
The following packages have unmet dependencies:
&lt;br&gt;
 dpkg-dev : Depends: libdpkg-perl (= 1.16.10ubuntu1) but 1.16.12ubuntu1 is installed.
&lt;br&gt;
The following actions will resolve these dependencies:
&lt;br&gt;
&lt;br&gt;
Keep the following packages at their current version:
&lt;br&gt;
1)     build-essential [Not Installed]
&lt;br&gt;
2)     dpkg-dev [Not Installed]
&lt;br&gt;
&lt;br&gt;
Accept this solution? [Y/n/q/?]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然不是中止安装，选择 &lt;code&gt;n&lt;/code&gt;， aptitude 给出另外一个解决方案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following actions will resolve these dependencies:
&lt;br&gt;
 Downgrade the following packages:
&lt;br&gt;
&lt;br&gt;
1)     libdpkg-perl [1.16.12ubuntu1 (now) -&amp;gt; 1.16.10ubuntu1 (raring)]
&lt;br&gt;
&lt;br&gt;
Accept this solution? [Y/n/q/?]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这正是我们需要解决的版本过高的问题，将库软件版本降级&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following packages will be DOWNGRADED:
&lt;br&gt;
libdpkg-perl 
&lt;br&gt;
The following NEW packages will be installed:
&lt;br&gt;
 build-essential dpkg-dev{a} 
&lt;br&gt;
The following packages are RECOMMENDED but will NOT be installed:
&lt;br&gt;
fakeroot libalgorithm-merge-perl 
&lt;br&gt;
0 packages upgraded, 2 newly installed, 1 downgraded, 0 to remove and 18 not upgraded.
&lt;br&gt;
Need to get 904 kB of archives. After unpacking 1,632 kB will be used.
&lt;br&gt;
Do you want to continue? [Y/n/?] &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选择 &lt;code&gt;y&lt;/code&gt;。然后 aptitude 会完成剩余的工作 。&lt;/p&gt;
&lt;p&gt;问题解决啦！&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20443067"&gt;Unix 的包依赖是如何形成的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://daway320.blog.163.com/blog/static/3878369920107331733393/"&gt;apt-get install安装软件问题(安装包的依赖库版本过高问题)&lt;/a&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="Package Management"></category></entry><entry><title>学习 Vim 保存项目设置</title><link href="http://guqian110.github.io/pages/2014/04/20/learning_vim_save_project_configuration.html" rel="alternate"></link><updated>2014-04-20T14:32:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-20:pages/2014/04/20/learning_vim_save_project_configuration.html</id><summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关于 Vim 和 IDE 的争论，这是程序猿的圣战，不再浪费时间 :-D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在参考了很多人分享的博客和教程之后，终于把 Vim 搭建成为一个自己定制的 IDE（这种说法严格意义上说，是不对的，应该是 “组合一组工具成为一个 IDE ”），总结一下～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本系列的内容很多都是参考别人的博客写的，也包含部分自己摸索的结果 。虽然部分内容和参考文章相同，但是总结一下自己的学习过程还是一件有必要的事 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;很多编辑器都有一个功能是以前打开过的文档会有记忆，再次打开时会直接跳转到上次编辑的地方，比如  &lt;a href="http://www.sublimetext.com/2"&gt;&lt;code&gt;Sublime Text 2&lt;/code&gt;&lt;/a&gt;，强大的 Vim 当然也有这个功能，&lt;strong&gt;我们的目标就是让 VIm 和其他 IDE 一样，可以记住上次的编辑状态 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vim 要实现这个功能，涉及到两个地方的配置：&lt;code&gt;session&lt;/code&gt; &amp;amp; &lt;code&gt;viminfo&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Session&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;查看 session 介绍&lt;/h3&gt;
&lt;p&gt;在 Vim 中输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;session&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就可以看到关于 &lt;code&gt;session&lt;/code&gt; 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Session keeps the Views for all windows, plus the global settings.  You can save a Session and when you restore it later the window layout looks the same. You can use a Session to quickly switch between different projects, automatically loading the files you were last working on in that project.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我使用的 Vim 7.3 中， &lt;code&gt;help&lt;/code&gt; 中的 &lt;code&gt;usr_21.txt&lt;/code&gt; 的主题是 &lt;code&gt;Go away and come back&lt;/code&gt;，其中 &lt;code&gt;21.4&lt;/code&gt;  节保存的就是关于 session 的说明，在 Vim 中输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="mf"&gt;21.4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就可以看到关于 session 的详细介绍 。&lt;/p&gt;
&lt;h3&gt;配置 session&lt;/h3&gt;
&lt;p&gt;Session 保存的信息由 &lt;code&gt;sessionoptions&lt;/code&gt; 确定，详细用法可以查看 help&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sessionoption&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;'sessionoptions' 'ssop' string  (default: &lt;strong&gt;"blank,buffers,curdir,folds,help,options,tabpages,winsize"&lt;/strong&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It is a comma separated list of words.  Each word enables saving and restoring something&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 session 保存的会话的属性默认的有 8 个 ：&lt;strong&gt;当前编辑的空窗口、缓冲区、当前目录、折叠信息、帮助信息、选项、标签页、窗口大小信息 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上面的设置中，不要同时包含 &lt;code&gt;curdir&lt;/code&gt; 和 &lt;code&gt;sesdir&lt;/code&gt; 两个选项，若两个选项都不包含，则保存 session 时，会保存绝路径 。添加 &lt;code&gt;sesdir&lt;/code&gt; 可以将当前目录设置为 &lt;code&gt;session-file&lt;/code&gt;  所在的目录，这个设置有个很有用的地方就是，当我们通过网络访问我们的工程或者有很多个工程版本，这时候只需要每个工程下保存一个 session-file 即可 。&lt;/p&gt;
&lt;p&gt;删除/加入 某个选项的方法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="n"&gt;curdir&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;sesdir&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;保存 session 文件&lt;/h3&gt;
&lt;p&gt;详细的语法可以在 help 中查看&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;mksession&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用 &lt;code&gt;mksession&lt;/code&gt; 命令保存会话&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptopms&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="n"&gt;curdir&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;sesdir&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;mksession&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 session-file 已经存在，则使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;mksession&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;载入 session 文件&lt;/h3&gt;
&lt;p&gt;然后退出 Vim，在别的目录下打开，干点别的事，这时候我们想起刚才的工程里面有个小 bug，想恢复过去，这时候就是只需要使用 &lt;code&gt;source&lt;/code&gt; 命令即可 。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;source&lt;/code&gt; 命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="n"&gt;PATHto&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这时候可以看到，已经恢复了之前的状态 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;只使用 session 就可以恢复一些上次编辑的信息，但是这还不够，我们还可以配合使用 &lt;code&gt;viminfo&lt;/code&gt; 来恢复更多的信息 。在 Vim 的 &lt;code&gt;:help 21.4&lt;/code&gt; 中有介绍两者的关系&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sessions store many things, but not the position of marks, contents of registers and the command line history.&lt;/strong&gt;  You need to use the viminfo feature for these things.&lt;/li&gt;
&lt;li&gt;In most situations you will want to use sessions separately from viminfo. This can be used to switch to another session, but keep the command line history.  And yank text into registers in one session, and paste it back in another session.&lt;/li&gt;
&lt;li&gt;You might prefer to keep the info with the session.  You will have to do this yourself then.&lt;/li&gt;
&lt;li&gt;You could also use a Session file.  &lt;strong&gt;The difference is that the viminfo file does not depend on what you are working on.&lt;/strong&gt;  There normally is only one viminfo file.  Session files are used to save the state of a specific editing Session.  You could have several Session files, one for each project you are working on.  Viminfo and Session files together can be used to effectively
enter Vim and directly start working in your desired setup.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Viminfo&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;查看 viminfo 介绍&lt;/h3&gt;
&lt;p&gt;在 Vim 中输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;viminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就可以看到关于 &lt;code&gt;viminfo&lt;/code&gt; 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you exit Vim and later start it again, you would normally lose a lot of information.  The viminfo file can be used to remember that information, which enables you to continue where you left off.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Vim 7.3 中， &lt;code&gt;help&lt;/code&gt; 中的 &lt;code&gt;usr_21.txt&lt;/code&gt; 的主题是 &lt;code&gt;Go away and come back&lt;/code&gt;，其中 &lt;code&gt;21.3&lt;/code&gt;  节保存的就是关于 viminfo 的说明，在 Vim 中输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="mf"&gt;21.3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就可以看到关于 viminfo 的详细介绍 。&lt;/p&gt;
&lt;p&gt;viminfo 文件可以保存的内容有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The command line history 命令行历史&lt;/li&gt;
&lt;li&gt;The search string history 字符串搜寻历史&lt;/li&gt;
&lt;li&gt;The input-line history 输入行历史&lt;/li&gt;
&lt;li&gt;Contents of non-empty register 非空寄存器内容&lt;/li&gt;
&lt;li&gt;Marks for serval files 文件位置标记&lt;/li&gt;
&lt;li&gt;Last search/substitute pattern 最近模式匹配搜索历史&lt;/li&gt;
&lt;li&gt;The buffer list 缓冲区列表&lt;/li&gt;
&lt;li&gt;Global variables 全局变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;保存 viminfo 文件&lt;/h3&gt;
&lt;p&gt;其实 Vim 每次退出时都会在 &lt;code&gt;～/&lt;/code&gt; 目录下保存一个 &lt;code&gt;.viminfo&lt;/code&gt; 的文件，但是每次打开关闭一个文件都会覆盖上次的记录，所以我们需要为工程手动保存一个 viminfo 文件，并且保存在工程目录下，防止被覆盖 。&lt;/p&gt;
&lt;p&gt;保存命令 &lt;code&gt;:wviminfo&lt;/code&gt; 的帮助&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;wviminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用 &lt;code&gt;wviminfo&lt;/code&gt; 保存&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;wviminfo&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;viminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;载入 viminfo 文件&lt;/h3&gt;
&lt;p&gt;载入命令 &lt;code&gt;rviminfo&lt;/code&gt; 帮助&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rviminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;载入 viminfo 文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rviminfo&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;viminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;为了节省每次都要手动输入一些设置命令，我们可以把部分相同的设置放在 &lt;code&gt;.vimrc&lt;/code&gt; 文件中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="n"&gt;curdir&lt;/span&gt;
&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;sesdir&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次退出 Vim 时保存&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;mksession&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;wviminfo&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;viminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进入 Vim 想恢复项目设置时&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="n"&gt;projetc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rviminfo&lt;/span&gt; &lt;span class="n"&gt;projetc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;viminfo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-session-file-and-viminfo/"&gt;vi/vim使用进阶: 使用会话和viminfo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-save-project-configuration/"&gt;vi/vim使用进阶: 保存项目相关配置&lt;/a&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="Vim"></category></entry><entry><title>学习 Vim 使用 Vundle 管理插件</title><link href="http://guqian110.github.io/pages/2014/04/16/learning_vim_vundle.html" rel="alternate"></link><updated>2014-04-16T17:06:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-16:pages/2014/04/16/learning_vim_vundle.html</id><summary type="html">&lt;p&gt;学习 Vim，使用 Vundle 管理插件 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Vim 插件&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Vim 的强大之处在于它的可扩展性，你可以把它当作一个简单的文本编辑器，也可以安装各种功能强大的插件，把它武装成一个 IDE 。&lt;/p&gt;
&lt;p&gt;我们可以从以下几个地方找到 Vim 插件，一般比较常用的插件从官网上都可以找到，还有一些插件是大神们自己写的，托管在 GitHub 上 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script_search_results.php"&gt;Vim 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/"&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;什么是 Vundle&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Vim 的插件虽然强大，但是因为 Vim 根本就没有插件管理这个概念，所有插件的文件都散布在~/.vim下的几个文件夹中，配置 vim 的过程, 就是在网上不停的搜插件，拷贝到 &lt;code&gt;~/.vim&lt;/code&gt; 下，发现更新，要重新下载重新拷贝，想要删除某个不需要插件，更是要小心翼翼的不要删错。配置出顺手的 Vim, 需要极大的耐心和运气，而且如果换一台电脑，就要重复一次这样的痛苦经历 。&lt;/p&gt;
&lt;p&gt;自然地，因为管理插件的需求，最早出现了一些管理插件的脚本，但是写脚本需要一定的 shell 知识，直接 copy 别人的自己并不一定适用 。后来，出现了一些插件，比如 pathogen，muzuiget，vim-flavor，Vundle 等 。&lt;/p&gt;
&lt;p&gt;目前比较流行的方式是采用 Vundle 来管理插件（别的我也没有试过...）&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/gmarik/Vundle.vim"&gt;Vundle on GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=3458"&gt;Vundle on vim.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vundle 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vundle is short for Vim bundle and is a Vim plugin manager.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vundle 可以在交互的方式下做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;.vimrc&lt;/code&gt; 中管理和配置插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按名字搜索插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除插件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;如何使用 Vundle 管理插件&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;安装 Vundle&lt;/h3&gt;
&lt;p&gt;Vundle 的安装需要 &lt;a href="http://git-scm.com/"&gt;Git&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;从 GitHub 上 clone 下来就可以了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/gmarik/vundle.git ~/.vim/bundle/vundle&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;配置 Vundle&lt;/h3&gt;
&lt;p&gt;将下列内容加入到 &lt;code&gt;.vimrc&lt;/code&gt; 文件中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;nocompatible&lt;/span&gt;              &lt;span class="s"&gt;&amp;quot; be iMproved, required&lt;/span&gt;
&lt;span class="n"&gt;filetype&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt;                  &lt;span class="s"&gt;&amp;quot; required&lt;/span&gt;

&lt;span class="s"&gt;&amp;quot; set the runtime path to include Vundle and initialize&lt;/span&gt;
&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;rtp&lt;/span&gt;&lt;span class="o"&gt;+=~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bundle&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vundle&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;vundle&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;rc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; alternatively, pass a path where Vundle should install plugins&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;let path = &amp;#39;~/some/path/here&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;call vundle#rc(path)&lt;/span&gt;

&lt;span class="s"&gt;&amp;quot; let Vundle manage Vundle, required&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;gmarik&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vundle&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; The following are examples of different formats supported.&lt;/span&gt;

&lt;span class="s"&gt;&amp;quot; Keep Plugin commands between here and filetype plugin indent on.&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; scripts on GitHub repos&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;tpope&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fugitive&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Lokaltog&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;easymotion&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;tpope&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rails&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; The sparkup vim script is in a subdirectory of this repo called vim.&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; Pass the path to set the runtimepath properly.&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rstacruz&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sparkup&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rtp&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; scripts from http://vim-scripts.org/vim/scripts.html&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;L9&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;FuzzyFinder&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; scripts not on GitHub&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//git.wincent.com/command-t.git&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; git repos on your local machine (i.e. when working on your own plugin)&lt;/span&gt;
&lt;span class="n"&gt;Plugin&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;///home/gmarik/path/to/plugin&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; ...&lt;/span&gt;

&lt;span class="n"&gt;filetype&lt;/span&gt; &lt;span class="n"&gt;plugin&lt;/span&gt; &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;     &lt;span class="s"&gt;&amp;quot; required&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; To ignore plugin indent changes, instead use:&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;filetype plugin on&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; Brief help&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; :PluginList          - list configured plugins&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; :PluginInstall(!)    - install (update) plugins&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; :PluginSearch(!) foo - search (or refresh cache first) for foo&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; :PluginClean(!)      - confirm (or auto-approve) removal of unused plugins&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; see :h vundle for more details or wiki for FAQ&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; NOTE: comments after Plugin commands are not allowed.&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot; Put your stuff after this line&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上面的配置文件中可以看到，Vundle 把插件分为了 3 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;scripts on GitHub repos&lt;/p&gt;
&lt;p&gt;GitHub 上的脚本，需要按照 &lt;code&gt;usrname/repos&lt;/code&gt; 的格式写出插件的名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scripts from http://vim-scripts.org/vim/scripts.html &lt;/p&gt;
&lt;p&gt;Vim scripts 上的脚本，不用作者名，直接写插件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scripts not on GitHub&lt;/p&gt;
&lt;p&gt;不是 GitHub 上的脚本，需要写出插件的详细路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;运行 Vundle&lt;/h3&gt;
&lt;p&gt;修改好 &lt;code&gt;.vimrc&lt;/code&gt; 文件后，打开 Vim，使用以下命令管理插件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;列表&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Bundles&lt;/span&gt;    &lt;span class="c1"&gt;// 列出所有插件（包括未安装的）&lt;/span&gt;
&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleList&lt;/span&gt; &lt;span class="c1"&gt;// 列出已安装的插件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleSearch&lt;/span&gt;   &lt;span class="c1"&gt;// 后面不接插件名时，同 Bundles，列出了 4000 个插件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;.vimrc&lt;/code&gt; 文件中删除/注释掉相应的插件名，然后输入命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleClean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; P.S. 我安装的插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;列出一些我安装的插件，这些插件都是大家比较常用的，可以从相关的网站或者帮助文档中找到使用说明或者 &lt;code&gt;README&lt;/code&gt;，计划在后续中写一写使用心得～&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;taglist&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NERD&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;SuperTab&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;snipMate&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;L9&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;FuzzyFinder&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bufexplorer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zip&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;winmanager&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Markdown&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Conque&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Shell&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;vimwiki&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;genutils&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;lookupfile&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;Bundle &amp;#39;ManPageView&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;calendar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;AutoClose&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;scripts on GitHub repos&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;suan&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;instant&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;markdown&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;godlygeek&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tabular&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://zuyunfei.com/2013/04/12/killer-plugin-of-vim-vundle/"&gt;vim中的杀手级插件: vundle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zfanw.com/blog/vundle-vim-plugin-management.html"&gt;Vundle 管理 Vim 插件&lt;/a&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="Vim"></category></entry><entry><title>学习 Vim 初步配置 Vim</title><link href="http://guqian110.github.io/pages/2014/04/16/learning_vim_vimrc_preliminary.html" rel="alternate"></link><updated>2014-04-16T12:44:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-16:pages/2014/04/16/learning_vim_vimrc_preliminary.html</id><summary type="html">&lt;p&gt;总结初步配置 Vim，让 Vim 更顺手 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;在哪里配置 Vim&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6126937/"&gt;学习 Vi 和 Vim 编辑器&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vim 依照特定顺序寻找初始化的信号，它执行找到的第一组指令（可以是 环境变量 or 配置文件），然后开始编辑工作 。所以，Vim 在下列清单中遇到的第一个项目，就是清单中被执行的唯一项目 。书寻如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;VIMINIT&lt;/code&gt; 。它是环境变量，如果不为空，Vim 把它的内容当作 ex 命令执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户 &lt;code&gt;vimrc&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exrc&lt;/code&gt; 选项 。如果设置了 Vim 的 exrc 选项，它会寻找三个额外的配置文件 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;vimrc&lt;/code&gt;（vim runtime configure）文件一般有 3 个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;/etc/vim/vimrc&lt;/p&gt;
&lt;p&gt;本配置文件影响所有的用户，一般不应该更改这个配置文件，因为谁也不能保证别人的喜好和自己一样 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/usr/share/vim/vimrc&lt;/p&gt;
&lt;p&gt;输入命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="n"&gt;ll&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;share&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;vimrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就可以看到，本文件是 &lt;code&gt;/etc/vim/vimrc&lt;/code&gt; 的软链接 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;~/.vimrc&lt;/p&gt;
&lt;p&gt;一般来说，配置 vim 就是在这个文件中配置，如果不存在的话 &lt;code&gt;touch&lt;/code&gt; 一个新文件并命名 &lt;code&gt;。vimrc&lt;/code&gt; 。我们在下面说的配置都是在本文件中配置 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;映射 &lt;code&gt;esc&lt;/code&gt; 键&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;因为历史原因，Joy 设计 vi 时采用的键盘和我们现在用的标准键盘布局并不一样，当时他的键盘的 &lt;code&gt;esc&lt;/code&gt; 键在现在我们的 &lt;code&gt;Caps Lock&lt;/code&gt; 键的位置，所以才设计使用 &lt;code&gt;esc&lt;/code&gt; 作为模式转换键 。为了更加方便顺手地使用 vim，当然要把这两个键相互调换一下 。&lt;/p&gt;
&lt;p&gt;在 vim 的官网上就有介绍如何实现两个按键的调换&lt;/p&gt;
&lt;p&gt;&lt;a href="http://vim.wikia.com/wiki/Map_caps_lock_to_escape_in_XWindows"&gt;Map caps lock to escape in XWindows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体方法，在 &lt;code&gt;～/&lt;/code&gt; 目录下新建一个文件，加入一下内容&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="n"&gt;Swap&lt;/span&gt; &lt;span class="n"&gt;caps&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;escape&lt;/span&gt;
&lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;Lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Caps_Lock&lt;/span&gt;
&lt;span class="n"&gt;keysym&lt;/span&gt; &lt;span class="n"&gt;Escape&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Caps_Lock&lt;/span&gt;
&lt;span class="n"&gt;keysym&lt;/span&gt; &lt;span class="n"&gt;Caps_Lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Escape&lt;/span&gt;
&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;Lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Caps_Lock&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;保存为 .speedswrapper&lt;/p&gt;
&lt;p&gt;然后输入命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;xmodmap&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;speedswrapper&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这时，对于整个系统范围，这两个键已经调换了位置 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;设置颜色主题 colorscheme&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Vim 自带一些颜色主题，一般存放在 &lt;code&gt;/usr/share/vim/vim7x&lt;/code&gt; 目录下（我的 Vim 版本为 7.3，所以路径为 &lt;code&gt;/usr/share/vim/vim73&lt;/code&gt;）.&lt;/p&gt;
&lt;p&gt;如果对系统自带的主题不满意，网上有很多不错的主题，个人最喜欢 &lt;a href="https://github.com/tomasr/molokai"&gt;molikai&lt;/a&gt; 主题，把下载下来的配色文件拷贝到 &lt;code&gt;usr/share/vim/vim73&lt;/code&gt; 路径下，打开 vim 后 输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;colorscheme&lt;/span&gt; &lt;span class="n"&gt;molikai&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就 ok 了～ 不过这个方法在关闭 vim 后就恢复了，要想省去每次都输命令的烦恼，只需要在下一步 .vimrc 文件中加入以下内容就可以了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;colorscheme&lt;/span&gt; &lt;span class="n"&gt;molikai&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;编写 .Vimrc&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;vimrc 文件是配置 Vim 编辑特性比较好的地方，差不多任何 Vim 选项都能在次文件中被设置为打开或者关闭，而且它特别适合设置全局变量与定义函数、缩写、按键映射 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注释以双引号 &lt;code&gt;“&lt;/code&gt; 开始，可位于一行的任何2位置，所有位于双引号后面的文本，包括双引号都会被视为注释而忽略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用冒号 &lt;code&gt;:&lt;/code&gt; 表示 ex 命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;配置 Vim 特性&lt;/h3&gt;
&lt;p&gt;vimrc 配置很简单，网上有很多人都分享了自己的配置方案 。我找到一份注释良好的&lt;a href="https://github.com/amix/vimrc"&gt;配置范例&lt;/a&gt;，这篇博客的作者总结了自己 8 年的使用经验，给出了两份配置文件，基本版 &lt;a href="https://github.com/amix/vimrc/blob/master/vimrcs/basic.vim"&gt;Basic&lt;/a&gt; 和 终极版&lt;a href="https://github.com/amix/vimrc"&gt;Ultimate&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;作为码农，当然要选择终极版了～不过个人喜欢用 Vundle 管理我的 Vim 插件（计划下篇博客记录我的配置过程），不是很喜欢作者选择的所有插件，想自己定制插件组合，那么目前只需要看 基础版就足够了 。&lt;/p&gt;
&lt;p&gt;copy 了一份基础版到自己的 github 中，有备无患 :-D&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;Copy of basic vimrc configure file&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我自己的配置文件：&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;My .vimrc file&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;General&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;set nocompatible&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nb"&gt;Set&lt;/span&gt; &lt;span class="nx"&gt;how&lt;/span&gt; &lt;span class="nx"&gt;many&lt;/span&gt; &lt;span class="nx"&gt;lines&lt;/span&gt; &lt;span class="nx"&gt;of&lt;/span&gt; &lt;span class="nx"&gt;history&lt;/span&gt; &lt;span class="nx"&gt;VIM&lt;/span&gt; &lt;span class="nx"&gt;has&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="nx"&gt;rememer&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;800&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Enable filetype plugins&lt;/span&gt;
&lt;span class="s2"&gt;filetype plugin on&lt;/span&gt;
&lt;span class="s2"&gt;filetype indent on&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nb"&gt;Set&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="nx"&gt;auto&lt;/span&gt; &lt;span class="nb"&gt;read&lt;/span&gt; &lt;span class="nx"&gt;when&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt; &lt;span class="nx"&gt;is&lt;/span&gt; &lt;span class="nx"&gt;changed&lt;/span&gt; &lt;span class="nb"&gt;from&lt;/span&gt; &lt;span class="nx"&gt;the&lt;/span&gt; &lt;span class="nx"&gt;outside&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nx"&gt;autoread&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Set leader key&lt;/span&gt;
&lt;span class="s2"&gt;let mapleader = &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;let g:mapleader = &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;fast&lt;/span&gt; &lt;span class="nx"&gt;saving&lt;/span&gt;
&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;leader&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="o"&gt;!&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; fast saving&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;leader&amp;gt;q :q!&amp;lt;cr&amp;gt;&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;fast&lt;/span&gt; &lt;span class="nx"&gt;editing&lt;/span&gt;
&lt;span class="nx"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;leader&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;aq&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;qa&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;cr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot; Vim user interface&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nb"&gt;Set&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="nx"&gt;lines&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="nx"&gt;the&lt;/span&gt; &lt;span class="nx"&gt;cursor&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Turn on the wild menu&lt;/span&gt;
&lt;span class="s2"&gt;set wildmenu&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;Ignore&lt;/span&gt; &lt;span class="nx"&gt;complited&lt;/span&gt; &lt;span class="nx"&gt;files&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="n"&gt;wildignore&lt;/span&gt;&lt;span class="o"&gt;=*&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="err"&gt;~&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;pyc&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Always show current postion&lt;/span&gt;
&lt;span class="s2"&gt;set ruler&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;Highlight&lt;/span&gt; &lt;span class="nx"&gt;current&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nx"&gt;cursorline&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Height of command bar&lt;/span&gt;
&lt;span class="s2"&gt;set cmdheight=2&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;A&lt;/span&gt; &lt;span class="nx"&gt;buffer&lt;/span&gt; &lt;span class="nx"&gt;becomes&lt;/span&gt; &lt;span class="nx"&gt;hidden&lt;/span&gt; &lt;span class="nx"&gt;when&lt;/span&gt; &lt;span class="nx"&gt;it&lt;/span&gt; &lt;span class="nx"&gt;is&lt;/span&gt; &lt;span class="nx"&gt;abandoned&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nx"&gt;hid&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Configure backsapce so it acts as it should act&lt;/span&gt;
&lt;span class="s2"&gt;set backspace=eol,start,indent&lt;/span&gt;
&lt;span class="s2"&gt;set whichwrap+=&amp;lt;,&amp;gt;,h,l&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;Ignore&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;when&lt;/span&gt; &lt;span class="nx"&gt;searching&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;ignorecase&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; When searching try to be smart about cases&lt;/span&gt;
&lt;span class="s2"&gt;set smartcase&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;Highlight&lt;/span&gt; &lt;span class="nb"&gt;search&lt;/span&gt; &lt;span class="nb"&gt;results&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nx"&gt;hlsearch&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; Make search act like in morden browsers&lt;/span&gt;
&lt;span class="s2"&gt;set incsearch&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nx"&gt;Don&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;t redraw while executing marcros&lt;/span&gt;
&lt;span class="s1"&gt;set lazyredraw&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; For regular expressions turn magic on&lt;/span&gt;
&lt;span class="s1"&gt;set magic&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Show matching brackets when text indicator is over them&lt;/span&gt;
&lt;span class="s1"&gt;set showmatch&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; How many tenths of a second to blink when matching brackets&lt;/span&gt;
&lt;span class="s1"&gt;set mat=2&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Colors and Fonts&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Enable syntax highlight&lt;/span&gt;
&lt;span class="s1"&gt;syntax enable&lt;/span&gt;
&lt;span class="s1"&gt;colorscheme molokai&lt;/span&gt;
&lt;span class="s1"&gt;set background=dark&lt;/span&gt;
&lt;span class="s1"&gt;:set t_Co=256&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Set utf8 as standard encoding and en_US as the standard language&lt;/span&gt;
&lt;span class="s1"&gt;set encoding=utf8&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Use Unix as the standard file type&lt;/span&gt;
&lt;span class="s1"&gt;set ffs=unix,dos,mac&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Files, backups and undo&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Turn backup off, since most stuff is in SVN. git et.c anyway&lt;/span&gt;
&lt;span class="s1"&gt;set nobackup&lt;/span&gt;
&lt;span class="s1"&gt;set nowb&lt;/span&gt;
&lt;span class="s1"&gt;set noswapfile&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Text, tab and indent related&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Use sapce instead of tabs&lt;/span&gt;
&lt;span class="s1"&gt;set expandtab&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Be smart when using tabs&lt;/span&gt;
&lt;span class="s1"&gt;set smarttab&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; 1 tab = 4 spaces&lt;/span&gt;
&lt;span class="s1"&gt;set shiftwidth=4&lt;/span&gt;
&lt;span class="s1"&gt;set tabstop=4&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Linebreak on 500 characters&lt;/span&gt;
&lt;span class="s1"&gt;set lbr&lt;/span&gt;
&lt;span class="s1"&gt;set tw=500&lt;/span&gt;

&lt;span class="s1"&gt;set ai &amp;quot;Auto indent&lt;/span&gt;
&lt;span class="s1"&gt;set si &amp;quot;Smart indent&lt;/span&gt;
&lt;span class="s1"&gt;set wrap &amp;quot;Wrap lines&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Moving around, tabs, windows and buffers&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Treat long lines as break lines&lt;/span&gt;
&lt;span class="s1"&gt;map j gj&lt;/span&gt;
&lt;span class="s1"&gt;map k gk&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Smart way to move between windows&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;C-j&amp;gt; &amp;lt;C-w&amp;gt;j&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;C-k&amp;gt; &amp;lt;C-w&amp;gt;k&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;C-h&amp;gt; &amp;lt;C-w&amp;gt;h&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;C-l&amp;gt; &amp;lt;C-w&amp;gt;l&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Status line&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Show line number&lt;/span&gt;
&lt;span class="s1"&gt;set number&lt;/span&gt;

&lt;span class="s1"&gt;&amp;quot; Always show the status line&lt;/span&gt;
&lt;span class="s1"&gt;set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s1"&gt;%d/%m/%y\ -\ %H:%M&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s1"&gt;)}&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ Line:\ %l&lt;/span&gt;


&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Spell checking&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Pressing ,ss will toggle and untoggle spell checking&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;leader&amp;gt;ss :setlocal spell!&amp;lt;cr&amp;gt;&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;leader&amp;gt;sn ]s&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;leader&amp;gt;sp [s&lt;/span&gt;
&lt;span class="s1"&gt;map &amp;lt;leader&amp;gt;sa zg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6126937/"&gt;学习vi 和 Vim 编辑器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/amix/vimrc"&gt;The Ultimate vimrc&lt;/a&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="Vim"></category></entry><entry><title>如何优雅地使用 Gmail</title><link href="http://guqian110.github.io/pages/2014/04/11/how_to_use_gmail_gracefully.html" rel="alternate"></link><updated>2014-04-11T23:33:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-11:pages/2014/04/11/how_to_use_gmail_gracefully.html</id><summary type="html">&lt;p&gt;Gmail 是 Google 提供的邮箱，细数使用 Gmail 已经快 5 年了，但是最近才发现自己的使用方法根本不对，摸索了 2 天，总结一下使用心得～&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;为何使用 Gmail&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;关于 QQ mail 和 Gmail 谁好谁坏的问题，知乎上有一堆&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20010081"&gt;为什么这么多人说 Gmail 好用？Gmail 和 QQmail 相比到底好在哪里？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/19606703"&gt;为什么现在这么多受过高等教育的人喜欢用 Gmail，国内的邮箱如何？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/19724238"&gt;不喜欢 Gmail 而喜欢 QQ 邮箱的人，为什么会产生这样的偏好？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我选择 Gmail 的理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Gmail 账户是 Google 所有服务的入口，除了可以使用 Gmail 外和其他所有 Google 产品都有无缝的整合 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;强大的功能，比如我最喜欢的 &lt;em&gt;邮件对话功能&lt;/em&gt; 和 &lt;em&gt;label 功能&lt;/em&gt;，还有 &lt;em&gt;过滤器&lt;/em&gt;，Chrome + Gmail，给你最简洁强大的体验 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全，邮件不会受到某些机器&amp;amp;人工的监视，免受 GFW 的干扰&lt;/p&gt;
&lt;p&gt;这恰恰是一些人不使用 Gmail 的原因，因为 Gmail 不稳定，但是关于这个问题，引用 &lt;a href="http://www.zhihu.com/people/hecaitou"&gt;和菜头&lt;/a&gt; 在知乎上的一句话 &lt;a href="http://www.zhihu.com/question/19580396"&gt;“因为Gmail总有访问正常的一天，只要Google不死。对未来没有信心做人和一条咸鱼又有什么区别？”&lt;/a&gt;，况且，在 Geek 面前这都不是问题 。）&lt;/p&gt;
&lt;p&gt;关于 Google 和百度、天朝的恩怨，一个有独立判断能力的人都明白为什么 Google 退出中国 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我是 G 粉，Gmail 代表了自由 :-D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gmail 可以代收发邮件，测试了一下 QQ mail 和 163 是可以用的，所以，只需要 一个 Gmail 就可以管理 3 个邮箱了。&lt;/p&gt;
&lt;p&gt;对于中国人来说，邮箱貌似是一个很边缘化的东西，而对于西方国家来说，邮箱交流是一件再普通的事了。听说微软 和 Google 公司即使一个办公室内的同事，上下级都是用邮件交流的（国内互联网公司貌似也有，但是没有达到那么频繁的程度），全世界的邮件流量超过 80% 在欧美 。所以，QQ mail 上到处是贺卡、问候、漂流瓶，这也是为什么用 QQ mail 发一份简历时为什么显得不正式的原因 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;如何优雅地使用 Gmail&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;擅自使用知乎风格来命名这个子标题，其实只是我个人的一些使用心得 :-D&lt;/p&gt;
&lt;p&gt;完整的攻略当然是官方的&lt;a href="https://support.google.com/mail/?hl=zh-Hans#topic=3394144"&gt;帮助&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;代收其他邮箱&lt;/h3&gt;
&lt;p&gt;官方帮助文档，导入&lt;a href="https://support.google.com/mail/answer/21289?hl=zh-Hans&amp;amp;ref_topic=3394220"&gt;邮箱账户&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="import" src="/images/how-to-use-gmail-gracefully/import.png" /&gt;&lt;/p&gt;
&lt;p&gt;Gmail 最多可以导入 5 个邮箱账户的邮件，对于普通人来说，远远足够了 。&lt;/p&gt;
&lt;h3&gt;Inbox /Archive&lt;/h3&gt;
&lt;p&gt;这是我最喜欢 Gmail 的地方，也是我以前一直没有正确使用的功能 。以前，我的 inbox 里面有大概 800+  份邮件，包括已读/未读，私人邮件、工作邮件、广告、各个网站注册激活链接、社交网络消息提醒等，全部混在一起 。&lt;/p&gt;
&lt;p&gt;从知乎上找到一个改变我对邮箱 Inbox/Archive 的认识的回答，问题是 &lt;a href="http://www.zhihu.com/question/20042480"&gt;如何有效地使用 Gmail 的 Archive（归档）功能？&lt;/a&gt; ，回答者是&lt;a href="http://www.zhihu.com/people/unogzx"&gt;钢盅郭子&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;精髓就是&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Inbox = 待/未处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Archive = 已/不处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阅读完邮件（已读），却无法立刻做出响应（回复或开展相关工作）的可能性是很高的，此时可以将邮件留在收件箱内留待日后处理。&lt;/p&gt;
&lt;p&gt;而将邮件存档，则说明已经不再对此邮件感兴趣了，即便它始终未读，我们也可以通过其他信息（标题、收件人不是自己）确定这是一封不需要关注的邮件。&lt;/p&gt;
&lt;p&gt;有人认为 Inbox 可以覆盖 Archive 的功能。我觉得可以理解，毕竟，喜欢把所有工作都堆放在办公桌台面上的也是大有人在。但即使我们有许多的文件夹或标签可用来分类、标识，抽屉总还是办公桌的默认配置吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;像我以前一样，读完的文件仍然保留在 Inbox 中，就像每次都在办公桌面上读完文件都不收拾，越摆越多，只是这个虚拟的办公桌不会堆不下文件 。&lt;/p&gt;
&lt;p&gt;正确的使用方法应该是把 Inbox 视为一个 tmp，在阅读完邮件后，该删除的删除、该归档的归档、该打标签的打标签，就像保持桌面整洁一样 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 事实上，Inbox 只是一个标签，所谓 归档（Archive） 就是删除这个标签，一份处理完的邮件不再应该打上 Inbox 的标签，所以我们要进行归档 。&lt;/p&gt;
&lt;h3&gt;标签 &amp;amp; 文件夹&lt;/h3&gt;
&lt;p&gt;Gmail 使用了标签代替文件夹，真是一个革命性的创举 。&lt;/p&gt;
&lt;p&gt;帮助里面[列举][lable]了 标签 相比于 文件夹 的优势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个会话可以拥有一个以上的标签，而一封邮件只能放在一个文件夹中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会话可以同时存在于多个位置（收件箱、所有邮件、已发邮件等等），便于日后查找 。而在文件夹中，您必须记住邮件的存档位置，才能找到它 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;您可以利用标签对会话进行搜索，而您不可能总是在文件夹内进行搜索 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，我们需要做的就是阅读邮件，然后按照邮件的属性，给它打上标签（label），比如私人邮件、工作邮件、学习邮件、注册验证邮件、社交邮件等等 。每种表情可以自定义颜色，按照邮件在我们心目中的重要程度，给每种标签赋予不同的颜色，一眼看上去，简洁明了，而且很好看 。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://support.google.com/mail/answer/118708?rd=1"&gt;了解如何创建、修改、删除和搜索标签&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;星标邮件 &amp;amp; 重要邮件&lt;/h3&gt;
&lt;p&gt;Gmail 提供了自动识别邮件重要性的功能，它可以根据算法，用户使用习惯等自动识别，标记一个邮件是否是 “重要的”，除此之外，我们可以自己给邮件打星标，来标记邮件的重要程度 。&lt;/p&gt;
&lt;p&gt;根据我的使用习惯，感觉超过 5 个标签，就有点让人迷惑了，所以，我使用的星标一共有 4 个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黄色星星   表示一般重要文件&lt;/li&gt;
&lt;li&gt;红色叹号 表示非常重要邮件&lt;/li&gt;
&lt;li&gt;紫色问号   表示未处理完，将来还需要处理&lt;/li&gt;
&lt;li&gt;绿色对号   表示已经处理完，暂时一段时间都不需要处理的邮件，除非我手动搜索&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;has&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;green&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;check&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;过滤器&lt;/h3&gt;
&lt;p&gt;使用强大的过滤器，我们可以让 Gmail 实现自动对邮件进行分类&lt;/p&gt;
&lt;p&gt;比如，邮件里包含 “注册”、“激活”、“Active”、“Registration”、“Verify” 等单词，就可以自动打上 “注册验证”标签 。&lt;/p&gt;
&lt;p&gt;再比如，为转发邮箱 QQ mail 或者 163 邮箱设置自动打标签，标记为已读，自动存档、转发、删除等 。&lt;/p&gt;
&lt;h3&gt;实验室功能&lt;/h3&gt;
&lt;p&gt;Gmail 实验室有一些很好玩的功能，比如在邮件中看 Google Map，查看 Google Calendar，取消发送等 。至于 Google 目前主推的 Google+ 和 Google Drive 已经整合进 Gmail 了 。&lt;/p&gt;
&lt;p&gt;强大的 Gmail 真是让人越用越不释手 :-D&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://xuyazhou.com/archives/248"&gt;收发Gmail 必学12招，善用邮件分类、前端管理当Gmail 达人&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.acgtyrant.com/how-to-use-gmail-and-mailinglist-correctly.html"&gt;如何優雅地使用 Gmail &amp;amp; Mailing List&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/topic/19550519/top-answers?page=1"&gt;知乎 Gmail 精华问题&lt;/a&gt;&lt;/p&gt;</summary><category term="Gmail"></category></entry><entry><title>在 Ubuntu 下运行 WarCraft</title><link href="http://guqian110.github.io/pages/2014/04/10/run_warcraft_on_ubuntu.html" rel="alternate"></link><updated>2014-04-10T10:58:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-10:pages/2014/04/10/run_warcraft_on_ubuntu.html</id><summary type="html">&lt;p&gt;闲来无聊，在 Ubuntu 下 wine 了一个 WarCraft 3 玩&lt;/p&gt;
&lt;p&gt;在实验室的 ”老爷车“ 电脑上运行。稍微有一点卡，在5年前买的笔记本（core 2 T6600, 4G RAM）上运行就感觉不到卡了 。&lt;/p&gt;
&lt;p&gt;实验室电脑配置：&lt;/p&gt;
&lt;p&gt;Processor: Pentium(R) Dual-Core CPU E5200 @ 2.50GHz × 2 &lt;/p&gt;
&lt;p&gt;Graphics: Gallium 0.4 on NV86&lt;/p&gt;
&lt;p&gt;Memory: 2.0 GiB&lt;/p&gt;
&lt;p&gt;OS type: 32-bit&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;安装 Wine&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Wine_(software)"&gt;Wine&lt;/a&gt; 是 wine is not an emulator 的缩写，它可以在 x86、x86-64 上容许类 Unix 操作系统在 X Window System 下运行 Microsoft Windows 程序的软件 .它的官方网址：http://www.winehq.org/&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;p&gt;Ubuntu 软件仓里搜索 Wine，就可以找到 &lt;code&gt;Wine Windows Program Loader&lt;/code&gt;，直接安装即可&lt;/p&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;apt-get&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt; &lt;span class="n"&gt;wine&lt;/span&gt;
&lt;span class="n"&gt;suod&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;wine&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;P.S. 若是其他系统，找不到对应的二进制包，可以直接从官网上下载源码，自己编译（官网上有详细的 &lt;a href="http://wiki.winehq.org/FAQ_zhcn"&gt;FAQ&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;拷贝 WarCraft&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;如果是双系统，则不必拷贝 WarCraft 文件夹，因为我电脑上只有 Ubuntu，所以从同学那里拷贝了一个，放在了 &lt;code&gt;～/&lt;/code&gt; 目录下 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;配置 Wine &amp;amp; WarCraft&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;CD key 注册表问题&lt;/h3&gt;
&lt;p&gt;直接以 wine 运行 &lt;code&gt;war3.exe&lt;/code&gt; 时提示没有 CD key，在 WarCraft 目录下找到了两个注册表文件，&lt;code&gt;War3.reg&lt;/code&gt; 和 &lt;code&gt;一键导入.reg&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在终端下导入注册表&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wine&lt;/span&gt; &lt;span class="n"&gt;regedit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后导入这两个文件，再次尝试，还是不行...&lt;/p&gt;
&lt;p&gt;不急，游戏目录下还有一个程序叫 &lt;code&gt;War3RegFixer.exe&lt;/code&gt;，看名字就知道是我们需要的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wine&lt;/span&gt; &lt;span class="n"&gt;War3RegFixer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exe&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为我的 Ubuntu 是英文版的，打开后是乱码...&lt;/p&gt;
&lt;p&gt;&lt;img alt="war3regfixer" src="/images/run-warcraft-on-ubuntu/war3regfixer.png" /&gt;&lt;/p&gt;
&lt;p&gt;找了一台 Windows 电脑，运行了一下，按照向导就可以修复 CD key 的问题 。&lt;/p&gt;
&lt;h3&gt;分辨率问题&lt;/h3&gt;
&lt;p&gt;第一次运行的结果一般不会全屏，处女座的强迫症犯了，还好比较简单 ：D&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wine&lt;/span&gt; &lt;span class="n"&gt;regedit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;找到 &lt;code&gt;HKEY_CURRENT_USER/Software/Blizzard Entertainment/Warcraft III/Video&lt;/code&gt;，里面有两个注册表值 &lt;code&gt;resheight&lt;/code&gt; 和 &lt;code&gt;reswidth&lt;/code&gt;，将他们设为和当前分辨率相同的十进制数值就可以了。&lt;/p&gt;
&lt;h3&gt;画面卡&lt;/h3&gt;
&lt;p&gt;因为 Wine 对 DirectX 的支持还不够好，如果电脑配置比较低，运行的时候添加参数 &lt;code&gt;-opengl&lt;/code&gt; 就可以了，为了避免每次运行都要输入参数，可以在注册表 &lt;code&gt;HKEY_CURRENT_USER/Software/Blizzard Entertainment/Warcraft III/&lt;/code&gt; 下新建整数（DWORD），名为 &lt;code&gt;Gfx OpenGL&lt;/code&gt;，值为 1 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;h3&gt;终端下&lt;/h3&gt;
&lt;p&gt;现在就可以在终端下运行 war3.exe 了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wine&lt;/span&gt; &lt;span class="n"&gt;war3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exe&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;熟悉的画面就出来了～&lt;/p&gt;
&lt;p&gt;这样子运行如果切出游戏，有时会导致 war3 崩溃或者切换不出去。一个解决方法是以窗口模式运行，只需要添加参数 &lt;code&gt;-window&lt;/code&gt; 即可&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wine&lt;/span&gt; &lt;span class="n"&gt;war3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exe&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;window&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;效果如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="war3window" src="/images/run-warcraft-on-ubuntu/war3window.png" /&gt;&lt;/p&gt;
&lt;p&gt;不过个人不是很喜欢，因为鼠标总是超出窗口，极其不方便，影响游戏操作和感受 ：D&lt;/p&gt;
&lt;h3&gt;桌面启动器&lt;/h3&gt;
&lt;p&gt;我们可以为 war3 添加一个桌面启动器，这样就不用进入终端启动了&lt;/p&gt;
&lt;p&gt;新建文件 &lt;code&gt;frozen-throne.desktop&lt;/code&gt; 文件，添加以下内容&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[Desktop Entry]&lt;/span&gt;
&lt;span class="na"&gt;Version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;1.0&lt;/span&gt;
&lt;span class="na"&gt;Name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;Frozen Throne&lt;/span&gt;
&lt;span class="na"&gt;Exec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/home/chien/WarCraft/war3.exe&lt;/span&gt;
&lt;span class="na"&gt;Terminal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;false&lt;/span&gt;
&lt;span class="na"&gt;Icon&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/home/chien/WarCraft/war3.jpg&lt;/span&gt;
&lt;span class="na"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;Application&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后把这个文件移动到 &lt;code&gt;/usr/share/applicants/&lt;/code&gt; ，这时在 unity 中搜索 &lt;code&gt;froz&lt;/code&gt;，就能看到我们刚才新建的启动器了～&lt;/p&gt;
&lt;p&gt;&lt;img alt="war3desktop" src="/images/run-warcraft-on-ubuntu/war3desktop.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;至此，就可以在 Ubuntu 下享受 War3 了&lt;/p&gt;
&lt;p&gt;gl hf！&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://linux-wiki.cn/wiki/zh-hans/%E7%94%A8Wine%E8%BF%90%E8%A1%8C%E9%AD%94%E5%85%BD%E4%BA%89%E9%9C%B8III"&gt;用Wine运行魔兽争霸III&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.ubuntusoft.com/wine-warcraft-3.html#.U0Xt11SSx38"&gt;Wine 魔兽争霸3的一些设置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://hi.baidu.com/chenwzox/item/4e6346f1575a7ab231c199b4"&gt;Wine魔兽争霸3，流畅运行+键盘操作+窗口化&lt;/a&gt;&lt;/p&gt;</summary><category term="Wine"></category><category term="WarCraft"></category></entry><entry><title>乔布斯传 书评</title><link href="http://guqian110.github.io/pages/2014/04/09/steve_jobs_review.html" rel="alternate"></link><updated>2014-04-09T17:14:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-09:pages/2014/04/09/steve_jobs_review.html</id><summary type="html">&lt;p&gt;一直想买本 &lt;a href="http://book.douban.com/subject/6798611/"&gt;《乔布斯传》&lt;/a&gt;，但是被 ￥68.00 的定价击败了，舍不得花钱买 :D 但是电子书的体验真的太差，看了一半就没有坚持下来。突然发现有个同学有本崭新的《乔布斯传》，于是借来用闲暇时间看了一个多月才看完...&lt;/p&gt;
&lt;p&gt;作为一名资深“挨踢”菜鸟，乔布斯的名字可以说是如雷贯耳，他在普通人眼中，尤其是果粉眼中，基本上就是神一般的存在。以前我也一直这么认为，直到看完这本书，我才发现事实中的“乔帮主”完全是另外一个人，一个有爱有恨，爱哭，执着的同时执着到固执的地步，毫不做作的一个人。&lt;/p&gt;
&lt;p&gt;写几点感触吧，以证明没有白看这本书，看书的价值就在与思考～&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;爱哭的教主&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;这是我看书时，最惊奇的地方。有网友统计，传记里记载的乔布斯一共哭泣了 157 次，其中哭倒在地 25 次，大哭并尖叫 34 次，泪流满面 42 次。以前觉得神一样的“乔帮主”肯定是神挡杀神，佛挡杀佛，怎么会动不动就哭鼻子呢。联系他的人生经历，原来这样子更符合他的性格 。&lt;/p&gt;
&lt;p&gt;在知乎上看到&lt;a href="http://www.zhihu.com/question/19875002"&gt;一个回答&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;乔布斯是一个多愁善感的人，他经常哭。他从小就发现这种方式能达到目的。我觉得实际上他是那种不去刻意控制自己情绪的人，想哭就哭，想骂就骂，想夸就夸，不受限制。我们所知道的他哭的例子，只不过是几个很有名的瞬间，被放大了。&lt;/p&gt;
&lt;p&gt;我们从小就被"男儿有泪不轻弹"给害了，变成了貌似坚强，却浅了情感。&lt;/p&gt;
&lt;p&gt;i hope i can cry when i want to.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或许，这样率性，真实的人生是另外一种更值得追求的选择，只是这种性格注定只有两种结局：1. 你很nb，可以把内心的真实想法随意说出来，别人即使很不爽，但是也不能对你怎么样，甚至尊敬你，这种最典型的就是yy小说中的主人公，而现实生活中则没几个，乔布斯就是典型例子；2. 你自己没有什么本事，还有一身尖酸刻薄的臭脾气，最后只能是连一个朋友也没有，一事无成。而大多数人，都会选择作出“正确”的选择——尽量修炼自己，积累知识，同时在这个人情冷漠的年代找到一两个好朋友和“红颜／蓝颜知己” 。&lt;/p&gt;
&lt;p&gt;不是任何一个人想哭就能哭的，这也是需要一定资本足够nb才行...&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ithome.com/html/it/50290.htm"&gt;乔布斯为何而哭？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;嬉皮士＆禅宗＆迷幻药＆现实扭曲力场&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;乔布斯由于自己身世的原因，总是对这种追求人生真谛的事很感兴趣 。（前半句为个人猜测，后半句是事实）他经历了嬉皮士运动，去印度寻找过 “精神导师”，嗑过迷幻药，在遇到罗伯特 弗里德兰之前，他羞涩又谦逊，非常内敛，但是很快他就学会了弗里德兰的强大气场，并且发展成为自己著名的“现实扭曲力场” 。&lt;/p&gt;
&lt;p&gt;乔布斯从来都不是标准意义上的“好学生”，相反，他叛逆，敏感，但是他也喜欢思考，在养父的影响下，他培养出了对细节要求到苛刻的“工匠精神” 。他直接给惠普的创始人打电话要求一份临时工的工作，参见工程师的会议，探索自己感兴趣的电路，和沃兹一起做出 “能打电话的盒子”，大发一笔 。另一方面，他又直接逼自己的养父母同意退学，去了里德学院，结果还是不去上课，上了一半就退学了 。&lt;/p&gt;
&lt;p&gt;这样的上学经历，在中国人看来，真的是无可就药，他能有后来的成就真的是不可思议。我好像为自己翘课，学习成绩不好找到了一个完美的借口...关于为什么中国出不了乔布斯，中外教育制度差别等话题都被谈烂了，个人认为，外界的客观环境是一方面，自身的努力也很重要（不仅中国出不了乔布斯，事实上，全世界也就这么一位，在美国，乔布斯也不是普通人能效仿的，不然美国遍地都是乔布斯了 -.-）。&lt;/p&gt;
&lt;h2&gt;站在人文与科技的十字路口&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href="http://apple4us.com/2011/10/jobs-begin-end.html"&gt;乔布斯：初心与终点&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;乔布斯是令人倾慕的天才、艺术家、犀利的商业决策者，而他亦正亦邪的浪子一面，暴君般肆虐、魔鬼般欺骗、傀儡师般操控他人，则平添戏剧性和张力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;乔布斯与他的同行们不同。盖茨、Facebook 的扎克伯格和亚马逊的贝佐斯们所致力的，都是将技术融入生活：无论让每户人家的桌子上摆一台电脑、让每个人将自己的身份及社会关系映射到互联网上，还是通过互联网销售书籍、音乐和电影。他们像工业革命时代掌握蒸汽机的人一样，以更高级的技术破坏既有的世界规则，并以此打造庞大的商业帝国 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;而科技对于乔布斯，更像画笔之于梵高、刻刀之于米开朗基罗。他热爱美好的事物，也希望自己成为一名创作者。自 21 岁创立苹果电脑，到 56 岁宣布退休，35 年间他主导设计的软、硬件各超过百款，而在美国商标专利局备案的署有他的名字的专利就多达 300 余个——相比之下，拥有更深厚技术背景的盖茨名下的专利不过九项、Google 的两名创始人拉里·佩奇和谢尔盖·布林拥有的专利总和也没超过 20 个 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以前美国的专利申请很宽松，乔帮主的专利大多数应该是设计方面的吧，而佩奇的专利明显更有技术含量 。&lt;/p&gt;
&lt;p&gt;乔帮主最看不上盖茨的就是 “糟糕的品味”，而盖茨也在访谈中承认自己最想拥有的就是一流的品味。两个人的人生轨迹完全不同，代表了完全相反的两条路，却最终成一生的对手和朋友，多么神奇 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;控制欲&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;乔帮主追求完美的欲望和控制欲强烈到一种不可思议的地步，他想控制产品的方方面面，不但是用户体验，甚至不想让用户拆开 Mac，iphone；里面的电路也和外面一样精致，即使用户永远都不会看到。用户买来直接用就行了，其他的全部由他，苹果公司负责，甚至他认为用户从来不知道自己需要什么样的产品，如汽车的发明人福特说的一样——”在我发明汽车以前，人们只会想买一辆什么样的马车“ 。&lt;/p&gt;
&lt;p&gt;他的这种控制欲望能成功，是建立在高雅的品味之上的。这种软件、硬件一体化，端到端的产品更本轮不到用户插手，这和 Geek 精神完全相悖，在 Apple I 时，他和沃兹的分歧就已经出现了，最终以教主的痛哭流涕收场。幸好这个世界上 Geek 只是少数，幸好他的艺术品味一流高雅，发明了改变P C、手机、动画、音乐等行业的产品，让我们体验到什么是美好的产品 。&lt;/p&gt;
&lt;p&gt;但是这种控制欲和他的 ”现实扭曲力场“ 也有副作用。在饮食上他是严格的素食主义者，面对他得癌症的现实，他也选择性的忽略，即使后来身体状况很糟糕了，他仍然只吃蔬菜和水果。如果他能及早面对癌症肿瘤，或许可以在扩散之前就控制住病情，但是他是乔布斯，所以他不会这样。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Jobs 像个任性的大孩子，尽情挥洒着自己的才能，永不停歇的迈向理想。留给中国人太多感动和反思 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.ithome.com/html/it/50290.htm"&gt;乔布斯为何而哭？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://apple4us.com/2011/10/jobs-begin-end.html"&gt;乔布斯：初心与终点&lt;/a&gt;&lt;/p&gt;</summary><category term="Steve Jobs"></category><category term="review"></category></entry><entry><title>C++ const 限定符</title><link href="http://guqian110.github.io/pages/2014/04/09/cosnt_qualifier.html" rel="alternate"></link><updated>2014-04-09T11:13:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-09:pages/2014/04/09/cosnt_qualifier.html</id><summary type="html">&lt;h2&gt;为什么要使用 const 限定符&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;一个需要使用 const 的简单例子&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;&lt;em&gt;C++ Primer&lt;/em&gt;&lt;/a&gt; 中的例子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段代码语法上是没有问题的，但是事实上是有两个小问题的，而且两个小问题都和数字 &lt;code&gt;512&lt;/code&gt; 有关 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一个问题是 程序的可读性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较 &lt;code&gt;index&lt;/code&gt; 与 &lt;code&gt;512&lt;/code&gt; 有什么意思呢？也就是说 512 这个值作用何在？在程序中这种数字被称为 &lt;code&gt;魔数（magic number）&lt;/code&gt;，它的意义在上下文中没有体现出来，好像这个数是凭空魔术般变出来的 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个问题是 程序的可维护性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如歌这个程序非常庞大，512 这个数字出现了 100 次，进一步假设这 100 次中，有 80 次是表示某个缓冲区的大小，剩余 20 次用于其他目的 。现在，我们需要把缓冲区的大小增大到 1024，要实现这个目标，必须检查每个 512 出现的位置，必须确定哪些是表示缓冲区大小，哪些不是 。&lt;/p&gt;
&lt;p&gt;解决这两个问题的方法是定义一个变量，并且初始化为 512&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过定义一个好记的变量，就可以增强程序的可读性，而且需要改变这个值时，只需要咋初始化的地方做修改 。这种方法不仅明显减小了工作量，而且大大减小了出错的可能性 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;看起来问题好像已经解决了，但是，事实上，我们可以进一步&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在上面的代码中，&lt;code&gt;buf_size&lt;/code&gt; 是可以被修改的，它有可能会被有意或者无意修改 。为了避免这种情况，就需要使用 const 限定符了 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;定义 &lt;code&gt;buf_size&lt;/code&gt; 为 &lt;strong&gt;常量（constant）&lt;/strong&gt;，并且初始化为 512 .&lt;strong&gt;变量（variable）&lt;/strong&gt; &lt;code&gt;buf_size&lt;/code&gt; 仍然是一个左值，但是这个左值现在是不能被修改的。（因为 const 把变量转化为常量，所以在定义的时候必须初始化！）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;如何使用 const 限定符&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;C++ Primer 中有这么一句话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It (const) transforms an object into a constant.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是在这句话之后有说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The variable bufSize is still an lvalue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是矛盾的，因为常量是不能当左值的 。个人感觉严谨的说法应该是 "cosnt 使变量具有了常量的属性“&lt;/p&gt;
&lt;h3&gt;文件的局部变量&lt;/h3&gt;
&lt;p&gt;const 限定符修同时也改变了变量的作用范围 。普通非 const 变量的默认是具有 &lt;em&gt;外部连接（external linkage）&lt;/em&gt;的，在全局作用域内定义非 const 变量时，它在整个程序中都可以被访问 。比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;// file1.cpp&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//file2.cpp&lt;/span&gt;
    &lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是，对于 全局作用域内的 const 类型的对象，其默认是 &lt;em&gt;内部连接（internal linkage）&lt;/em&gt;，仅在定义该对象的文件内可见，不能被其他文件访问 。要想在整个程序里面访问，就必须在定义的时候显式地声明为 &lt;code&gt;extern&lt;/code&gt; 类型 。比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;//file1.cpp&lt;/span&gt;
    &lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fcn&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;//fiel2.cpp&lt;/span&gt;
    &lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用 const 的方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义在头文件中 inlcude&lt;/p&gt;
&lt;p&gt;如果 const 变量是用常量表达式初始化的，那么就可以把它的定义放在头文件中，即使多次包含这个头文件也不会产生 ”重定义“  的问题 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// file1.h&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// file2.cpp&lt;/span&gt;
&lt;span class="k"&gt;include&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;file1.h&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义时声明为 extern&lt;/p&gt;
&lt;p&gt;如果 const 变量不是用常量表达式初始化的，那么就不能把它当在头文件中 。只能在源文件中定义并初始化 。因为 const 变量是文件局部变量，所以要在其他文件中使用该变量，必须在定义时加上 &lt;code&gt;extern&lt;/code&gt; 声明 。&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// file1.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在头文件中声明为 extern 类型，以使其他文件共享。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// file1.h&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// fil2.cpp&lt;/span&gt;
&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="k"&gt;include&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;file1.h&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不需要在头文件中声明，在其他文件中使用前声明&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// file2.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 在 C 中 const 是默认为外部连接的，在 C++ 中是默认为内部连接的 。&lt;/p&gt;
&lt;p&gt;至于为什么要这么规定，&lt;a href="http://book.douban.com/subject/1459728/"&gt;Thinking in C++&lt;/a&gt; 中有说明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Constants were introduced in early versions of C++ while the Standard C specification was
still being finished. It was then seen as a good idea and included in C. But somehow, const in
C came to mean “an ordinary variable that cannot be changed.” &lt;em&gt;In C, it always occupies
storage and its name is global. The C compiler cannot treat a const as a compile-time
constant.&lt;/em&gt; In C, if you say&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;you will get an error, even though it seems like a rational thing to do. Because bufsize
occupies storage somewhere, the C compiler cannot know the value at compile time.&lt;/p&gt;
&lt;p&gt;In C++, a const doesn’t necessarily create storage. In C a const always creates storage.
Whether or not storage is reserved for a const in C++ depends on how it is used. In general, if
a const is used simply to replace a name with a value (just as you would use a #define), then
storage doesn’t have to be created for the const. If no storage is created (this depends on the
complexity of the data type and the sophistication of the compiler), the values may be folded
into the code for greater efficiency after type checking, not before, as with #define. If,
however, you take an address of a const(even unknowingly, by passing it to a function that
takes a reference argument) or you define it as extern, then storage is created for the const.&lt;/p&gt;
&lt;p&gt;Since a const in C++ defaults to internal linkage, you can’t just define a const in one file and
reference it as an extern in another file. To give a const external linkage so it can be
referenced from another file, you must explicitly define it as extern, like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Notice that by giving it an initializer and saying it is extern, you force storage to be created for the const(although the compiler still has the option of doing constant folding here). The
initialization establishes this as a definition, not a declaration. The declaration:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;in C++ means that the definition exists elsewhere (again, this is not necessarily true in C).
&lt;em&gt;You can now see why C++ requires a constdefinition to have an initializer: the initializer
distinguishes a declaration from a definition (in C it’s always a definition, so no initializer is
necessary).&lt;/em&gt; With an external constdeclaration, the compiler cannot do constant folding
because it doesn’t know the value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;const 引用 &amp;amp; const 对象&lt;/h3&gt;
&lt;p&gt;在引用的定义中声明 const，此 const 约束的是引用，而不是引用的对象 。比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ival&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，&lt;code&gt;const&lt;/code&gt; 修饰的是 &lt;code&gt;int &amp;amp;&lt;/code&gt;，规定了引用 &lt;code&gt;ref&lt;/code&gt; 为 const 类型变量，而 &lt;code&gt;ival&lt;/code&gt; 的类型则由其他语句定义说明 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;const 引用： 引用变量为 const 类型，引用对象的类型可以是 const、nonconst、r-value&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nonconst 引用： 引用变量为 nonconst 类型，引用对象只能是同类型的 nonconst 类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为引用只是对象的另外一个名字，它们指向的是统一块内存空间，所以通过修改引用的值就能达到修改对象的值的目的 。&lt;/p&gt;
&lt;p&gt;当对象是 const 类型时，隐含的含义是该对象不能被修改，所以只能定义 const 类型的引用指向它；nonconst 类型的引用隐含的意思是可以通过引用修改对象值，这对于 const 类型的对象来说是不允许的 。&lt;/p&gt;
&lt;p&gt;当对象是 nonconst 类型时，隐含的含义是该对象可以通过引用来修改，此时，const 引用和 nonconst 引用都可以指向该对象 。当使用 nonconst 引用时，可以通过引用修改对象的值；当使用 const 引用时，虽然对象的值是可以改变的，但是不能通过该引用修改，因为引用的类型是 const，定义以后，不能再修改 。 &lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;何时应该使用 const&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Scott Meyers 大神的经典著作 &lt;a href="http://book.douban.com/subject/1842426/"&gt;Effective C++&lt;/a&gt; 里面提到的关于 const 的使用 。&lt;/p&gt;
&lt;h3&gt;Effective C++ 条款 02：尽量以 const、enum、inline 替换 #define（Prefer consts,enums,and inline to #define）&lt;/h3&gt;
&lt;p&gt;使用const 代替 #define，事实上 &lt;code&gt;const&lt;/code&gt; 的最初动机就是取代预处理器 &lt;code&gt;#define&lt;/code&gt; 来进行值替代 。因为 #define 不被视为语言的一部分，这就是它的问题所在 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c"&gt;#define ASPECT_RATIO 1.653;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;记号名 ASPECT_RATIO 也许从未被编译器看见，也许在编译器开始处理代码前就被与处理器移走了，于是记号没有进入记号表，当出现编译错误时，也许会提示是 1.653 而不是 ASPECT_RATIO，这回带来很多困惑 。&lt;/p&gt;
&lt;p&gt;解决之道就是以一个常量代替上述的宏&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;AspectRatio&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.653&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Effective C++ 条款 03：尽可能使用 const（Use const whenever possile）&lt;/h3&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;C++ Primer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1459728/"&gt;Thinking in C++&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1842426/"&gt;Effective C++&lt;/a&gt;&lt;/p&gt;</summary><category term="C"></category><category term="C++"></category></entry><entry><title>脉冲边沿检测</title><link href="http://guqian110.github.io/pages/2014/04/08/pulse_edge_detection.html" rel="alternate"></link><updated>2014-04-08T18:33:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-08:pages/2014/04/08/pulse_edge_detection.html</id><summary type="html">&lt;p&gt;脉冲边沿检测是 FPGA 设计中经常用到的方法，本文总结一下其原理和实现代码，可以将其加入我们自己的代码库中，以备以后使用 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测原理&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img alt="pulse" src="/images/learning-fpga-pulse-edge-detection/pulse.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;如图，任何一个脉冲既有上升沿也有下降沿，系统的时钟周期一定要比脉冲宽度小，而且越小越好，即频率越高越好 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脉冲边沿的特点就是：边沿两侧的电平发生了变化 。&lt;/strong&gt; 利用这一点，我们就可以设计出检测边沿的方法 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作方法：&lt;/strong&gt; 建立 2 个寄存器，形成二级寄存器，在时钟触发中，首先把数据送入第一个寄存器中，然后在下一个时钟上沿到来时，将第一个寄存器中的数据存入第二个寄存器，也就是说第二个寄存器中的数据始终比第一个寄存器晚一个周期，即晚一个数据 。根据系统时钟检测，如果前后进来的信号发生了变化，可以用异或运算，异或结果为1，说明电平发生了变化，有边沿产生。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测方法&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;检测是否有边沿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
        &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_edge&lt;/span&gt;  
        &lt;span class="p"&gt;);&lt;/span&gt; 

        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trigedge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
        &lt;span class="n"&gt;end&lt;/span&gt;  

        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trigEdge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

    &lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl1" src="/images/learning-fpga-pulse-edge-detection/rtl1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim1" src="/images/learning-fpga-pulse-edge-detection/sim1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;检测 上/下 边沿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;下降沿检测原理：&lt;/strong&gt; 将第一个寄存器中的数据取反与第二个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 1 变为 0 时，就会在新的寄存器里产生一个高电平，并维持一个周期 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上升沿检测原理：&lt;/strong&gt; 将第二个寄存器中的数据取反与第一个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 0 变为 1 时（上升沿，此时 r1 变为 1，但 r2 仍保持前一周期的 0），就会在新的寄存器里产生一个高电平，并维持一个周期 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
        &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;  
        &lt;span class="p"&gt;);&lt;/span&gt;  

        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;  
        &lt;span class="n"&gt;end&lt;/span&gt;  

        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// Detect posedge  &lt;/span&gt;
        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// Detect negedge  &lt;/span&gt;

    &lt;span class="n"&gt;endmodule&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl2" src="/images/learning-fpga-pulse-edge-detection/rtl2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim2" src="/images/learning-fpga-pulse-edge-detection/sim2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外一种写法：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="nf"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
        &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tirg_pos_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;  
        &lt;span class="p"&gt;);&lt;/span&gt;  

        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="k"&gt;else&lt;/span&gt;  
                &lt;span class="n"&gt;trig_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
        &lt;span class="n"&gt;end&lt;/span&gt;  

        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="n"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  

    &lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl3" src="/images/learning-fpga-pulse-edge-detection/rtl3.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim3" src="/images/learning-fpga-pulse-edge-detection/sim3.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;脉冲边沿检测应用&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;理想的键盘输入特性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keyboard1" src="/images/learning-fpga-pulse-edge-detection/keyboard1.png" /&gt;&lt;/p&gt;
&lt;p&gt;然而实际的键盘受制造工艺等影响，其输入特性不可能如上图完美 。当按键按下时，在触点即将接触到完全接触这段时间里，键盘的通断状态很可能已经改变了多次 。即在这段时间里，键盘输入了多次逻辑 0 和 1，也就是输入处于失控状态 。如果这些输入被系统响应，则系统暂时也将处于失控状态，这是我们要尽量避免的 。在触点即将分离到完全分离这段时间也是一样的 。&lt;/p&gt;
&lt;p&gt;实际的键盘输入特性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keyboard2" src="/images/learning-fpga-pulse-edge-detection/keyboard2.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件消抖&lt;/strong&gt; 要占用系统资源，在系统资源充足的情况下使用软件消抖更加简单 。软件消抖的实质在于降低键盘输入端口的采样频率，将高频抖动略去 。实际应用中通常采用延时跳过高频抖动区间，然后再检测输入做出相应处理。一般程序代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="c1"&gt;//一旦检测到键值&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Delay&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;//延时20ms，有效滤除按键的抖动&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;//再次确定键值是否有效&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt;    &lt;span class="c1"&gt;//执行相应处理&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段软消抖程序从机理上看不会有什么问题，通常在软件程序不太 "繁忙" 的情况下也能够很好的消抖并做相应处理 。但是如果在延时期间产生了中断，则此中断可能无法得到响应 。&lt;/p&gt;
&lt;p&gt;对于硬件资源丰富的 FPGA 系统，可以使用硬件来减轻软件工作量，通常称之为 &lt;strong&gt;"硬件加速"&lt;/strong&gt; 。在按键信号输入到软件系统前用逻辑对其进行一下简单的处理即可实现所谓的"硬件消抖"，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;//对输入信号inpio硬件滤波，每20ms采样一次当前值&lt;/span&gt;
    &lt;span class="n"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//20ms计数器&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_25m&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d500000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; 
            &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//当前inpio信号锁存，每20ms锁存一拍&lt;/span&gt;

    &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_25m&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;h7ffff&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;inpio_swin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//前后20ms两次锁存值都为0时才为0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该程序中设置了一个 20 ms 计数器，通过间隔 20 ms 对输入信号 inpio 采样两次，两次相同则认为键盘输入稳定，得到用硬件逻辑处理后的 inpio_swin 信号则是消抖处理过的信号 。程序不再需要 delay() 来滤波了，也不会出现使用纯软件处理出现的 "中断失去响应" 的情况了，这就是 "硬件加速" 的效果 。&lt;/p&gt;
&lt;p&gt;我们可以看到，传统单片机等系统大多是串行处理，即顺序执行，只能并行处理一些中断程序 。对于这样的系统，只能采用单纯软件或硬件电路消抖，但都不那么完美 。而对于 FPGA 等并行处理的系统，其优势就很明显，只要片内逻辑资源够用，通过硬件加速软件消抖的处理，完全可以做到按键消抖并行化，不影响系统的实时性 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG_ARTICLE_213430.HTM"&gt;脉冲边沿检测（Verilog）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/lg2lh/article/details/8104551"&gt;脉冲边沿检测原理verilog版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/LVY33/article/details/6225925"&gt;脉冲边缘检测法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_790c0ca10100srid.html"&gt;按键消抖&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category></entry><entry><title>(转载) 如何学习 FPGA</title><link href="http://guqian110.github.io/pages/2014/04/07/learning_fpga_how_to.html" rel="alternate"></link><updated>2014-04-07T16:16:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-07:pages/2014/04/07/learning_fpga_how_to.html</id><summary type="html">&lt;p&gt;学习 FPGA 差不多一年多，长期混迹于各大论坛，让我学习到了很多知识，转载一篇文章。&lt;/p&gt;
&lt;p&gt;当年在对于 FPGA 什么都不懂的情况下，觉得这篇文章相当高大上，现在看来，的确如此～和别的入门级别的文章书籍相比，这篇文章没有涉及 FPGA 设计的细节，而是很精炼地讲了 FPGA 设计中最基本的 &lt;em&gt;“世界观”&lt;/em&gt; 。也就是说这篇没有一头扎进 &lt;strong&gt;“术”&lt;/strong&gt; 的内容中让读者无从读起，而是从整体上给出 FPGA 设计的 &lt;strong&gt;“道”&lt;/strong&gt; 。对于初学者——尤其是我这样从软件思维过渡过来的人，的确是不错的入门指导 。&lt;/p&gt;
&lt;p&gt;转载地址：&lt;a href="http://www.ednchina.com/ART_8800513345_18_20010_TA_38ec22f4.HTM"&gt;如何学习FPGA？FPGA学习必备的基础知识&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;FPGA已成为现今的技术热点之一，无论学生还是工程师都希望跨进FPGA的大门。网络上各种开发板、培训班更是多如牛毛，仿佛在告诉你不懂FPGA你就OUT啦。那么我们要玩转FPGA必须具备哪些基础知识呢?下面我们慢慢道来。&lt;/p&gt;
&lt;h2&gt;要了解什么是FPGA&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;既然要玩转FPGA，那我们首先最重要的当然是要了解什么 FPGA 。FPGA（Field-Programmable Gate Array），即现场可编程门阵列 。看到编程两个字码农就笑了，不就是编程嘛，那可是我们的强项 。且慢，此编程非彼编程 。一定要把 FPGA 的编程和软件编程区分开来 。软件的编程，处理器会逐条的把语言翻译成各种控制信号，去控制内部电路完成一个个运算或操作 。那么FPGA的编程是怎么实现的呢？无论 Altera 家还是 Xlinix 家的 FPGA，叫法有什么差异，基本单元都相似，都是由真值表和 D 触发器构成 。改变真值表的值就改变了逻辑功能，再通过和D触发器组合来实现任何时序逻辑 。所以我们对 FPGA 的编程，实际上就是去修改这些真值表和连接关系，使他们组成一张专门的真值表，去实现特定的功能 。这和软件编程一步步运行程序有本质的区别 。要想玩转 FPGA，就必须理解 FPGA 内部的工作原理，学习如何利用这些单元实现复杂的逻辑设计 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;正确理解HDL语言&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;HDL（Hardware Description Language），硬件描述语言 。通过名称我们能看出来，HDL语言是一种 “描述” 语言，这一点和 C 语言是有本质区别的 。正确理解描述的含义，对学好 HDL 语言很有帮助 。HDL 语言只是用文本的方式把硬件电路描述出来 。我们在阅读 HDL 程序的时候，在脑子里应该能反映出一个完整的硬件电路结构 。从另一方面说，我们在编写 HDL 语言之前，就已经对要实现的电路有清晰的概念 。所以 HDL 语言只是一个描述我们头脑中具体电路的工具，&lt;strong&gt;玩转 FPGA 的根本不是语言而是逻辑电路设计&lt;/strong&gt;。不要再纠结于我应该学习 VHDL 还是 Verilog，哪种语言更好学这些问题 。如果把学习 FPGA 的重点放在学习语言上，死记硬背一些语法，那自然是抓错了重点 。语言在日常使用中会越用越熟练，不需要花很长的专门时间去学习 。当然一本好的参考资料可以随时方便查询会是很有帮助的 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;数字电路基础&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;说到底，FPGA 就是一堆数字逻辑组合在一起实现特定功能而已 。所以数字电路基础知识是根本 。如果你连触发器，组合电路，时序电路，竞争，毛刺等等基本概念还莫能两可不清不楚的话，那玩转 FPGA 只能是痴人说梦的幻想了 。我们必须要好好的学好数字电路基础这门课，基本的数字电路烂熟于心 。把这些基础打牢固，再往更深的方向发展 。什么时候能够从抽象的算法中提炼算法的结构，再分解成具体的模块并通过硬件电路实现出来，这时候就算从菜鸟级别步入老鸟级别了 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;硬件设计思想&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;这一点应该说是重中之重 。学习 FPGA，一定要有硬件设计思想 。在软件编程的时候，比如 1 秒钟能实现 5 次乘法运算，那系统要求 1 秒钟实现 50 次乘法运算怎么办，我们会尽可能的优化代码，让代码更简洁更高效，或者提高系统主频，让系统跑的更快 。但是在 FPGA 里面我们不是这种思维方式。在 FPGA 里实现一个乘法器不够用，那我就实现两个实现三个去满足系统要求；我可以进行流水线设计；串行运行方式不够快了，我可以先串并转换，再并行的做处理 — —只要 FPGA 的资源够用，我可以充分利用资源去满足系统要求 。因为在我手里的就是一堆硬件资源，我要做的是把他们组合成一个好用的电路 。评价硬件描述语言写的好坏的标准和其他软件编程语言的标准是完全不同的 。因此一定要摒弃软件编程的一些固有思路，学会用硬件的方式去解决问题 。时刻提醒自己正在设计的是一个电路，而不是一行行空洞的代码 。这是很多做软件编程的人很难跨过的坎 。FPGA 学了很久还在纠结到底是用 &lt;code&gt;if-else&lt;/code&gt; 语句好呢还是用 &lt;code&gt;case&lt;/code&gt; 语句好？而不能透过这些语句表面看到他们所具体代表的电路 。只有建立了硬件设计思想，才有更深入学习FPGA的可能 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;FPGA 入门简单精通难 。要想入门，买一块开发板跟着例程走一遍，很多人都能在很短的时间内熟悉开发软件的操作方法并且点亮开发板上的 LED 或者再实现个跑马灯什么的，但是再往后进步往往就进展很慢 。上面提到的这四条是玩转 FPGA 的基础，只有打好了坚实的基础后面才能一马平川 。希望每个学习 FPGA 的人最后都能成为大牛，设计出自己的完美电路 。&lt;/p&gt;</summary><category term="FPGA"></category></entry><entry><title>学习 Linux SSH</title><link href="http://guqian110.github.io/pages/2014/04/04/learning_linux_ssh.html" rel="alternate"></link><updated>2014-04-04T17:00:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-04:pages/2014/04/04/learning_linux_ssh.html</id><summary type="html">&lt;p&gt;实验室的师兄师姐毕业了，继承了他们的旧电脑 。宿舍的笔记本和实验室的电脑出现了相互之间传送同步文件的需求 。想到了两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;云同步&lt;/li&gt;
&lt;li&gt;SSH / SCP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决方案 1 是最省事的，也是目前最流行的，目前各大互联网公司都提供各种云服务，比如国外的 Google Drive、Dropbox，国内的百度云、360 网盘什么的。这种方案最大的有点是跨平台，不过这个方案是借助了第三方的服务器，需要连接到互联网才行，而且对网速是有一定要求的。&lt;/p&gt;
&lt;p&gt;解决方案 2 相比于方案 1 的优势是：不是必须要连接到互联网，在局域网内也可以同步文件 。一般局域网内传输文件的速度要比连外界的服务器快很多 。&lt;/p&gt;
&lt;p&gt;考虑到校园网的环境，明显方案 2 更加好 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;什么是 SSH&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑 。&lt;a href="http://en.wikipedia.org/wiki/Secure_Shell"&gt;SSH&lt;/a&gt; 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为 Linux 系统的标准配置 。&lt;/p&gt;
&lt;p&gt;最初的 SSH 协议是由芬兰的一家公司的研究员 Tatu Ylönen 于 1995 年设计开发的，但是因为受版权和加密算法等等的限制，现在很多人都转而使用 OpenSSH 。OpenSSH 是 SSH 的替代软件包，而且是开放源代码和免费的 。—— Wikipedia&lt;/p&gt;
&lt;p&gt;关于 SSH 的原理，找到了一系列 &lt;a href="http://www.ruanyifeng.com/blog/"&gt;阮一峰&lt;/a&gt;的文章，很简洁明了:&lt;/p&gt;
&lt;h3&gt;SSH&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html"&gt;SSH原理与运用（一）：远程登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html"&gt;SSH原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;SSH 的用法&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;最简单明了的教程就是 man page 了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;内容为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;NAME&lt;/span&gt;
    &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;—&lt;/span&gt; &lt;span class="n"&gt;OpenSSH&lt;/span&gt; &lt;span class="n"&gt;SSH&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;login&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;SYNOPSIS&lt;/span&gt;
 &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1246&lt;/span&gt;&lt;span class="n"&gt;AaCfgKkMNnqsTtVvXxYy&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;bind_address&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;cipher_spec&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bind_address&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;escape_char&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;configfile&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;pkcs11&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;identity_file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bind_address&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hostport&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;login_name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;mac_spec&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;O&lt;/span&gt; &lt;span class="n"&gt;ctl_cmd&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;option&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bind_address&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hostport&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="n"&gt;ctl_path&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;W&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;local_tun&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;remote_tun&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;hostname&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进阶的书籍有：&lt;a href="http://docstore.mik.ua/orelly/networking_2ndEd/ssh/index.htm"&gt;SSH, The Secure Shell: The Definitive Guide&lt;/a&gt;, O'reilly&lt;/p&gt;
&lt;p&gt;目前已经有两台安装了 Ubuntu 的电脑，实验室的一台 name 是 &lt;em&gt;lab&lt;/em&gt; ，宿舍的一台 name 是 &lt;em&gt;dom&lt;/em&gt; ，两台电脑上都有一个用户名为 &lt;em&gt;chien&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们的目的是使两台电脑可以相互之间通过 SSH 访问。&lt;/strong&gt; 下面就是整个过程：&lt;/p&gt;
&lt;h3&gt;安装 SSH server&lt;/h3&gt;
&lt;p&gt;SSH 只是一种协议，在 Ubuntu 下，具体实现使用的是 &lt;a href="http://www.openssh.com/"&gt;OpenSSH&lt;/a&gt; 。Ubuntu 默认是安装了 SSH 客户端 &lt;code&gt;openssh-client&lt;/code&gt;，而没有安装 SSH 服务程序 &lt;code&gt;openssh-server&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;检测本机是否已经安装了 SSH server&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;localhost&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果结果是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="nl"&gt;ssh:&lt;/span&gt; &lt;span class="n"&gt;connect&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt; &lt;span class="n"&gt;localhost&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Connection&lt;/span&gt; &lt;span class="n"&gt;refused&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;说明 SSH server 还没有安装 。&lt;/p&gt;
&lt;p&gt;安装方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;openssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;启动 SSH 服务&lt;/h3&gt;
&lt;p&gt;启动 SSH server&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查询服务是否正确启动&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;ps&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;grep&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回结果应该类似于&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;     &lt;span class="mi"&gt;4156&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;        &lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;agent&lt;/span&gt;
     &lt;span class="mi"&gt;4606&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt;        &lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="n"&gt;sshd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;则说明服务已经正确启动 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;因为两台电脑要相互访问，所以它们的角色即使 server，又是 client，所以需要在两台电脑上都执行上面两步 。&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;远程访问&lt;/h3&gt;
&lt;p&gt;首先，查询本机 IP 地址&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;ifconfig&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比如 lab 的 IP 地址是 &lt;code&gt;10.105.55.155&lt;/code&gt;, dom 的 IP 地址是 &lt;code&gt;10.210.111.116&lt;/code&gt; 。（因为是校园网，所以分配到的都是内网地址）&lt;/p&gt;
&lt;p&gt;然后，在宿舍用 dom 访问 lab 这台机器&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mf"&gt;10.105.55.155&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实际结果如下图&lt;/p&gt;
&lt;p&gt;&lt;img alt="login1" src="/images/learning-linux-ssh/login1.png" /&gt;&lt;/p&gt;
&lt;p&gt;在执行命令前，提示符显示目前的用户是在 dom 这台机器上的用户 chien，本机 home 目录下有 &lt;code&gt;dom&lt;/code&gt; 文件，但是没有 &lt;code&gt;lab&lt;/code&gt; 文件 。执行了登录命令以后，就会切换到以 chien 身份登录到 lab 机器，远程机器 home 目录下有 &lt;code&gt;lab&lt;/code&gt; 文件，但是没有 &lt;code&gt;dom&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;p&gt;同理，在实验室用 lab 访问 dom 这台机器&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="mf"&gt;10.210.111.116&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实际结果如下图&lt;/p&gt;
&lt;p&gt;&lt;img alt="login2" src="/images/learning-linux-ssh/login2.png" /&gt;&lt;/p&gt;
&lt;p&gt;在执行命令前，提示符显示目前的用户是在 lab 这台机器上的用户 chien，本机 home 目录下有 &lt;code&gt;lab&lt;/code&gt; 文件，但是没有 &lt;code&gt;dom&lt;/code&gt; 文件 。执行了登录命令以后，就会切换到以 chien 身份登录到 dom 机器，远程机器 home 目录下有有 &lt;code&gt;dom&lt;/code&gt; 文件，但是没有 &lt;code&gt;lab&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;h3&gt;省去 IP 地址&lt;/h3&gt;
&lt;p&gt;每次登录都需要记忆、手动输入 IP 地址，其实只需要改 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件，就能省去手动输入 IP 地址的烦恼。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hosts&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 dom 的 hosts 文件后面添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;lab&lt;/span&gt;    &lt;span class="mf"&gt;10.105.55.155&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 lab 的 hosts 文件后面添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;dom&lt;/span&gt;     &lt;span class="mf"&gt;10.210.111.116&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以后，登录时只需要输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;// from dom to lab&lt;/span&gt;
    &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;lab&lt;/span&gt;

    &lt;span class="c1"&gt;// from lab to domm&lt;/span&gt;
    &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;dom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就可以登录了。&lt;/p&gt;
&lt;h3&gt;公钥登录&lt;/h3&gt;
&lt;p&gt;上一步解决了 IP 地址的问题，但是还是需要手动输入密码 。我们可以用公钥登录的方法，免去输密码的烦恼。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，什么是数字签名 Digital Signature&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html"&gt;数字签名是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youdzone.com/signature.html"&gt;What is a Digital Signature?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次，生成数字签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu 默认安装了 &lt;code&gt;ssh-keygen&lt;/code&gt;，可以生成公钥和私钥&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;keygen&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令执行过程中会询问保存密钥文件的路径，还可以为密钥文件设置口令（passphrase）。运行结束以后，在 &lt;code&gt;$HOME/.ssh/&lt;/code&gt; 目录下，会新生成两个文件：&lt;code&gt;id_rsa.pub&lt;/code&gt; 和 &lt;code&gt;id_rsa&lt;/code&gt; 。前者是你的公钥，后者是你的私钥。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后，发布数字签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ssh-copy-id&lt;/code&gt; 命令可以把公钥复制到远程机器中 。&lt;/p&gt;
&lt;p&gt;将 dom 的公钥发送到 lab 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;di&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;lab&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将 lab 的公钥发送到 dom 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;di&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;dom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;最后，使用公钥登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时，远程登录时就不再需要输入密码了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;// from dom to lab&lt;/span&gt;
    &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;lab&lt;/span&gt;

    &lt;span class="c1"&gt;// from lab to dom&lt;/span&gt;
    &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;dom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;使用 SCP 传输文件&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;SSH 提供了一些命令和 shell 用来登录远程服务器 。在默认情况下它不允许你拷贝文件,但是还是提供了一个 "scp" 命令 。scp 命令是 SSH 中最方便有用的命令了，试想，在两台服务器之间直接传送文件。仅仅用 scp 一个命令就完全解决了 。&lt;/p&gt;
&lt;p&gt;man page&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;scp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;内容为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;NAME&lt;/span&gt;
 &lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="err"&gt;—&lt;/span&gt; &lt;span class="n"&gt;secure&lt;/span&gt; &lt;span class="n"&gt;copy&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="n"&gt;copy&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;SYNOPSIS&lt;/span&gt;
 &lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12346&lt;/span&gt;&lt;span class="n"&gt;BCpqrv&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;cipher&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;ssh_config&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;identity_file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;ssh_option&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;P&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;host1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;file1&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;host2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;file2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;scp 可以实现把 [[user@]host1:]file1 复制到 [[user@]host2:]file2 的功能。所以&lt;/p&gt;
&lt;h3&gt;上传 dom 本地文件至服务器 lab&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="n"&gt;dom&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;lab&lt;/span&gt;&lt;span class="o"&gt;:~/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;下载 lab 服务器文件至本地 dom&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;lab&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;lab&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;若发送文件夹则添加参数 &lt;code&gt;-r&lt;/code&gt; 即可&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;scp&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="n"&gt;chien&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;lab&lt;/span&gt;&lt;span class="o"&gt;:~/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;至此，就实现了两台电脑的之间相互远程访问的功能 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html"&gt;数字签名是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html"&gt;What is a Digital Signature?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html"&gt;SSH原理与运用（一）：远程登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youdzone.com/signature.html"&gt;SSH原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="SSH"></category></entry><entry><title>编写可综合的 Verilog HDL 代码</title><link href="http://guqian110.github.io/pages/2014/04/04/writing_synthesizable_code.html" rel="alternate"></link><updated>2014-04-04T01:35:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-04:pages/2014/04/04/writing_synthesizable_code.html</id><summary type="html">&lt;p&gt;对电路建模方法有很多种，可以用绘制原理图，也可以用 &lt;em&gt;硬件描述语言（Hardware Description Language）&lt;/em&gt; 建模 。硬件描述语言中最常用的就是 Verlilog 和 VHDL 。&lt;/p&gt;
&lt;p&gt;Verilog HDL和VHDL相比有很多优点，有C语言基础的话很容易上手。搜集了一些网上大神的经验总结和书上的例子，所以对于和我一样的初学者，这篇博客应该还是很有提高作用的，至于具体语法，任何一本书都讲的很详细。&lt;/p&gt;
&lt;h2&gt;HDL&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;从网上找到一篇文章，把 HDL 的历史说的非常清楚。&lt;/p&gt;
&lt;p&gt;作者 董培良 &lt;/p&gt;
&lt;p&gt;题目： &lt;a href="http://www.dzkf.cn/html/EDAjishu/2006/0720/9.html"&gt;浅谈VHDL/Verilog的可综合性以及对初学者的一些建议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要明确的是 VHDL 和 Verilog 并非是针对硬件设计而开发的语言，只不过目前被我们用来设计硬件。HDL 是 Hardware &lt;strong&gt;Description&lt;/strong&gt; Language 的缩写，正式中文名称是 “硬件描述语言”。也就是说，HDL 并不是 “硬件设计语言（Hardware &lt;strong&gt;Design&lt;/strong&gt; Language）”。别看只差这一个单词，正是这一个单词才决定了绝大部分电路设计必须遵循RTL的模式来编写代码，而不能随心所欲得写仅仅符合语法的 HDL 代码。&lt;/p&gt;
&lt;p&gt;VHDL 于 1980 年开始在美国国防部的指导下开发，完成于 1983 年，并于 1987 年成为 IEEE 的标准。当初开发这种语言，是出于美国国防部采购电子设备的需要。美军的装备采购自私人企业，时常要面对这样一种风险：如果某种武器大量装备部队，而其中某个零件的供应商却在几年后倒闭了，那这种武器的再生产、维修和保养都会出现大问题。而电子设备、尤其是集成电路的内部结构较为复杂，若出现前面所说的情况要找其他公司生产代用品非常困难。于是美国防部希望供应商能以某种形式留下其产品的信息，以保证一旦其破产后能由其他厂商迅速生产出代用品。&lt;/p&gt;
&lt;p&gt;显然，当初的设计文档显然是不能交出来的，这在美国会涉及商业机密和知识产权问题。于是美国防部就想出了一种折衷的方法——描述硬件的语言，也就是 VHDL 。通过 VHDL，供应商要把自己生产的集成电路芯片的行为描述出来：比如说，加了什么样的信号后过多少时间它能输出什么等等。这样，如果有必要让其他厂商生产代用品，他们只需照着 VHDL 文档，设计出行为与其相同的芯片即可。这样的代用品相当于是新厂商在不了解原产品结构的情况下独立设计的，所以不太会涉及知识侵权。&lt;/p&gt;
&lt;p&gt;Verilog HDL 也形成于差不多的年代，是由 Gateway Design Automation 公司大约在 1983 年左右开发的。其架构同 VHDL 相似，但主要被用来进行硬件仿真。或许私人公司更注重实用，Verilog 要比 VHDL 简洁得多。&lt;/p&gt;
&lt;p&gt;由此可见，这两种最流行的用于电路设计的语言，没有一种是为了设计硬件而开发的（更何况 80 年代还没有现在的那些功能强大的EDA软件呢）。因此，当初制订 HDL 语言标准的时候，并没有考虑这些代码如何用硬件来实现。换句话说，有些代码写起来简单，实现起来却可能非常复杂，或者几乎不可能实现。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;可综合代码&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;任何符合 HDL 语法标准的代码都是对硬件行为的一种描述，但不一定是可直接对应成电路的设计信息。行为描述可以基于不同的层次，如系统级，算法级，寄存器传输级(RTL)、门级等等。以目前大部分EDA软件的综合能力来说，&lt;strong&gt;只有RTL或更低层次的行为描述才能保证是可综合的&lt;/strong&gt;。而众多初学者试图做的，却是想让软件去综合 &lt;em&gt;算法级或者更加抽象的硬件行为描述&lt;/em&gt;。&lt;/p&gt;
&lt;h3&gt;所有综合工具都支持的语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="nx"&gt;always&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="nx"&gt;wire&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;tri&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;inout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;aupply0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;supply1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="nx"&gt;and&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;nand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;nor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;xor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;xnor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;not&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;bufif0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;bufif1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;notif0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;notif1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;instantitation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;module&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;negedge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;posedge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;operators&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parameter&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;有些工具支持，有些工具不支持的语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;asex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;casez&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;triand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;trior&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;disable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forever&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arrays&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;memories&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;repreat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建立可综合模块的原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不要用 initial （FPGA 上电时初始状态不定，一般需要上电复位信号，在复位信号有效的时候进行初始化，上电复位信号可以由外部手动输入，也可以系统自己产生 —— 写一个实现上电产生自动复位信号的模块）。P.S. 现在的综合软件功能已经足够强大，即使写了 initial 语句，在 ISE 13.3 中仍然是可综合的，而且没有 warning 和 info 的提示）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用 &lt;code&gt;#10&lt;/code&gt;（在仿真中有用，实际在硬件上不会实现）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用循环次数不定的循环语句，如 &lt;code&gt;forever&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt; 等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用用户自定义原语（UDP 原件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除非是关键路径设计，一般不采用调用门级原件描述的设计的方法，建议采用行为语句完成设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用同步方式设计电路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;code&gt;always&lt;/code&gt; 语句描述组合逻辑时，在敏感信号列表中要列出所有输入信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的内部寄存器都应该可以被复位，在 FPGA 设计时应尽量使用器件的全局复位端信号作为系统的总复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序逻辑使用非阻塞赋值，组合逻辑使用阻塞赋值，同一过程块中不要同时使用阻塞和非阻塞两种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要在不同的 &lt;code&gt;always&lt;/code&gt; 过程块中对同一变量赋值（否则综合时会提示有多驱动源错误，&lt;em&gt;multiple source
&lt;/em&gt;），对同一赋值对象，不能既使用阻塞赋值，又使用非阻塞赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不打算把变量综合成锁存器，在 &lt;code&gt;if&lt;/code&gt; 语句或 &lt;code&gt;case&lt;/code&gt; 语句的所有分支中都要对变量明确赋值（不能省去 &lt;code&gt;else&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt;，原理：在省去的情况下，变量的值会保持原来的值不变，所以系统会综合出一个锁存器 Latch）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免混合使用上升沿和下降沿触发器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一变量的赋值不能受多个时钟控制，也不能受两种不同时钟条件（或不同时钟沿）控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免在 &lt;code&gt;case&lt;/code&gt; 语句中使用 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;z&lt;/code&gt; 值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;不可综合代码&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;不可综合语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;defparam&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delays&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UDP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wait&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;initial&lt;/code&gt; 只能在 Testbench 中使用，不能综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;events&lt;/code&gt; 在 Testbench 中更有用，不能综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;real&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;time&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;force&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;assign&lt;/code&gt; 和 &lt;code&gt;deassign&lt;/code&gt; 不支持 &lt;code&gt;reg&lt;/code&gt; 类型的综合，支持 &lt;code&gt;wire&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fork...join&lt;/code&gt; 不可综合，可以用非块语句达到同样的效果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;primitives&lt;/code&gt; 支持门级原语综合，不支持非门级原语综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;table&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt; 的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一个 &lt;code&gt;reg&lt;/code&gt; 被多个 &lt;code&gt;always&lt;/code&gt; 块驱动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;延时，不可综合为硬件电路延时，综合工具会忽略延时，但是不会报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与 &lt;code&gt;x&lt;/code&gt;、&lt;code&gt;z&lt;/code&gt; 比较，综合工具会忽略，所以要保证信号只有两个状态，&lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;判断是否可综合&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;继续引用 &lt;strong&gt;董培良&lt;/strong&gt; 的文章：&lt;/p&gt;
&lt;p&gt;用一句简单的话概括：电脑永远没有你聪明 。具体来说，通常 EDA 软件对 HDL 代码的综合能力总是比人差 。对于一段代码，如果你不能想象出一个较直观的硬件实现方法，那 EDA 软件肯定也不行。比如说，加法器、多路选择器是大家都很熟悉的电路，所以类似&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的运算一定可以综合。而除法、开根、对数等等较复杂的运算，必须通过一定的算法实现，没有直观简单的实现方法，则可以判断那些计算式是不能综合的，必须按它们的算法写出更具体的代码才能实现 。此外，硬件无法支持的行为描述，当然也不能被综合（比如想在 FPGA 上实现 DDR 内存那样的双延触发逻辑，代码很容易写，但却不能实现）。&lt;/p&gt;
&lt;p&gt;不过，这样的判断标准非常主观模糊，遇到具体情况还得按设计人员自己的经验来判断 。如果要一个相对客观的标准，一般来说：在 RTL 级的描述中，所有逻辑运算和加减法运算、以及他们的有限次组合，基本上是可综合的，否则就有无法综合的可能性 。当然，这样的标准仍然有缺陷，更况且 EDA 的技术也在不断发展，过去无法综合的代码或许将来行，某些软件不支持的代码换个软件或许行 。比如固定次数的循环，含一个常数参数的乘法运算等等，有些 EDA 软件支持对它们的综合，而有些软件不行。&lt;/p&gt;
&lt;p&gt;所以，正确的判断仍然要靠实践来积累经验。当你可以较准确判断代码的可综合性的时候，你对 HDL 的掌握就算完全入门了。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.dzkf.cn/html/EDAjishu/2006/0720/9.html"&gt;浅谈VHDL/Verilog的可综合性以及对初学者的一些建议&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="Verilog"></category></entry><entry><title>学习 FPGA 入门</title><link href="http://guqian110.github.io/pages/2014/04/03/learning_fpga_getting_started.html" rel="alternate"></link><updated>2014-04-03T12:40:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-04-03:pages/2014/04/03/learning_fpga_getting_started.html</id><summary type="html">&lt;h2&gt;FPGA 是什么&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 是 PLD 家族中的一员，要说清楚什么是 FPGA，就不得不说一说 PLD 。（&lt;strong&gt;以下内容来自wikipedia&lt;/strong&gt;）&lt;/p&gt;
&lt;h3&gt;PLD &amp;amp; ASIC&lt;/h3&gt;
&lt;p&gt;早期的数字逻辑系统，是由中、小规模集成电路芯片搭建而成的。这种形式的电路在可靠性、工作速度、功耗和体积方面都难以满足大规模、高性能信息处理系统的要求 。后来，随着集成电路的发展，出现可专用集成电路 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专用集成电路&lt;/strong&gt;（Application Specific Integrated Circuits, &lt;a href="http://en.wikipedia.org/wiki/Application-specific_integrated_circuit"&gt;&lt;code&gt;ASIC&lt;/code&gt;&lt;/a&gt;）是指依产品需求不同而非通用目的，而自定义的特殊规格集成电路 。ASIC 可以将整个系统集成到一个芯片上。由于芯片内集成度高、连线短，所以它可以满足之前 ”搭建系统“ 难以满足的性能指标 。&lt;/p&gt;
&lt;p&gt;随着芯片尺寸的减小和设计工具的发展，这些年来 ASIC 芯片最大的集成度从 5,000 增长到了 超过100,000,000 门 。现代的 ASIC 通常都包含了微处理器、存储块（如 ROM 、RAM 、EEPROM 、Flash 等）。这种 ASIC 被称为 SoC （&lt;a href="http://en.wikipedia.org/wiki/System-on-chip"&gt;system on chip&lt;/a&gt;），ASIC 设计师采用硬件描述语言（Hardware Description Language，HDL），比如 Verilog、VHDL，描述 ASIC 的功能 。&lt;/p&gt;
&lt;p&gt;但是 ASIC 的研制周期长，现代信息处理的快速发展要求集成电路的设计、测试和生产周期尽可能的段，这就促进了可编程逻辑器件的发展 。严格地说，有些可编程器件出现的时间比 ASIC 出现的早，这里说的可编程器件主要是指 CPLD/FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可编程逻辑器件&lt;/strong&gt;（Programmable Logic Device,&lt;a href="http://en.wikipedia.org/wiki/Programmable_logic_devices"&gt;&lt;code&gt;PLD&lt;/code&gt;&lt;/a&gt;）是一种用来搭建可重配置数字电路的电子器件。和逻辑门（logic gate）不同，PLD 出厂时逻辑功能是没有被定义的，在使用之前，必须先重配置（reconfigure）。&lt;/p&gt;
&lt;h3&gt;历史&lt;/h3&gt;
&lt;h4&gt;ROM as PLD&lt;/h4&gt;
&lt;p&gt;在 PLD 器件被发明之前，就已经有人 &lt;em&gt;将 &lt;a href="http://en.wikipedia.org/wiki/Read-only_memory"&gt;ROM&lt;/a&gt; 以 PLD 的概念来运用&lt;/em&gt;，用 ROM 芯片来充当一些输入性的组合逻辑（combinatorial logic）的函数发生器。ROM 有 m 个地址线，则有 &lt;code&gt;n = 2^m&lt;/code&gt; 个输出结果，这和布尔逻辑是一一对应的，所以如果把 ROM 的地址线当作相互之间没有关系的输入，则相应的输出就可以实现不同的函数。&lt;/p&gt;
&lt;p&gt;早期的 Mask ROM 存储数据的方式是使用内部的硬件电路，所以只能在出厂时就写入数据，而且以后不能更改。这就导致了一系列缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因为消费者必须联系制造商才能生产出自定义的芯片，所以只有买大量的 ROM 芯片时才经济划算 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为同样的原因，从设计到最终生产出产品，中间耗费的时间很长 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mask ROM 在研发中基本上不能使用，因为设计师在改进设计时需要经常改动 ROM 里面的值 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个设备中含有故障的 Mask ROM，那么修复这个设备的唯一方法就是召回设备并且更换其中的每一个 Mask ROM 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;PROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_read-only_memory"&gt;PROM&lt;/a&gt;（Programmable Read Only Memory）是周文俊于 1956 年发明的。他在纽约 Garden City 的 American Bosch Arma Corporation 工作，当时，美国空军为了提升空军用计算机以及Atlas E/F波段导弹的灵活性和保安性而提出要求，这项技术就是为了满足这一要求而产生的 。&lt;/p&gt;
&lt;p&gt;PROM 是通过熔丝/反熔丝（fuse/antifuse）实现对每个 bit 的设置 。通过使用高电压脉冲改变内部的物理结构，这种方法通常是不可逆的，所以它只允许用户更改一次配置 。PROM 解决了上面提到的问题 1 和问题 2 ，因为公司可以买一大批没有配置过的 PROM，设计人员可以根据自己的需要随意配置 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EPROM"&gt;EPROM&lt;/a&gt;（Erasable Programmable Read Only Memory）是 intel 公司的 Dov Frohman 于 1971 年发明的 。与 PROM 不同的是，EPROM 可利用高电压将资料编程写入，通过紫外线照射的方式不断的重置为未配置状态。因此，在封装外壳上会预留一个石英玻璃所制的透明窗以便进行紫外线曝光。写入程序后通常会用贴纸遮盖透明窗，以防日久不慎曝光过量影响资料。&lt;/p&gt;
&lt;p&gt;因为EPROM 可以重复配置，所以它解决了上面的第 3 个问题 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EEPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EEPROM"&gt;EEPROM&lt;/a&gt;（Electrically Erasable Programmable Read-Only Memory）于 1983 年被发明出来。相比EPROM，EEPROM不需要用紫外线照射，也不需取下，就可以用特定的电压，来抹除芯片上的信息，以便写入新的数据 。&lt;/p&gt;
&lt;p&gt;如果设备可以从外部接收数据（比如 PC 通过串口线），就可以在线配置 EEPROM，这样它解决了问题 4 。&lt;/p&gt;
&lt;p&gt;虽然解决了上面的 4 个问题，但是把 ROM 当作 PLD 器件使用，还是有很多弊端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;与专用逻辑电路相比，ROM 的速度很慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当输入不同步时（异步状态），ROM 的输出有毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更加耗电&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与可编程逻辑相比，价格更贵，尤其是高速应用中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而且，大部分 ROM 没有输出寄存器，所以它不能直接应用在时序电路中，所以在状态机的设计中，通常还需要一个外部的 TTL 寄存器 。对电路设计的业余爱好者来说，有时也仍然用“2716”之类的普遍型EPROM芯片来充当PLD，这种用法有时也称为“穷人的PAL”。（PAL也是PLD的一种，以下将再进一步说明）&lt;/p&gt;
&lt;p&gt;于是，就出现了 PLD 器件。&lt;/p&gt;
&lt;h4&gt;早期可编程逻辑&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1969 年，Motorola 生产出 XC157，它是一个有 12 个逻辑门和 30 个独立输入/输出管脚的可编程逻辑正列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（PLA）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1971 年，通用电器公司（GE）在新的 PROM 技术的基础上发明了一种可编程逻辑器件。这个实验性质的设备通过使用多层逻辑来提高 IBM 的 ROAM 性能 。GE 的这个设备是最早的 PLD 设备，比 Altera 的 EPLD 早了十几年 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1974 年，GE 和 Monolithic Memories 达成协议，开发一种可编程逻辑器件。这个设备被称为 ”Programmable Associative Logic Array“ 或者是 PALA 。最终于 1976 年完成 MMI 5760 ，它可以实现超过 100 门的时序电路。GE 的开发环境支持这一器件，它可以直接将布尔表达式转化为配置器件的代码，然而最终这个器件却没有上市。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;PLA&lt;/h4&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（&lt;a href="http://en.wikipedia.org/wiki/Programmable_Logic_Array"&gt;PLA&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;PLA 具有一组可编程的 AND 阵列，AND 阵列之后连接一组可编程的 OR 阵列 ，这样就可以只在合乎设定条件时才允许产生逻辑信号输出 。&lt;/p&gt;
&lt;p&gt;虽然名字中含有可编程 3 个字，但是并不是所有的 PLA 都可以现场编程，事实上许多都属遮罩性的可编程化，性质与ROM相同，必须在芯片制造厂内就执行与完成程序化设定，尤其是内嵌于电路较复杂的芯片（例如：微处理器）的PLA多属此种程序化方式。&lt;/p&gt;
&lt;h4&gt;PAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_Array_Logic"&gt;PAL&lt;/a&gt;（Programmable Array Logic）是 Monolithic Memories 公司在 1978 年 3 月提出的，在数字电路中用来搭建逻辑功能的可编程器件的总称 。PAL 内部含有固定的或门阵列，可编程的与门阵列，从而实现所要求的逻辑函数。&lt;/p&gt;
&lt;p&gt;PAL 内部有个 PROM 的核，外部附加的输出逻辑电路，这样就可以实现所需要的逻辑功能 。因为 PAL 是基于 PROM 的，所以要使用特殊的设备，PAL 才具有可编程性，而且是 ”一次编程“ 。&lt;/p&gt;
&lt;h4&gt;GAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Generic_array_logic"&gt;GAL&lt;/a&gt;（Generic array logic）是 PAL 的发展，是 Lattice Semiconductor 于 1985 年发明 。这个设备具有和 PAL 同样的功能，但是可以重配置多次，所以 GAL 在设计中很有用，一旦有错误，只需要擦除后重新配置即可 。&lt;/p&gt;
&lt;p&gt;后来，International CMOS Technology (ICT) 公司发明了 类似的设备，称为 PEEL（programmable electrically erasable logic）。&lt;/p&gt;
&lt;h4&gt;CPLD&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Complex_programmable_logic_device"&gt;CPLD&lt;/a&gt;（Complex programmable logic device）适合用来实现各种运算和组合逻辑（combinational logic）。PAL、GAL仅适合用在约数百个逻辑门所构成的小型电路，若要实现更大的电路则适合用 CPLD，一颗CPLD内等于包含了数颗的PAL，各PAL（逻辑区块）间的互接连线也可以进行程序性的规划、烧录，CPLD运用这种多合一（All-In-One）的整合作法，使其一颗就能实现数千个逻辑门，甚至数十万个逻辑门才能构成的电路。&lt;/p&gt;
&lt;p&gt;CPLD 与 PAL 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非易失性配置存储器。与 FPGA 不同，CPLD v不需要外部的 ROM，只要系统上电，就可以正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于许多旧的 CPLD 来说，布线约束要求大部分逻辑块要和输入输出相连接，以减少内部状态记录，对于新的 CPLD 系列来说，已经不需要这样了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPLD 与 FPGA 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以利用大量的逻辑资源，CPLD 等价有有数百万的逻辑门资源可以用来实现比较复杂的设计，而 PAL 最多等价有几千个逻辑门，FPGA 有几万到几百万的逻辑门。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供一些更加灵活的资源，比如宏模块之间复杂的反馈连接和整数运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大的 CPLD 和小 FPGA 之间最显著的差别就是 CPLD 含有片内非易失性存储器 。因为非易失性存储器的特点，CPLD 在数字电路设计中被当作 ”boot loader“ 来使用，之后它再把系统的控制权转交给没有这种特性的设备，最好的例子就是使一块 CPLD 从非易失性存储器中装载配置 FPGA 所需要的数据 。&lt;/p&gt;
&lt;h4&gt;FPGA&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array"&gt;FPGA&lt;/a&gt;（Field Programmable Gate Array，FPGA）是在 PAL、GAL、CPLD 等可编程逻辑器件的基础上进一步发展的产物。它是作为专用集成电路领域中的一种半定制电路而出现的，既解决了全定制电路的不足，又克服了原有可编程逻辑器件门电路数有限的缺点。&lt;/p&gt;
&lt;p&gt;当 PAL 忙于进展成 GAL、CPLD 时，另一种 “可编程化” 的流派也逐渐成形，此称之为现场可编程闸阵列（Field Programmable Gate Array，FPGA）。FPGA是以阵列（Gate Array）技术为基础所发展成的一种PLD 。所谓 ”Field Programmable“ 就是说芯片是出厂以后由客户或者设计师配置而工作的 。&lt;/p&gt;
&lt;p&gt;1980 年代后期，Naval Surface Warfare Department 在 Steve Casselman 的提议下成立了实验项目，目的是为了研制一台由 600,000 个逻辑门组成的计算机。Casselman 最后成功了并且在 1992 年获得了专利 。&lt;/p&gt;
&lt;p&gt;Xilinx 公司的共同创世人 &lt;a href="http://en.wikipedia.org/wiki/Ross_Freeman"&gt;Ross Freeman&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Bernard_Vonderschmitt"&gt;Bernard Vonderschmitt&lt;/a&gt; 在 1985 年发明出第一款商业 FPGA —— XC2064 。XC2064 芯片有可以编程的逻辑门和可以编程的内部连接线，这开辟了一项新的技术和市场 。XC2064 有 64 个可配置逻辑块（configurable logic blocks，CLBs），和 3 输入查找表（lookup tables，LUTs）。&lt;/p&gt;
&lt;p&gt;从 1985 开始到 90 年代中期，Xilinx 一直处于高速发展阶段，之后竞争对手出现了，截至 1993 年，Actel 占据了 18% 的市场 。&lt;/p&gt;
&lt;p&gt;90 年代是 FPGA 爆炸式发展的年代，这一期间出现了大量高端技术和产品。在 90 年代初期，FPGA 主要应用于通信领域，在 90 年代后期，FPGA 已经广泛应用于消费品、汽车和工业应用 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;为什么选择 FPGA&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;FPGA vs ASIC&lt;/h3&gt;
&lt;p&gt;ASIC 的优点：&lt;/p&gt;
&lt;p&gt;ASIC 在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低 。&lt;/p&gt;
&lt;p&gt;ASIC 的缺点：&lt;/p&gt;
&lt;p&gt;设计周期最长，设计成本贵，设计费用最高，适合于批量很大或者对产品成本不计较的场合。&lt;/p&gt;
&lt;p&gt;至于 FPGA 的优点和缺点完全就是 ASIC 的取反 。FPGA 一般来说比专用集成电路（ASIC）的速度要慢，无法完成更复杂的设计，并且会消耗更多的电能。但是，FPGA 具有很多优点，比如可以快速成品，而且其内部逻辑可以被设计者反复修改，从而改正程序中的错误，此外，使用 FPGA 进行除错的成本较低 。在一些技术更新比较快的行业，FPGA几乎是电子系统中的必要部件，因为在大批量供货前，必须迅速抢占市场，这时FPGA方便灵活的优势就显得很重要。这也是 FPGA 能够发展起来的原因，市场是不会允许一个毫无优势的技术发展到今天这种地步的 。&lt;/p&gt;
&lt;p&gt;个人认为两者不是对立的，由于各自的特点，它们有各自适用的环境，不能一棒子打死，否定其中一个 。事实上更多的情况是：设计的开发是在普通的FPGA上完成的，然后将设计转移到一个类似于专用集成电路的芯片上 。&lt;/p&gt;
&lt;h3&gt;FPGA vs CPLD&lt;/h3&gt;
&lt;p&gt;为了达到上述目的，还有一种方法是使用 CPLD 。
CPLD和FPGA都包括了一些相对大数量的可以编辑逻辑单元。CPLD逻辑门的密度在几千到几万个逻辑单元之间，而FPGA通常是在几万到几百万。&lt;/p&gt;
&lt;p&gt;FPGA 与 CLPD 最大的区别就是：FPGA 是基于查找表（look up table，LUT），而 CPLD 是基于海门架构（sea-of-gates），也就是它们的系统结构 。CPLD 的结构具有一定的局限性 。这个结构由一个或者多个可编辑的结果之和的逻辑组列和一些相对少量的锁定的寄存器组成 。这样的结果是缺乏编辑灵活性，但是它的优点是，其延迟时间易于预计，逻辑单元对连接单元比率较高 。而FPGA具有的连接单元数量很大，这样虽然让它可以更加灵活的编辑，但是结构却复杂的多 。&lt;/p&gt;
&lt;p&gt;CPLD 和 FPGA 另外一个区别是大多数的 FPGA 含有高层次的内置模块（比如加法器和乘法器）和内置的存储器 。一个由此带来的重要区别是，很多新的 FPGA 支持完全的或者部分的系统内重新配置 。允许他们的设计随着系统升级或者动态重新配置而改变 。一些FPGA可以让设备的一部分重新编辑，而其他部分继续正常运行 。&lt;/p&gt;
&lt;p&gt;CPLD 与 FPGA 之间结构、原理上的差别导致两者应用上的差别 。考虑成本、性能要求等因素，应该根据实际情况选择 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Xilinx &amp;amp; Altera&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 的制造商主要是 Xilinx 和 Altera 两家，他们合起来市场占有率达到了 80% 之多 。两家是 FPGA 技术的领导者也是长期竞争对手 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Xilinx"&gt;Xilinx&lt;/a&gt; 于 1984 年创建于美国加利福尼亚州的硅谷，总部位于硅谷核心的圣何塞。它是一家主要提供 FPGA 的科技公司 。并且就是它的创始人是发明了 FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Altera"&gt;Altera&lt;/a&gt; 是一家位于美国硅谷的可编程逻辑器件和 CPLD 的制造商 。该公司于1984年推出了其首款可编程逻辑设备。&lt;/p&gt;
&lt;p&gt;两家一直是互为竞争对手，一般来说，大学里面都 Altera 的器件和 VHDL 上课，所以在学校里面用 Xilinx 的人比较少 。&lt;/p&gt;
&lt;p&gt;因为原理是一样的，所以只要学会一种，另一种就很容易上手。学校实验室里面用的是 Xilinx 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Xilinx FPGA Architecture（架构）&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 需要反复烧写，所以不能像 ASIC 一样通过固定的与非门来完成，只能采用一种易于反复配置的结构，查找表就可以很好的满足这一要求。目前主流 FPGA 都是采用了基于 SRAM 工艺的查找表结构（军品和宇航级 FPGA 采用 Flash或者熔丝/反熔丝工艺），通过烧写文件改变查找表内容的方法来实现对 FPGA 的重复配置。&lt;/p&gt;
&lt;p&gt;查找表（look-up table，LUT）本质上就是一个 RAM 。当用户通过原理图或 HDL 语言描述了一个电路以后，FPGA 开发软件会计算逻辑电路的所有可能结果，并把真值表事先写入 RAM，这样，每输入一个信号进行逻辑运算就相当于输入一个地址进行查找，这样 LUT 就具有了和逻辑电路相同的功能 。实际上，LUT 具有更快的执行速度和更大的规模 。&lt;/p&gt;
&lt;p&gt;上电时，FPGA将外部存储器中的数据读入片内RAM，完成配置后，进入工作状态；掉电后FPGA恢复为白片，内部逻辑消失。这样FPGA不仅能够反复使用，还无须专门的FPGA编程器，只需通用的EPROM、PROM编程器即可。&lt;/p&gt;
&lt;p&gt;目前，Xilinx FPGA 仍然是基于查找表技术，但是其概念已经远远超出查找表技术的限制，并且整合了常用功能的硬核模块（如块 RAM，时钟管理和 DSP）。Xilinx FPGA 内部大致可以分为 6 部分：&lt;/p&gt;
&lt;h3&gt;IOB&lt;/h3&gt;
&lt;p&gt;可编程输入/输出单元简称 I/O 单元，是芯片与外界电路的接口部分，完成不同电气特性下输入/输出信号的驱动和匹配 。&lt;/p&gt;
&lt;h3&gt;CLB&lt;/h3&gt;
&lt;p&gt;CLB（Configurable Logic Block）是 FPGA 内的基本逻辑单元，Xilinx FPGA 的 CLB 由多个相同的 Slice 和附加逻辑组成 。&lt;/p&gt;
&lt;h3&gt;DCM&lt;/h3&gt;
&lt;p&gt;业内大多数 FPGA 都提供数字时钟管理（Digital Clock Manager）。Xilinx FPGA 提供 DCM 和 PLL 。&lt;/p&gt;
&lt;h3&gt;BRAM&lt;/h3&gt;
&lt;p&gt;大多数 FPGA 都具有内嵌的块 RAM，这大大扩展了 FPGA 的应用范围和灵活度 。块 RAM 可以被配置为单口 RAM、双端口 RAM、内容地址存储器（CAM）和 FIFO 等常用存储结构 。&lt;/p&gt;
&lt;h3&gt;Routing Resource&lt;/h3&gt;
&lt;p&gt;布线资源连通 FPGA 内部的所有单元，而连线的长度和工艺决定着信号在连线上的驱动能力和传输速度 。Xilinx FPGA 的布线资源可以分为 4 类：全局布线资源、长线资源、短线资源、分布式资源 。&lt;/p&gt;
&lt;h3&gt;Embedded Module&lt;/h3&gt;
&lt;p&gt;内嵌功能模块只要是指 DLL、PLL、DSP 和 CPU 等 &lt;strong&gt;软核&lt;/strong&gt;，还有底层的 &lt;strong&gt;硬核&lt;/strong&gt; 资源，比如内嵌的 Power PC、ARM9、DSP芯片等 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Xilinx 主流 FPGA&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Xilinx 主流的 FPGA 主要有A系列、K系列、V系列、Spartan系列，如今还有最新的 Zynq 系列，官网上有详细介绍 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;开发流程&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;FPGA 的开发流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="design flow" src="/images/learning-fpga-getting-started/design-flow.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;整个开发过程就是使用开发工具 ISE Design Suite，按照流程图进行 。图示是标准流程，但是实际上并不是严格按照每一个步骤进行 。&lt;/p&gt;
&lt;p&gt;一般简化过的流程是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设计可综合的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合 Systhesis&lt;/p&gt;
&lt;p&gt;前两步主要是确保写的代码是开发工具可以转化为实际电路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合后仿真&lt;/p&gt;
&lt;p&gt;这一步保证模块的逻辑功能是正确的，即检验模块的结果是否和预期一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序约束&lt;/p&gt;
&lt;p&gt;为设计添加时序约束和管脚约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现 Implement&lt;/p&gt;
&lt;p&gt;按照约束条件将综合结果映射到实际器件中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序分析&lt;/p&gt;
&lt;p&gt;实际上，一次就能达到时序要求且布线成功的情况并不多，尤其是对于高速设计，所以需要根据上一步的时序结果对设计进行修改，以满足时序要求，类似于写软件的 Debug 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载，在线调试&lt;/p&gt;
&lt;p&gt;将设计下载到芯片中调试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_logic_devices"&gt;PLD wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array"&gt;FPGA wikipedia&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category></entry><entry><title>C/C++ 内置数据类型</title><link href="http://guqian110.github.io/pages/2014/03/31/built_in_types.html" rel="alternate"></link><updated>2014-03-31T13:37:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-03-31:pages/2014/03/31/built_in_types.html</id><summary type="html">&lt;p&gt;类型是程序设计的基础。一些程序设计语言，比如 Smalltalk 和 Python，在运行的时候才检查预计中的对象的类型，想反，C++ 是静态类型（statically typed）语言，在编译时执行类型检查。导致的结果是：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;变量和函数在使用前必须先声明&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;每种类型都定义了其存储空间要求和可以在该类型的所有对象上执行的操作。C++ 是 在 C 的基础上扩充得到的，为了和 C 兼容， C++ 在必要时必须能够直接处理硬件，所以 C++ 提供的一组基本内置类型，如int、char等，这些类型与它们在机器硬件上的标示方式紧密相关。（所以，C++ 可以称为 “具有高级语言库的低级语言”）&lt;/p&gt;
&lt;p&gt;本文只限于总结 C++ 的内置类型（Built-in Types），不讨论自定义类型 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;基本内置类型&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;算术类型&lt;/h3&gt;
&lt;p&gt;C++ 语言自身定义了一组基本类型来表示不同的数据，如整数、浮点数、字母、bool 类型等，这些类型统称为 &lt;em&gt;算术类型（Arithmetic type）&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算术类型的存储空间依机器而定，即用多少二进制位 bit 来表示一个数 。C++ 标准规定了每个算术类型的最小存储空间，但它并不阻止编译器使用更大的存储空间 。事实上，对于 &lt;code&gt;int&lt;/code&gt; 类型，几乎所有的编译器使用的存储空间都比所要求的大 。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;sizeof()&lt;/code&gt; 操作符可以查询对象或类型的大小（以字节为单位），包含头文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c"&gt;#include &amp;lt;limits&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就可以使用 STL 库中的 &lt;code&gt;numeric_limits&amp;lt;T&amp;gt;::max&lt;/code&gt; 和 &lt;code&gt;numeric_limits&amp;lt;T&amp;gt;::min&lt;/code&gt; 查询各个内置内类类型的最大值和最小值。&lt;/p&gt;
&lt;p&gt;下面是 Ubuntu amd64 版本上的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="size" src="/images/built-in-types/size.png" /&gt;&lt;/p&gt;
&lt;p&gt;算术类型可以分为两类：表示整数的 &lt;em&gt;整型&lt;/em&gt; 和表示浮点数的 &lt;em&gt;浮点型&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Integral Types&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示整数、字符、布尔值的算术类型合称为 整型（integral types）。&lt;/p&gt;
&lt;p&gt;整数的基本表示类型是 &lt;code&gt;int&lt;/code&gt; 。int 类型前面可以加两类修饰说明，表示数据位数长短的 &lt;code&gt;short&lt;/code&gt; 和 &lt;code&gt;long&lt;/code&gt; ；表示有无符号的 &lt;code&gt;signed&lt;/code&gt; 和 &lt;code&gt;unsigned&lt;/code&gt; 。组合出来的结果就有 4 种：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="kt"&gt;signed&lt;/span&gt; &lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="kt"&gt;signed&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每一种的数据长短和可以表示的范围都不相同。&lt;/p&gt;
&lt;p&gt;字符类型有两种：&lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;wchar_t&lt;/code&gt; 。char 用来表示 &lt;em&gt;基本字符集&lt;/em&gt; 中的字符，wchar_t 用于 &lt;em&gt;扩展字符集&lt;/em&gt; ，比如汉字和日语 。修饰 int 类型有无符号的 signed 和 unsigned 也可以修饰 char 类型 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;C++ Primer&lt;/a&gt; (chapter 2) 中写到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unlike the other integral types, there are three distinct types for char: plain char, signed char, and unsigned char. Although there are three distinct types, there are only two ways a char can be represented. The char type is respresented using either the signed char or unsigned char version. Which representation is used for char varies by compiler.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么会有这么奇怪的事呢？上网搜索了一下，按照自己的理解总结了一下：&lt;/p&gt;
&lt;p&gt;signed/unsigned 可以描述的类型有 int 和 char 两种，在 C 的标准里面规定：对于 int 类型，如果没有在类型前显式地声明，默认 int 是 signed 类型，而对于 char 类型，则是 &lt;em&gt;Implementation Defined&lt;/em&gt; 。也就是说由编译器在编译的时候决定具体使用哪一种 。而为什么要作出这么奇怪的规定呢？是因为 char 类型本来就是用来表示字符而非数字的， ASCII 码字只使用 7 bit，所以使用 signed/unsigned 对其没有影响，但是如果使用 char 类型来表示一个 8 bit 的数字（有时候空间不够用时不得不这样做，比如嵌入式系统中），为了可移植性，必须写明 signed/unsigned 。所以，如果用来表示字符，则直接使用 char 就行，如果用来表示整数，则声明是signed/unsigned 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.51cto.com/art/200912/166574.htm"&gt;Linux C编程一站式学习：整型&lt;/a&gt; 中进一步解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器可以定义char型是无符号的，也可以定义char型是有符号的，在该编译器所对应的体系结构上哪种实现效率高就可以采用哪种，x86平台的gcc定义char型是有符号的。这也是C标准的Rationale之一： &lt;em&gt;优先考虑效率，而可移植性尚在其次。&lt;/em&gt; 这就要求程序员非常清楚这些规则，如果你要写可移植的代码，就必须清楚哪些写法是不可移植的，应该避免使用。另一方面，写不可移植的代码有时候也是必要的，比如Linux内核代码使用了很多只有gcc支持的语法特性以得到最佳的执行效率，在写这些代码的时候就没打算用别的编译器编译，也就没考虑可移植性的问题。如果要写不可移植的代码，你也必须清楚代码中的哪些部分是不可移植的，以及为什么要这样写。如果不是为了效率，一般来说就没有理由故意编写不可移植的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网上有&lt;a href="http://www.cppblog.com/wuzimian/archive/2012/05/28/176427.aspx"&gt;博客&lt;/a&gt;说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;VC 编译器、x86 上的 GCC 都把 char 定义为 signed char，而 arm-linux-gcc 却把 char 定义为 unsigned char 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是，编写一个测试小程序就可以知道我们使用的编译器是如何处理的。&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ch1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch1 = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ch1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="char" src="/images/built-in-types/char.png" /&gt;&lt;/p&gt;
&lt;p&gt;结果说明，gcc 把 char 默认为 signed char 处理。&lt;/p&gt;
&lt;p&gt;布尔类型表示 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。可以将任何算术类型的值赋给 &lt;code&gt;bool&lt;/code&gt; 对象，&lt;code&gt;0&lt;/code&gt; 表示 &lt;code&gt;false&lt;/code&gt; ，任何非 &lt;code&gt;0&lt;/code&gt; 值都表示 &lt;code&gt;true&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Floating-Point Types&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类型 &lt;code&gt;float&lt;/code&gt; 表示 单精度浮点数&lt;/p&gt;
&lt;p&gt;类型 &lt;code&gt;double&lt;/code&gt; 表示 双精度浮点数&lt;/p&gt;
&lt;p&gt;类型 &lt;code&gt;long double&lt;/code&gt; 表示 扩展精度浮点数&lt;/p&gt;
&lt;p&gt;从前面的运行结果可以看出在我的电脑上 float 使用 1 个字（32 bit） 表示，double 使用 2 个字（64 bit） 表示，long double 使用 4 个字（128 bit） 表示 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;C++ Primer&lt;/a&gt; (chapter 2)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The float type is usually not precise enough for real programsfloat is guaranteed to offer only 6 significant digits. The double type guarantees at least 10 significant digits, which is sufficient for most calculations.&lt;/p&gt;
&lt;p&gt;Determining which floating-point type to use is easier: It is almost always right to use double. The loss of precision implicit in float is significant, whereas the cost of double precision calculations versus single precision is negligible. In fact, on some machines, double precision is faster than single. The precision offered by long double usually is unnecessary and often entails considerable extra run-time cost.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;void&lt;/h3&gt;
&lt;p&gt;void 类型没有对应的值，仅用在有限的一些情况下，通常用作无返回值函数的返回类型。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;初始化 Initialize&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;初始化 &amp;amp; 赋值&lt;/h3&gt;
&lt;p&gt;首先是初始化的必要性：&lt;/p&gt;
&lt;p&gt;在 C++ 中，初始化是一个非常重要的概念，给变量一个初始值几乎总是正确的，但不要求必须这么做。定义变量时，应该给变量赋初始值，除非确定将变量用于其他意图之前会覆盖这个初值。如果不能保证读取变量前重置变量，就应该初始化变量。变量没有初始化是很常见的导致程序崩溃/结果错误的原因，而且有时候很难像 Debug 一样找到这个错误（bug 导致程序一定不对，但是没有初始化的变量的结果是随机的）。所以，良好的习惯是对每个变量都进行初始化 。&lt;/p&gt;
&lt;p&gt;其次是初始化和赋值的区别：&lt;/p&gt;
&lt;p&gt;初始化 &lt;code&gt;Initialization&lt;/code&gt;：创建变量并且给它赋初始值&lt;/p&gt;
&lt;p&gt;赋值 &lt;code&gt;Assigment&lt;/code&gt;：擦除变量的当前值并用新值代替&lt;/p&gt;
&lt;p&gt;C++ 提供两种初始化变量的方法：复制初始化（&lt;code&gt;copy-initialization&lt;/code&gt;）和直接初始化（&lt;code&gt;direct-initialization&lt;/code&gt;）。复制初始化使用 &lt;code&gt;=&lt;/code&gt;，直接初始化使用 &lt;code&gt;()&lt;/code&gt; 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ival&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// copy-initialization&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;ival&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// direct-initialization&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用 &lt;code&gt;=&lt;/code&gt; 很容易让人把初始化和赋值混淆在一起，但是在 C++ 中这是两种不同的操作，当涉及到类对象时，两种不同的初始化方式的区别是很微妙的。目前先不考虑这点，只需要知道直接初始化语法更灵活而且效率高。&lt;/p&gt;
&lt;h3&gt;内置类型初始化&lt;/h3&gt;
&lt;p&gt;当我们定义一个变量却没有初始化时，系统 &lt;em&gt;有可能&lt;/em&gt; 会为我们进行隐式的初始化。至于系统是否帮我们隐式初始化变量，以及为变量赋予一个怎样的初始值，这要取决于 &lt;em&gt;该变量的类型&lt;/em&gt; 以及我们 &lt;em&gt;在何处定义的该变量&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;这里我们只考虑内置类型的初始化：&lt;/p&gt;
&lt;p&gt;内置类型的变量是否自动初始化取决于变量定义的位置。在函数体外（全局范围）定义的变量都初始化为 0，函数体内定义的变量不进行自动初始化 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;算术类型转换&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;隐式类型转换&lt;/h3&gt;
&lt;p&gt;当两个操作数类型不同时，C++ 并不是直接把两个数加在一起，而是提供了一组转换规则，以便在执行算术操作之前，将两个数转换为同一数据类型。这些转换规则由编译器自动执行，不需要程序眼介入，有时甚至不需要程序员了解。因此，它们被称为 隐式类型转换 (&lt;code&gt;implicit type conversion&lt;/code&gt;) 。&lt;/p&gt;
&lt;p&gt;在以下情况会发生隐式类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;混合类型表达式，操作数被转换为相同类型&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;dval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;ival&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;dval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// ival converted to double&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;用作条件表达式被转化为 bool 型&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// ival converted to bool&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;// cin converted to bool&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;用表达式初始化（赋值）某一变量，表达式被转化为该变量类型&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ival&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.14&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 3.14 converted to int&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;ip&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// the int 0 converted to a null pointer of type int *&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外，函数调用时也可能发生隐式类型转化。&lt;/p&gt;
&lt;h3&gt;算术类型转换&lt;/h3&gt;
&lt;p&gt;C++ 语言为内置类型提供了一组转化规则，其中最常用的就是算术转化（arithmetic conversion）。算术转化规则定义了一个 &lt;em&gt;类型转换层次&lt;/em&gt;，该层次规定了操作数应该按照什么次序转换为表达式中最宽的数据类型。&lt;/p&gt;
&lt;p&gt;有两条通用规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为了保留精度，如果有必要，数据总是被提升为较宽的类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有含有小于整形的有序类型的算术表达式在计算之前其类型都会被转换成整型（整型提升 integral promotion）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于有符号数和无符号数，原则是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不同级数据转换，若较宽的类型可以表示所有较窄的类型的数，则直接将较窄的类型提升为较宽的类型，否则，把两个数都转换为无符号的较宽的类型 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同级数据转换，unsigned int 和 int ，signed 类型会转换为 unsigned 类型 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;unsigned 操作数的转换依赖于机器中整型的相对大小，所以，这类转换依赖于机器。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;short 类型 与 int 类型 。在我的机器上，short 类型所占用的宽度为半字（2 Byte），int 类型占用的宽度为 1个字（4 Byte）。所有的 unsigned short 的值都包含在 int 之中，所以，unsigned short 转换为 int 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;signed&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;unsigned int b&amp;#39; = &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;c = &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4294967276&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为 &lt;code&gt;b = -2&lt;/code&gt; 被转化为一个很大的正数 &lt;code&gt;b' = 4294967276&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;references&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;c++ Primer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cppblog.com/wuzimian/archive/2012/05/28/176427.aspx"&gt;C++之char , signed char , unsigned char，以及Integral Promotion&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.51cto.com/art/200912/166574.htm"&gt;Linux C编程一站式学习：整型&lt;/a&gt;&lt;/p&gt;</summary><category term="C"></category><category term="C++"></category></entry><entry><title>Ubuntu 下安装 ISE &amp; ModelSim</title><link href="http://guqian110.github.io/pages/2014/03/27/install_ise_modelsim_on_ubuntu.html" rel="alternate"></link><updated>2014-03-27T20:52:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-03-27:pages/2014/03/27/install_ise_modelsim_on_ubuntu.html</id><summary type="html">&lt;p&gt;从 Windows 平台转移到 Linux，于是把 FPGA 的开发平台也搬过来。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;软件版本：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu 13.10 Desktop amd64 &lt;/p&gt;
&lt;p&gt;ISE 14.7 for Linux&lt;/p&gt;
&lt;p&gt;ModelSim 6.5b for Linux&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;下载&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE Design Suit for Linux&lt;/h3&gt;
&lt;p&gt;Xilinx 官方网站上有&lt;a href="https://secure.xilinx.com/webreg/register.do?group=dlc&amp;amp;htmlfile=&amp;amp;emailFile=&amp;amp;cancellink=&amp;amp;eFrom=&amp;amp;eSubject=&amp;amp;version=14.7&amp;amp;akdm=1&amp;amp;filename=Xilinx_ISE_DS_Lin_14.7_1015_1.tar"&gt;下载链接&lt;/a&gt;，但是在校园网内下载速度实在是蛋疼，还好有校内 bt 资源。&lt;/p&gt;
&lt;p&gt;我下载下来的 ISE 版本为 &lt;strong&gt;14.7&lt;/strong&gt;，tar 包大小为 6.5 G 。&lt;/p&gt;
&lt;h3&gt;ModelSim for Linux&lt;/h3&gt;
&lt;p&gt;网上的教程（2011 年前）都说是 &lt;a href="http://www.mentor.com/products/fpga/model"&gt;ModelSim 官方网站&lt;/a&gt; 上提供 ftp 下载链接，但是好像现在官网上不再提供下载链接了，我只找到 ModelSim PE Student Edition，而且还是 Windows 平台的...&lt;/p&gt;
&lt;p&gt;花费了一下午的时间，不停地在各个论坛注册下载附件，终于把 ModelSim_6.5b for Linux 下载下来了,结果安装时提示找不到 &lt;code&gt;libxp.so.6&lt;/code&gt; 库，于是 &lt;code&gt;apt-get&lt;/code&gt; 到一些 &lt;code&gt;libxp&lt;/code&gt; 的库，安装后仍然提示找不到，无奈放弃了，准备老老实实用 &lt;code&gt;ism&lt;/code&gt; 了（以后有时间了再慢慢折腾 T_T）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE DS 14.7&lt;/h3&gt;
&lt;p&gt;首先解压&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xvf&lt;/span&gt; &lt;span class="n"&gt;Xilinx_ISE_DS_Lin_14&lt;/span&gt;&lt;span class="mf"&gt;.7&lt;/span&gt;&lt;span class="n"&gt;_1015_1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着进入解压出来的目录并给安装文件赋予执行的权限&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;Xilinx_ISE_DS_Lin_14&lt;/span&gt;&lt;span class="mf"&gt;.7&lt;/span&gt;&lt;span class="n"&gt;_1015_1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;chmod&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;xsetup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后执行 xsetup&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;xsetup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后熟悉的图形界面就出来，和 Windows 下一样，同意安装许可协议，不停地下一步就可以安装成功。&lt;/p&gt;
&lt;p&gt;安装完成以后，运行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;14.7&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE_DS&lt;/span&gt;
    &lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="n"&gt;settings64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时，已经可以从终端运行 ISE 了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;nohup&lt;/span&gt; &lt;span class="n"&gt;ise&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;熟悉的图形界面出来了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ise" src="/images/install-ise-modelsim/ise_start.png" /&gt;&lt;/p&gt;
&lt;p&gt;P.S.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择安装版本时，选择 &lt;code&gt;System Edition&lt;/code&gt;，因为这个版本功能最全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择安装组件时，不要勾选 &lt;code&gt;Install Cable Drivers&lt;/code&gt;，我们自己编译安装另外一个驱动（因为此驱动只能在 Linux 内核 &amp;lt; 2.6的版本中使用，所以即使勾选了最后安装完成时会提示 &lt;em&gt;Driver installation failed&lt;/em&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Crack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又到了该和谐的地方了 =.=&lt;/p&gt;
&lt;p&gt;第一次打开 ISE 时，会自动弹出 License Management Tools 提示我们添加 License 。网上有一大堆破解包，我使用以前在 Windows 中生成的 Lincese，直接就可以使用了～&lt;/p&gt;
&lt;p&gt;再次声明：仅供技术交流，请支持正版软件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;installing Cable Drivers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如前面所说，因为 ISE 自带的驱动程序依赖于一个叫 windrvr 的文件。 而该文件目前只有 Linux 内核 2.4 的二进制版本，因此遇到高于 2.4 内核的 Linux发布版，如我使用的Ubuntu 13.10（Linux version 3.11.0-12-generic ） 就不工作了。&lt;/p&gt;
&lt;p&gt;好在一个叫 Michael Gernoth 的德国人，大公无私地写了一个 windrvr 的替代版本，并且开放源码，这样，无论碰到什么版本的内核，现场编译一个驱动并安装， 就能解决 Linux 内核版本匹配的问题。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://rmdir.de/~michael/xilinx/"&gt;XILINX JTAG tools on Linux without proprietary kernel modules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以按照说明&lt;/p&gt;
&lt;p&gt;首先安装 usb 驱动开发包，在 64 位系统下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;libusb&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="n"&gt;libc6&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt; &lt;span class="n"&gt;fxload&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着下载驱动程序的源代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;
    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//git.zerfleddert.de/usb-driver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后编译驱动程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;usb&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
    &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;make&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载下来的源代码中有个脚本可以设置好一切，我们只需要运行脚本就 ok&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;setup_pcusb&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;opt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Xilinx&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;14.7&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE_DS&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ISE&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把 Xilinx 路径添加到系统 PATH 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;PATH=\$PATH:/opt/Xilinx/13.2/ISE_DS/ISE/bin/lin64/&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bashrc&lt;/span&gt;
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;export PATH&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bashrc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这时候，写个小测试的程序，&lt;code&gt;Systhesize&lt;/code&gt; -&amp;gt; &lt;code&gt;Implement&lt;/code&gt; -&amp;gt; &lt;code&gt;Generate Programming File&lt;/code&gt;，打开 &lt;code&gt;iMPACT&lt;/code&gt;, 如图所示，可以看到已经识别出 JTAG 链上的芯片&lt;/p&gt;
&lt;p&gt;&lt;img alt="jtag" src="/images/install-ise-modelsim/jtag.png" /&gt;&lt;/p&gt;
&lt;h3&gt;ModelSim&lt;/h3&gt;
&lt;p&gt;待续...&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;配置 ISE &amp;amp; ModelSim&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;ISE&lt;/h3&gt;
&lt;p&gt;其实也没有特殊配置的地方，主要是自定义代码编辑器，目前我的主要使用的是 &lt;code&gt;sublime text 2&lt;/code&gt;，正在向 &lt;code&gt;vim&lt;/code&gt; 过度ing&lt;/p&gt;
&lt;p&gt;具体步骤 Edit -&amp;gt; Preferences -&amp;gt; Editors，选择 &lt;code&gt;custom&lt;/code&gt;，在右侧的 “Command line syntax” 中写自定义编辑器的执行路径&lt;/p&gt;
&lt;p&gt;配置自定义编辑器为 vim&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;gnome&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;terminal&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;maximize&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;ModelSim&lt;/h3&gt;
&lt;p&gt;ModelSim 编译 Xilinx库，ISE 关联 ModelSim&lt;/p&gt;
&lt;p&gt;待续...&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://rmdir.de/~michael/xilinx/"&gt;XILINX JTAG tools on Linux without proprietary kernel modules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.george-smart.co.uk/wiki/Xilinx_JTAG_Linux"&gt;Xilinx JTAG Linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/yunz1994/article/details/12350071"&gt;【Linux软件安装】Ubuntu12.04: Xilinx ISE 14.6&lt;/a&gt;&lt;/p&gt;</summary><category term="FPGA"></category><category term="Linux"></category></entry><entry><title>学习 Vim 存活</title><link href="http://guqian110.github.io/pages/2014/03/25/learning_vim_survival.html" rel="alternate"></link><updated>2014-03-25T21:23:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-03-25:pages/2014/03/25/learning_vim_survival.html</id><summary type="html">&lt;p&gt;这个系列的博客是我学习 Vim 过程中的记录和总结，希望可以帮助到和我一样的菜鸟～&lt;/p&gt;
&lt;p&gt;第一篇：入门/存活 Survival&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br&gt;
&lt;nr&gt;&lt;/p&gt;
&lt;h2&gt;Vim 是什么&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;简单的说，&lt;a href="http://en.wikipedia.org/wiki/Vim_(text_editor)"&gt;Vim&lt;/a&gt; 就是广大的编辑器中的一员，但是对程序猿来说，她并不是一款简单的编辑器。她强大的编辑能力、苗条的身材（软件体积小、启动速度快）和 Linux 系统的血缘关系（几乎是 Linux 系统的标配），使其在全世界有成千上万的粉丝，以至于掌握 Vim 成为每个码农必备技能。&lt;/p&gt;
&lt;p&gt;Wikipedia 上 Vim 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vim (an acronym for Vi IMproved) is a text editor written by Bram Moolenaar and first released publicly in 1991. Based on the vi editor common to Unix-like systems, Vim is designed for use both from a command line interface and as a standalone application in a graphical user interface. Vim is free and open source software and is released under a license that includes some charityware clauses, encouraging users who enjoy the software to consider donating to children in Uganda. The license is compatible with the GNU General Public License.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;历史&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;摘抄（翻译）自 &lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;Wikipedia&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于 vi/Vim 的发展，还是从头说起：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Ed_(text_editor)"&gt;ed&lt;/a&gt;&lt;/strong&gt; 是 UNIX 界最古老最基本的编辑器，它由 &lt;a href="http://en.wikipedia.org/wiki/Ken_Thompson_(computer_programmer)"&gt;Ken Thompson&lt;/a&gt; (UNIX 之父)于 1971 年在 &lt;a href="http://en.wikipedia.org/wiki/PDP-11"&gt;PDP-11&lt;/a&gt;/20 上用汇编写成 。ed 的许多特性来自于 &lt;a href="http://en.wikipedia.org/wiki/Ken_Thompson_(computer_programmer)"&gt;Thompson&lt;/a&gt; 在加州伯克利大学上学时受到的&lt;a href="http://en.wikipedia.org/wiki/QED_(text_editor)"&gt;qed&lt;/a&gt; 编辑器的影响 。Thompson 对 qed 非常熟悉，他在 &lt;a href="http://en.wikipedia.org/wiki/Compatible_Time-Sharing_System"&gt;CTSS&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Multics"&gt;Multics&lt;/a&gt; 操作系统上重新实现了一边 qed ，并且在他的版本中，第一次实现了正则表达式（ &lt;a href="http://en.wikipedia.org/wiki/Regular_expression"&gt;regular expressions&lt;/a&gt;）。虽然正则表达式也是 ed 的一部分，但是一般认为在 qed 中正则表达式的实现更多一些 。&lt;/p&gt;
&lt;p&gt;ed 是为电传机（&lt;a href="http://en.wikipedia.org/wiki/Teletype"&gt;teletype&lt;/a&gt;）而不是终端显示器（&lt;a href="http://en.wikipedia.org/wiki/Display_terminal"&gt;display terminals&lt;/a&gt;）设计的行编辑器，它是一个行编辑器。在它的起源地 —— AT&amp;amp;T 实验室，人们似乎很满意把 ed 设置为默认的编辑器，即使它的功能很基本而且很不友好。 &lt;a href="http://en.wikipedia.org/wiki/George_Coulouris_(computer_scientist)"&gt;George Coulouris&lt;/a&gt; 回忆说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] for many years, they had no suitable terminals. They carried on with TTYs and other printing terminals for a long time, and when they did buy screens for everyone, they got Tektronix 4014s. These were large storage tube displays. You can't run a screen editor on a storage-tube display as the picture can't be updated. Thus it had to fall to someone else to pioneer screen editing for Unix, and that was us initially, and we continued to do so for many years.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Coulouris 认为 ed 的隐藏的命令只适合于 “神人”（immortals），所以在 &lt;a href="http://en.wikipedia.org/wiki/Queen_Mary,_University_of_London"&gt;Queen Mary College&lt;/a&gt; 当讲师的期间，他在 Thompson 的代码的基础上加强了 ed，并且命名为 em （the "editor for mortals"）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;em&lt;/strong&gt; 是为终端显示器设计（display terminals）的，一次只显示一行的可视化编辑器，它是 UNIX 中第一个大量使用 "raw terminal input mode" 的程序，这种模式下，由应用程序而不是终端的驱动处理键盘的输入。1976 年夏天，Coulouris 参观 &lt;a href="http://en.wikipedia.org/wiki/University_of_California,_Berkeley"&gt;UC Berkeley&lt;/a&gt; 时，他带着一卷录有 em 的 DEC 磁带，他给很多人演示了 em ，有的人认为 em 只是有潜力，但是有的人却对此留下了深刻影响，其中就包括 &lt;a href="http://en.wikipedia.org/wiki/Bill_Joy"&gt;Bill Joy&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;受到 em 的鼓舞，加上他们自己使用 ed 时的技巧，Bill Joy 和 Chuck Haley 这两个刚从 UC Berkeley 的毕业的研究生使用 em 的代码，设计了一个叫 en 的编辑器，然后把 en 扩展为 &lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Ex_(editor)"&gt;ex&lt;/a&gt;&lt;/strong&gt; v0.1 。&lt;/p&gt;
&lt;p&gt;ex 仍然只显示一行而非一屏的内容。后来，Chuck Haley 退出了开发，Bruce Englar 鼓励 Bill Joy 重新设计了 ex，在 1977 年 6 月到 10 月期间，他为 ex 添加了全屏可视化模式 ，ex 的 visual mode 也就是 &lt;strong&gt;vi&lt;/strong&gt; 的命名原因 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;vi Wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vi /ˈviːˈaɪ/ is a screen-oriented text editor originally created for the Unix operating system. The portable subset of the behavior of vi and programs based on it, and the ex editor language supported within these programs, is described by (and thus standardized by) the Single Unix Specification and POSIX.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;据 Bill Joy 讲，很多 vi 的可视化灵感来自于另外一个叫做 &lt;a href="http://en.wikipedia.org/wiki/Bravo_(software)"&gt;Bravo&lt;/a&gt; 的编辑器，在一次关于 vi 的起源的访谈中，他说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A lot of the ideas for the screen editing mode were stolen from a Bravo manual I surreptitiously looked at and copied. Dot is really the double-escape from Bravo, the redo command. Most of the stuff was stolen. There were some things stolen from ed—we got a manual page for the Toronto version of ed, which I think Rob Pike had something to do with. We took some of the regular expression extensions out of that.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于为什么 vi 要设计成这么不友好，其实是有历史原因的：&lt;/p&gt;
&lt;p&gt;Joy 使用的是 Lear Siegler ADM3A 终端，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="Terminal_ADM3A" src="/images/learning-vim-survival/Terminal_ADM3A.png" /&gt;&lt;/p&gt;
&lt;p&gt;在这个终端上，&lt;code&gt;ESC&lt;/code&gt; 键的位置是现在 &lt;a href="http://en.wikipedia.org/wiki/IBM_PC_keyboard"&gt;IBM PC keyboard&lt;/a&gt; 键盘的 &lt;code&gt;Tab&lt;/code&gt; 键的位置，所以，选择 &lt;code&gt;ESC&lt;/code&gt; 作为模式切换键是很方便的设计 。同时，&lt;code&gt;h&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;l&lt;/code&gt; 键也起方向键的作用，所以，vi 也采用相同的设计 。Joy 解释说，因为他开发软件时使用的 Modem 的速率只有 300 波特，显示器上的刷新速度还没有他的思考速度快，所以他设计了单字符这样的简洁风格的命令。&lt;/p&gt;
&lt;p&gt;1978 年 3 月，Joy 负责的 BSD Unix 发布了，系统自带了 ex 1.1，这为他的编辑器在 UC Berkeley 积攒了大量人气。从那时起，Unix 系统自带的编辑器只有 ed 和 ex 。在 1984 年的一次采访中，Joy 把 vi 的成功归功于免费，当时的其他编辑器，比如 Emacs 要花费数百美金 。&lt;/p&gt;
&lt;p&gt;观察显示基本上，所有的 ex 用户都是在 visual mode 下工作，所以在 ex 2.0（作为 1979 年 5 月的 BSD Unix 的一部分）中，Joy 把 vi 作为 ex 的硬链接，这样用户一打开 ex，就默认进入 visual mode ，所以说，vi 并不是 ex 的进化，vi 就是 ex 。&lt;/p&gt;
&lt;p&gt;虽然在今天看来，vi 是一个很小的，轻量级的程序，但是 Joy 把 ex 2.0(vi) 描述为一个非常大的程序，因为它几乎占据了 &lt;a href="http://en.wikipedia.org/wiki/PDP-11#Models"&gt;PDP-11/70&lt;/a&gt; 的所有内存。在 1979 年第3版 BSD 中，PDP-11 已经无法存储v3.1 的 vi 。&lt;/p&gt;
&lt;p&gt;Joy 一直领导着 vi 的开发，一直到 1979 年 6 月的 vi 2.7，到 1980 年 8 月的 v3.5 版本中，还作出偶尔的贡献。在谈及 vi 的起源和他为何退出开发时，他说，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I wish we hadn't used all the keys on the keyboard. I think one of the interesting things is that vi is really a mode-based editor. I think as mode-based editors go, it's pretty good. One of the good things about EMACS, though, is its programmability and the modelessness. Those are two ideas which never occurred to me. I also wasn't very good at optimizing code when I wrote vi. I think the redisplay module of the editor is almost intractable. It does a really good job for what it does, but when you're writing programs as you're learning... That's why I stopped working on it.&lt;/p&gt;
&lt;p&gt;What actually happened was that I was in the process of adding multiwindows to vi when we installed our VAX, which would have been in December of '78. We didn't have any backups and the tape drive broke. I continued to work even without being able to do backups. And then the source code got scrunched and I didn't have a complete listing. I had almost rewritten all of the display code for windows, and that was when I gave up. After that, I went back to the previous version and just documented the code, finished the manual and closed it off. If that scrunch had not happened, vi would have multiple windows, and I might have put in some programmability—but I don't know.&lt;/p&gt;
&lt;p&gt;The fundamental problem with vi is that it doesn't have a mouse and therefore you've got all these commands. In some sense, its backwards from the kind of thing you'd get from a mouse-oriented thing. I think multiple levels of undo would be wonderful, too. But fundamentally, vi is still ed inside. You can't really fool it.
It's like one of those pinatas—things that have candy inside but has layer after layer of paper mache on top. It doesn't really have a unified concept. I think if I were going to go back—I wouldn't go back, but start over again.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 1979 年， &lt;a href="http://en.wikipedia.org/wiki/Mary_Ann_Horton"&gt;Mark Horton&lt;/a&gt; 接管了 vi 的开发，他添加了对方向键和功能键的支持，用  terminfo 代替了 termcap，提高了 vi 的性能 。&lt;/p&gt;
&lt;p&gt;到 1981 年的 8 月，v3.7 版的 vi 以前，UC Berkeley 是 vi 开发的中心，但是随着 1982 年初 Joy 的离开去创办 &lt;a href="http://en.wikipedia.org/wiki/Sun_Microsystems"&gt;Sun Microsystems&lt;/a&gt;，AT&amp;amp;T 的  &lt;a href="http://en.wikipedia.org/wiki/UNIX_System_V"&gt;UNIX System V&lt;/a&gt; (1983 年 1 月)采用 vi，vi 代码库的变化开始变得缓慢混乱，而且变得相互不兼容。在 UC Berkeley，虽然有修改代码，但是版本号一直没有超过 3.7 。商业的 Unix 制造商，比如 Sun, &lt;a href="http://en.wikipedia.org/wiki/HP"&gt;HP&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Digital_Equipment_Corporation"&gt;DEC&lt;/a&gt;, 和 &lt;a href="http://en.wikipedia.org/wiki/IBM"&gt;IBM&lt;/a&gt;，他们的系统 &lt;a href="http://en.wikipedia.org/wiki/Solaris_(operating_system)"&gt;Solaris&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/HP-UX"&gt;HP-UX&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Tru64_UNIX"&gt;Tru64 UNIX&lt;/a&gt;, 和 &lt;a href="http://en.wikipedia.org/wiki/AIX"&gt;AIX&lt;/a&gt;，今天仍然在使用从 3.7 release 中衍生出来的代码，但是加入了新的特性，比如可以调整的按键映射、加密等 。&lt;/p&gt;
&lt;p&gt;虽然商业的制造商可以使用 Joy 的代码库（直至今天），但是有许多人却不能使用。因为 Joy 是在 Thompson 的 ed 的基础上开发的，所以 ex 和 vi 是派生出来的产品，不能发布给没有 AT&amp;amp;T 的许可证的人使用。想在类 Unix 系统上找到一个编辑器的话必须在别的地方寻找。1985年，一个 Emacs 的版本（&lt;a href="http://en.wikipedia.org/wiki/MicroEMACS"&gt;MicroEmacs&lt;/a&gt;）在很多平台上可以使用，但是直到 1987 年 6 月才出现一个 vi 的克隆版本 —— Steive 。在 1990 年 1 月初，Steve Kirkendall 为发布了一个新的 vi 克隆版本 &lt;a href="http://en.wikipedia.org/wiki/Elvis_(text_editor)"&gt;Elvis&lt;/a&gt;，它比 Stive 更加完整更加忠实于 vi 。它很快就吸引了社区用户的热情，&lt;a href="http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"&gt;Andrew Tanenbaum&lt;/a&gt; 马上在社区讨论在 &lt;a href="http://en.wikipedia.org/wiki/Minix"&gt;Minix&lt;/a&gt; 中使用哪一个当中 vi 的克隆，结果 Elvis 胜利了，直到今天仍然在 Minix 中当作 vi 的克隆体使用 。&lt;/p&gt;
&lt;p&gt;在 1989 年，&lt;a href="http://en.wikipedia.org/wiki/Lynne_Jolitz"&gt;Lynne Jolitz&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/William_Jolitz"&gt;William Jolitz&lt;/a&gt; 开始着手把 BSD Unix 移植到 386 系列的处理器上，为了发布一个免费版本，他们必须绕过 AT&amp;amp;T 含有的代码，其中就包括 Joy 的 vi 。为了填补 vi 的空白，他们在 1992 年的 386BSD 发布版中采用了 Elvis 作为 vi 的替代品，386BSD 后来的分支 &lt;a href="http://en.wikipedia.org/wiki/FreeBSD"&gt;FreeBSD&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/NetBSD"&gt;NetBSD&lt;/a&gt; 也延续了这一决定。但是在 UC Berkely，Keith Bostic 使用 Kirkendall 的 Elvis（v1.8）代码，编写了 &lt;a href="http://en.wikipedia.org/wiki/Nvi"&gt;nvi&lt;/a&gt;，并于 1994 年春发布。当 FreeBSD 和 NetBSD 在  4.4-Lite2 代码库的基础上重新同步以后，他们也采用了 nvi，并且一直延续到今天。&lt;/p&gt;
&lt;p&gt;虽然有很多 vi 的克隆体，而且它们都有很多加强的特性，但是在 2000 年前左右，Gunnar Ritter 使用了 2.11BSD 中的 Joy 的代码，并把 vi 移植到了类 Unix 系统中，比如 Linux 和 FreeBSD 。从技术上讲，他没有许可证而发布 vi 的做法是非法的，但是，到了 2002 年 1 月，AT&amp;amp;T 的许可证被取消了，vi 可以作为开源项目在其他发布版中使用。Ritter 继续在 Joy 的代码的基础上加强 vi 的特性，就像那些商业版一样。他的成果 &lt;a href="http://ex-vi.cvs.sourceforge.net/"&gt;Traditional Vi&lt;/a&gt; 在很多系统上运行。&lt;/p&gt;
&lt;p&gt;虽然 Joy 的 vi 现在又可以在 BSD Unix 上使用，但是 很多 BSD 的粉丝都转移到 更加强大、但仍然保留着 vi 的某些特性的 nvi 的阵地。从某种意义上说，这是一个奇怪的反常现象，在 Joy 的 vi 的发源地 BSD 中不再使用 vi，但是缺少它的 AT&amp;amp;T 的发行版却仍然保留了它并使用至今。&lt;/p&gt;
&lt;p&gt;在 1984 年 Emacs 发布以前，vi 几乎是所有 Hacker 使用的 Unix 标准编辑器，从 2006 年开始，作为 &lt;a href="http://en.wikipedia.org/wiki/Single_UNIX_Specification"&gt;”单一Unix标准“（Single UNIX Specification）&lt;/a&gt;的一部分，vi 和 vi 的变形体一定可以在今天的系统中找到。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Bram_Moolenaar"&gt;Bram Moolenaar&lt;/a&gt; 于 1988 年买了一台 [Amiga][Amiga] 计算机，Amiga 上没有他常用的 vi，于是他在开源的 Stevie 的基础上，于 1991 年发布了 Vim v1.14 。&lt;/p&gt;
&lt;p&gt;起初 &lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Vim_(text_editor)"&gt;Vim&lt;/a&gt;&lt;/strong&gt; 是 &lt;em&gt;”Vi IMitation“&lt;/em&gt; 的缩写，但是后来 1993 年 12 发布的 Vim 2.0 版本中改名为 &lt;em&gt;"Vi IMproved"&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;vim 现在是 &lt;a href="http://en.wikipedia.org/wiki/GNU_General_Public_License"&gt;GNU General Public （GPL）&lt;/a&gt;下的自由软件，几乎在所有的 Linux 系统和 苹果 OS X 系统中都可以找到她的身影。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;为什么选择 Vim&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;程序猿界的 &lt;strong&gt;圣战：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Windows&lt;/strong&gt; vs &lt;strong&gt;Linux&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vim/Emacs&lt;/strong&gt; vs &lt;strong&gt;IDE&lt;/strong&gt; (&lt;strong&gt;Vim&lt;/strong&gt; vs &lt;strong&gt;Emacs&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt; vs &lt;strong&gt;JAVA&lt;/strong&gt; vs &lt;strong&gt;Python&lt;/strong&gt; vs ...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先是在 Vim 和 IDE 之间的争论。&lt;/p&gt;
&lt;h3&gt;Vim &amp;amp; IDE&lt;/h3&gt;
&lt;p&gt;”到底是该选择 vim 还是 IDE ？“ 在 Stackoverflow 和 知乎 上有非常多的这样的帖子。&lt;/p&gt;
&lt;p&gt;比如这篇：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim"&gt;What is your most productive shortcut with Vim?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再比如这篇：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/21504638"&gt;为什么不少程序员极度推崇 Vim 和 Emacs，却对 IDE 嗤之以鼻？??&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总之，萝卜芹菜各有所爱，有 Geek 精神、喜欢折腾的人不用你去说服，他自然会去学习 Vim，没有心情、懒得折腾的人，你再怎么说 Vim 好，他也不会去尝试 。（是的，我就是喜欢折腾的人 ^_^）&lt;/p&gt;
&lt;p&gt;个人选择 Vim 的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Vim 是 Linux 的 ”标配“ 编辑器，在 Linux 下开发，不会 Vim 的程序猿不是好程序猿&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还是因为 Linux 的原因。大多数 Linux 下的程序都是不需要界面的，终端才是 Linux 的精华，千万不要成迷于界面。在终端下，除了选择 Vim 你说还能选谁呢？ 因为 Vim 和 Linux 的 ”血缘“ 关系，终端 &amp;amp; Vim 给你纯正的 Linux 哲学体验（再说当你远程ssh登录时，总不能还用 IDE 吧？）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vim 下有着高度的编码一致性体验。学会了 Vim，写不同语言不同代码的体验是一样的，妈妈再也不用担心我要花时间学习不同的 IDE 了~&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我写的代码基本只限定在底层开发，主要代码是 C/C++、Shell脚本、Python脚本，不会涉及到 JAVA，更不会涉及前端开发；而且都是我的 ”玩具小程序“，几乎不涉及好几百个源文件的项目，所以我不需要 IDE 的强大的管理能力，写一个 makefile 就 OK 了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习过 CPU 知识的人都知道，频繁打断流水线才是最影响效率的东西。在调试代码的时候，显然纯键盘流要比不停的 ”鼠标 -&amp;gt; 键盘 -&amp;gt; 鼠标 -&amp;gt; ...“ 有效率的多，而且省事。&lt;a href="http://www.zhihu.com/question/22096642/answer/20290505"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;崇尚 Geek 文化，喜欢 ”折腾“，Linux 哲学教导我要学习轻量级的 Vim，而不是笨重的 IDE 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;vim &amp;amp; emacs&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;来自 wiki 百科：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Editor_war"&gt;Editor war&lt;/a&gt; 是指两类文本编辑器 Vi（以及衍生版本） 和 Emacs 之间的争论，这已经成为 hacker 文化和自由软件社区文化的一部分 。&lt;/p&gt;
&lt;p&gt;因为他们都认为自己的选择是完美的，所以相互蔑视，相互之间争论（点燃战火）。相比其他的 IT 领域战争（如浏览器大战、操作系统之争、编程语言之争、代码缩进风格之战)，编辑器的选择其实通常只是个人问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vim 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;遵循“简单工具，多样组合”的理念。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小，符合Unix哲学中的“只做一件事，并做好它”，避免了功能蔓延。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比Emacs快（至少历史上是这样的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可运行于任何实现了C标准库的系统之上，包括UNIX、Linux、AmigaOS、DOS、Windows、Mac、BeOS和POSIX兼容系统等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;让“QWERTY”键盘用户将手指保持在默认键位上，使编辑时手指移动更少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更普及。基本上所有Unix和类Unix系统都默认提供了vi或其变体。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Emacs 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;符合“厨房水槽”理念，提供了比 vi 更多的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移植最广泛的非试用计算机程序之一。它能在各种操作系统上运行，包括大多数类 Unix 系统（GNU/Linux、各种 BSD、Solaris、AIX、IRIX、AmigaOS、Mac OS X等）、MS-DOS、Microsoft Windows 和 OpenVMS。Unix 系统，无论自由版本或商业版本，均随系统提供 Emacs 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可扩展和可定制（Lisp的变体 - Emacs Lisp）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;幽默&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Richard_Stallman"&gt;Richard Stallman&lt;/a&gt; 组建了 The Church of Emacs，它称 vi 为 “魔鬼的编辑器”（vi-vi-vi 在罗马数字中表示兽名数目）。然而它并不反对 vi；相反，它视私有软件为诅咒。（“使用自由版本的 vi 不是罪恶，而是赎罪。”）它还有专门的新闻组，alt.religion.emacs，发布主题宣扬这个滑稽的宗教。&lt;/p&gt;
&lt;p&gt;Stallman 曾称自己是St IGNU−cius，Emacs教会的圣人。&lt;/p&gt;
&lt;p&gt;vi支持者也成立了对立的 Cult of vi，较强硬的 Emacs 的用户攻击这是“抄袭他们的创意”。&lt;/p&gt;
&lt;p&gt;关于vi的模式，一些 Emacs 用户说 vi 有两个模式 – “不停地哔哔叫” 和 “搞砸一切”。vi 用户则指责 Emacs 的快捷键会引发 "腕管综合症"，或者拿 EMACS 这个缩写词作文章，比如 “Escape Meta Alt Control Shift”（攻击Emacs太依赖修改键）。一些人断定是代表 “Eight Megabytes And Constantly Swapping”（8 MB，还不断进行内存交换，过去这已经是很多内存了），或者 “EMACS Makes Any Computer Slow”（EMACS使一切计算机跑得慢，这是斯托曼惯用的递归缩写），讽刺Emacs对系统资源的高需求。&lt;/p&gt;
&lt;p&gt;针对 Emacs 的“功能蔓延”，vi 支持者认为 Emacs 是 “一个伟大的操作系统，只缺个体面的编辑器”。&lt;/p&gt;
&lt;p&gt;UNIX 用户中流行一个游戏，考验一个 Emacs 用户对这个编辑器的理解深度，或者是拿 Emacs 的复杂性开玩笑，内容是：预测一下，如果一个用户按住修改键（比如 Control 或 Alt），然后键入自己的名字，会发生什么事。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;开始学习 Vim&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;闲扯了这么多，终于开始学习 vim 了...&lt;/p&gt;
&lt;p&gt;结合我的痛苦的学习过程，至今还在痛苦ing，我觉得以下的学习顺序比较适合我这样的新手：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;入门：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先，在终端下输入 vimtutor 就能进入一个 vim 自带的教程，大概花半个小时的时间就能做完。完成以后基本上就可以说是可以使用这款 大(chou)名(ming)鼎(zhao)鼎(zhu) 的 ”反人类“  的编辑器～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习 陈皓 大神在 &lt;a href="http://coolshell.cn/"&gt;coolshell&lt;/a&gt; 的博客 &lt;a href="http://coolshell.cn/articles/5426.html"&gt;vim 练级攻略&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同样，&lt;a href="http://coolshell.cn/"&gt;coolshell&lt;/a&gt; 上介绍的一个关于 Vim 的游戏 —— &lt;a href="http://vim-adventures.com/"&gt;vim adventrue&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去图书馆借本书 &lt;em&gt;&lt;a href="http://book.douban.com/subject/3041178/"&gt;Learning the vi and Vim Editors&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;阅读 Vim manpage 和 &lt;a href="https://github.com/asins/vimcdoc"&gt;安装 vim docs 中文版插件&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一本书 &lt;em&gt;&lt;a href="http://book.douban.com/subject/10599776/"&gt;Pratical Vim&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vim 作者 Bram Moolenaar 的文档 &lt;em&gt;&lt;a href="http://www.moolenaar.net/habits.html"&gt;seven habits for effective text editing&lt;/a&gt;&lt;/em&gt;  和 &lt;a href="http://v.youku.com/v_show/id_XMTIwNDY5MjY4.html"&gt;演讲视频&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-catalog/"&gt;vi/vim使用进阶&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;vi wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vim_(text_editor)"&gt;Vim wikipedia&lt;/a&gt;&lt;/p&gt;</summary><category term="Linux"></category><category term="Vim"></category></entry><entry><title>Code 书评</title><link href="http://guqian110.github.io/pages/2014/03/21/code_review.html" rel="alternate"></link><updated>2014-03-21T16:33:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-03-21:pages/2014/03/21/code_review.html</id><summary type="html">&lt;p&gt;最近花了一个星期的时间，终于把 &lt;a href="http://book.douban.com/subject/1494026/"&gt;&lt;em&gt;Code&lt;/em&gt;&lt;/a&gt; 看完了，看完全书，观后感总结出来就一个字——爽～&lt;/p&gt;
&lt;p&gt;书名： &lt;a href="http://book.douban.com/subject/1494026/"&gt;&lt;em&gt;Code:  The Hidden Language of Computer Hardware and Software&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者： &lt;a href="http://charlespetzold.com/"&gt;Charles Petzold&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这本书的作者 &lt;a href="http://en.wikipedia.org/wiki/Charles_Petzold"&gt;Charles Petzold&lt;/a&gt; 是 Windows 编程界一位大师，世界顶级技术作家。1994 年 5 月，Petzold 作为仅有的七个人之一（并且是唯一的作家）被《Window Magazine》和 Microsoft 公司授予 “Windows Pioneer” 奖，以表彰他对 Microsoft Windows 的成功做出的贡献 。&lt;/p&gt;
&lt;p&gt;关于这本书的 “江湖地位” ，只需要来看看 stackoverflow 上的这个帖子就明白了：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read"&gt;What is the single most influential book every programmer should read?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本书排名在 &lt;em&gt;第15&lt;/em&gt;，当然绝对排名没有很大的意义，但是也能说明本书的影响力 。另外本书号称 “完全不懂计算机的人也能看懂”... 如果这都不读，我不知道还有什么样的书值得我们去花费时间 : D&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;打通任督二脉&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;纵观程序员的 “武功秘籍”，不外乎两种：一种是讲 &lt;code&gt;道&lt;/code&gt;，另外一种是讲 &lt;code&gt;术&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;道&lt;/code&gt; 即 “道理”（真理），是脱离了具体事物，抽象出来的事物的本质 。比如平时学习的 &lt;em&gt;数学&lt;/em&gt;、&lt;em&gt;物理&lt;/em&gt;、&lt;em&gt;化学&lt;/em&gt; 知识，再比程序中的 &lt;em&gt;算法&lt;/em&gt;、分析解决问题的 &lt;em&gt;思维方式&lt;/em&gt; 等，都不会因时间和环境变化而不适用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;术&lt;/code&gt; 即 “技术”（技巧），是人们在具体工程实践中总结出来的一些技巧。比如 “The art of XXX” ，“The principle of XXX” 等 。&lt;/p&gt;
&lt;p&gt;是的，这本书既不是单独讲 &lt;code&gt;道&lt;/code&gt;，也不是单独讲 &lt;code&gt;术&lt;/code&gt;，而是将两者结合起来，让你不仅明白 &lt;em&gt;道&lt;/em&gt;  的深奥，也明白 &lt;em&gt;术&lt;/em&gt; 的精妙；让你体会到 &lt;em&gt;道&lt;/em&gt; 是如何在 &lt;em&gt;术&lt;/em&gt; 中实现，也体会到 &lt;em&gt;术&lt;/em&gt; 是如何在 &lt;em&gt;道&lt;/em&gt;   的约束下追求极限的 。更加关键的是全书都是用很平白的语言讲述，平白到 “即使完全不懂计算机的人也能读懂”的地步，这就是其厉害之处了。&lt;/p&gt;
&lt;p&gt;就好像你学习了五花八门的心法秘籍和各式武功，每一门都厉害无比，可偏偏无法把这些武功融会贯通，修至大成 。这时候，你需要的不是一本《葵花宝典》，而是《论天下武功之间的关系及其融会贯通方法》，打通自己的任督二脉，也就是这本 &lt;a href="http://book.douban.com/subject/1494026/"&gt;Code&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;读这本书时，让我想起了在大学 4 年间读的各种课程：&lt;/p&gt;
&lt;p&gt;读到 第 6 章 “电报机与继电器” 让我想起 &lt;em&gt;大学物理&lt;/em&gt; ，虽然翘了很多课，但是电磁感应什么的有中学基础，还好没有忘记 。&lt;/p&gt;
&lt;p&gt;读到 第 7～9 章，书中对计数的方法和进制的讨论，让我想起 &lt;em&gt;大学计算机基础&lt;/em&gt; ，然后花了一天时间去把以前一知半解的 “原码、反码、补码” 仔细推敲总结一遍，收获颇大 。&lt;/p&gt;
&lt;p&gt;读到 第 10 章，布尔代数 让我想起 &lt;em&gt;离散数学&lt;/em&gt; ，尤其发人深醒的是布尔发明了 布尔逻辑 100 多年后， 才有人（香农）将其和电路联系起来 。&lt;/p&gt;
&lt;p&gt;读到 第 11～13 章，跟随作者的思路，我才明白当年令人痛不欲生的 &lt;em&gt;模拟电路&lt;/em&gt; 、&lt;em&gt;数字电路&lt;/em&gt;  到底是来干什么的，数字电路是如何从最基本的门搭建出来更强的功能的元器件的，联系前面学习的 编码的知识，明白这样做的道理 。&lt;/p&gt;
&lt;p&gt;读到 第 16～22 章，让我想起 &lt;em&gt;微机原理&lt;/em&gt; ，对微处理器的工作方式不再模糊不清，跟随着作者的思路搭建一台 “计算机”（当然和现在的计算机完全不同，但是原理是一模一样的），为自己搭建的处理器设计一套可以实现自动功能的编程语言，然后写一段程序，甚至一窥操作系统 。&lt;/p&gt;
&lt;p&gt;还有等等...&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br&gt;
胡扯了这么多，书固然是好书，但是更让人深思的是 国内外教育的差异 。吐槽我们的教育体制毫无意义，吐槽的人都当不上教育部长，没有能力去改变现状，有能力的 guan猿却根本没有动力去改变。作为普通人，我们能做到的就是自己努力，找真正的好书、向真正的大师学习，比如上面提到过的&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read"&gt;What is the single most influential book every programmer should read?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了技术、还有很多程序员需要看的书。找到一本好书，然后 Let's start it !&lt;/p&gt;</summary><category term="Code"></category><category term="review"></category></entry><entry><title>原码、反码、补码</title><link href="http://guqian110.github.io/pages/2014/03/19/signed_number_representations.html" rel="alternate"></link><updated>2014-03-19T14:31:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-03-19:pages/2014/03/19/signed_number_representations.html</id><summary type="html">&lt;p&gt;最近找到一本好书——&lt;a href="http://book.douban.com/subject/4822685/"&gt;《编码: 隐匿在计算机软硬件背后的语言》&lt;/a&gt;。作者是大名鼎鼎的 &lt;a href="http://en.wikipedia.org/wiki/Charles_Petzold"&gt;Charles Petzold&lt;/a&gt; (&lt;a href="http://charlespetzold.com/"&gt;个人网站&lt;/a&gt;)。书的介绍也很有意思，据说完全不懂计算机的人也能看懂...于是买了本来拜读一下（这种文章当然是英文版最好了，只是学生党没银子，只好买翻译版了）&lt;/p&gt;
&lt;p&gt;看到用继电器搭建加法器、减法器，讨论二进制编码方式那章，想起一直不是很清楚的原码、反码、补码等，果断 &lt;a href="https://www.google.com.hk/"&gt;Google&lt;/a&gt;、&lt;a href="http://en.wikipedia.org/wiki/Main_Page"&gt;Wiki&lt;/a&gt;，于是总结出下文。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;机器数&lt;/h3&gt;
&lt;p&gt;顾名思义，一个数字在机器中的存储方式，“&lt;em&gt;数&lt;/em&gt; ” 是指 有符号数（&lt;code&gt;signed number&lt;/code&gt;），即包含了正负号的数，“&lt;em&gt;机器&lt;/em&gt; ” 当然是指计算机（&lt;code&gt;Computer&lt;/code&gt;）了。&lt;/p&gt;
&lt;p&gt;从小学毕业，刚进入初中，我们就知道数字是有符号的：&lt;em&gt;正数&lt;/em&gt; &amp;amp; &lt;em&gt;负数&lt;/em&gt;。但是在计算机的哲学体系中，整个世界只有两个元素：0 &amp;amp; 1 ，没有额外的专门表示正负号的符号。怎么办呢？解决方法就是添加一位来表示符号。于是，人们约定把符号位放在一个数字的 &lt;em&gt;最高有效位&lt;/em&gt;（Most significant bit, &lt;code&gt;MSB&lt;/code&gt;），在&lt;a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F"&gt;大端序&lt;/a&gt;中，&lt;code&gt;MSB&lt;/code&gt; 指的是一个二进制数的最左边的一位。一般，&lt;code&gt;MSB&lt;/code&gt; 等于 0  表示正数，1 表示负数。&lt;/p&gt;
&lt;h3&gt;真值&lt;/h3&gt;
&lt;p&gt;因为机器数中有一位表示符号，所以机器数的形式值不等于真正的数值，机器数对应的数值称为机器数的 &lt;em&gt;真值&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
举个栗子：&lt;/p&gt;
&lt;p&gt;用 8 bit 表示一个数字，因为有符号位的存在，可以表示的范围为 (-127, -0, +0, +127) 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# +5 的 机器数 = 0000_0101 ；真值 = + 000_0101&lt;/span&gt;

&lt;span class="c"&gt;# -5 的 机器数 = 1000_0101 ；真值 = - 000_0101&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种机器数的编码方式称为 &lt;a href="http://en.wikipedia.org/wiki/Signed_magnitude#Signed_magnitude_representation"&gt;&lt;em&gt;原码&lt;/em&gt;&lt;/a&gt; (&lt;code&gt;signed-magnitude&lt;/code&gt;) ，是机器数编码方式中的一种。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The four best-known methods of extending the binary numeral system to represent signed numbers are: sign-and-magnitude, Ones' complement, two's complement, and excess-K.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;There is no definitive criterion by which any of the representations is universally superior. The representation used in most current computing devices is two's complement, although the Unisys ClearPath Dorado series mainframes use Ones' complement.&lt;/em&gt;
（&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations"&gt;Wikipeida&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;下面分别讨论：&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;机器数表示法&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;原码（sign and magnitude）&lt;/h3&gt;
&lt;h4&gt;编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 正数：  0_xxxxxxx&lt;/span&gt;

&lt;span class="c"&gt;# 负数：  1_xxxxxxx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8 bit 的原码可以表示的范围是 [ -127, -0, +0, +127 ]，共 255 个数&lt;/p&gt;
&lt;h4&gt;计算法则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 两数符号相同：  低位相加，最高位的符号位不变（当低位相加产生进位时，溢出 Overflow）&lt;/span&gt;

&lt;span class="c"&gt;# 两数符号不同：  比较绝对值的大小，差的绝对值 = 大数 - 小数 ，符号位和大数的符号位相同&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;电路复杂&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从前面的计算方法中可以看到，原码中的符号位不能直接参与运算，必须要单独的线路来确定符号位&lt;/li&gt;
&lt;li&gt;原码的计算不能避免减法运算，加法运算是产生 &lt;em&gt;进位&lt;/em&gt;，减法运算需要 &lt;em&gt;借位&lt;/em&gt;，这是两种不同的运算过程，需要额外的电路把 &lt;code&gt;加法器&lt;/code&gt; 改造为 &lt;code&gt;减法器&lt;/code&gt;（&lt;a href="http://www.charlespetzold.com/code/"&gt;《编码》&lt;/a&gt;这本书里面有详细介绍 如何使用继电器搭建 加法器 和 减法器）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0的表示不唯一&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0可以编码为两种方式： &lt;code&gt;0000_0000&lt;/code&gt; 和 &lt;code&gt;1000_0000&lt;/code&gt;，进一步增加了逻辑的复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;This approach is directly comparable to the common way of showing a sign (placing a "+" or "−" next to the number's magnitude). Some early binary computers (e.g., &lt;a href="http://en.wikipedia.org/wiki/IBM_7090"&gt;IBM 7090&lt;/a&gt;) used this representation, perhaps because of its natural relation to common usage. Signed magnitude is the most common way of representing the significand in floating point values.
（&lt;a href="http://en.wikipedia.org/wiki/Signed_magnitude#Signed_magnitude_representation"&gt;Wiki&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;虽然 &lt;code&gt;原码&lt;/code&gt; 的编码方式最接近人类的习惯，但是，并不适合在计算机中使用，为了解决原码计算中的一些问题，于是 &lt;code&gt;反码&lt;/code&gt; 就出现了&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;反码（Ones' complement）&lt;/h3&gt;
&lt;p&gt;首先，来看看 &lt;a href="http://www.charlespetzold.com/code/"&gt;Code&lt;/a&gt; 中介绍了基于10进制的补码：&lt;/p&gt;
&lt;p&gt;实现一个减法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 - 176 =？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照我们从数学课上学习到知识，这个计算需要进行 &lt;em&gt;借位&lt;/em&gt; 操作，为了避免这个在计算机中很难实现的操作，可以稍微变化一下计算过程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (999-176) + 1 - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个过程中，用两个减法代替了原来的一个减法，避免了烦琐的 &lt;em&gt;借位&lt;/em&gt; 操作。在这个运算中，负数 &lt;code&gt;-176&lt;/code&gt; 转化为另外一个数 &lt;code&gt;999 - 176&lt;/code&gt; ，这个数称为它的 &lt;code&gt;9 的补数(nine's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个运算的关键在于：&lt;em&gt;把负数用 9 的补数表示，减法转化为加法&lt;/em&gt; 。同理，我们推广到 2 进制，就得到了 &lt;code&gt;1 的补数(Ones' complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;把减数从一串 1 当中减去，结果就称为这个数的 “1 的补数”，在求 1 的补数的时候，其实并不需要做减法，因为求 1 的补数，只需要将原来的 1 变为 0 ，0 变为 1 即可，也就是取反，在电路中只需要一个反向器就可以实现，所以 &lt;code&gt;1 的补数&lt;/code&gt; 也称为 &lt;code&gt;反码&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;从上面的描述就可以很容易写出反码的编码规则&lt;/p&gt;
&lt;h4&gt;编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 正数    反码 = 原码&lt;/span&gt;

&lt;span class="c"&gt;# 负数    反码 = 符号位不变，其他位取反&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8 bit 的反码可以表示的范围是 [ -127, -0, +0, +127 ]，共 255 个数&lt;/p&gt;
&lt;h4&gt;计算法则&lt;/h4&gt;
&lt;p&gt;反码的计算不用区分符号和绝对值，直接进行计算，计算结果若有溢出，需要将溢出加到最低位，这种操作称为 “循环进位”（end-around carry）&lt;/p&gt;
&lt;h4&gt;优缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;优点，电路简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为不需要把符号和绝对值分开考虑，正数和负数的加法都一样算，所以反码计算不需要单独的判断符号的电路，也不需要判断两个数绝对值相对大小的电路&lt;/li&gt;
&lt;li&gt;节省了减法器，只需要一组额外的反向器就能把加法器改进为可以计算 加 / 减法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算机中仍然需要进行 “循环进位” 的硬件电路，但是这种复杂度的电路是可以接受的&lt;/li&gt;
&lt;li&gt;0的表示不唯一，0的编码仍然有两种方式： &lt;code&gt;0000_0000&lt;/code&gt; 和 &lt;code&gt;1111_1111&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;The &lt;a href="http://en.wikipedia.org/wiki/PDP-1"&gt;PDP-1&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/CDC_160_series"&gt;CDC 160 series&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/CDC_6000_series"&gt;CDC 6000 series&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/UNIVAC_1100"&gt;UNIVAC 1100 series&lt;/a&gt;, and the &lt;a href="http://en.wikipedia.org/wiki/LINC"&gt;LINC&lt;/a&gt; computer used Ones' complement representation.（&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations#Ones.27_complement"&gt;Wiki&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;反码&lt;/code&gt; 中仍然没有避免 0 有两种编码方式的问题，虽然对于人来说，+0 和 -0 没有区别，但是对于计算机来说，判断一个数是否为0，要进行两次判断。为了解决 0 的表示问题和硬件上的 “循环进位”，于是人们又发明了 &lt;code&gt;补码&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;补码（Two's complement）&lt;/h3&gt;
&lt;p&gt;前面介绍的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 - 176 =？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照反码的方法可以转换为&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (999-176) + 1 - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果我们稍微再变形一下，就有&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (1000 - 176) - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个运算中 &lt;code&gt;-176&lt;/code&gt; 转化为 &lt;code&gt;1000 - 176&lt;/code&gt;，这个数称为它的 &lt;code&gt;10 的补数(ten's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个运算的关键在于：&lt;em&gt;把负数用 10 的补数表示，减法转化为加法&lt;/em&gt; 。同理，我们推广到 2 进制，就得到了 &lt;code&gt;2 的补数(two's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;因为对一位二进制数 b 取补码就是 &lt;code&gt;1 - b + 1 = 10 - b&lt;/code&gt;，相当于从 2 里面减去 b ,所以，这种方法称为 &lt;code&gt;2 的补数&lt;/code&gt;，这种编码方式简称 &lt;code&gt;补码&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;举例说明，要表示 -4 ，需要对 &lt;code&gt;0000_0100&lt;/code&gt;取补码，&lt;code&gt;1111_1111 - 0000_0100 + 1 = 1_0000_0000 - 0000_0100&lt;/code&gt;，相当于从2^8里面减去 4 。&lt;/p&gt;
&lt;p&gt;从上面的计算过程可以很容易写出补码的编码规则&lt;/p&gt;
&lt;h4&gt;编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 正数    补码 = 原码&lt;/span&gt;

&lt;span class="c"&gt;# 负数    补码 = 反码 + 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8 bit补码可以表示的范围是 [ -128, -1, +0, +127 ]，共 256 个数 。&lt;/p&gt;
&lt;p&gt;目前大多数计算机内部使用的都是补码，所以对于编程中的 32 位 &lt;code&gt;int&lt;/code&gt; 型变量，它可以表示的范围就是 [ -2^32, +2^32 - 1] 。&lt;/p&gt;
&lt;p&gt;P.S. -128 没有对应的 原码 和反码，它的补码为 &lt;code&gt;1000_0000&lt;/code&gt; 。&lt;/p&gt;
&lt;h4&gt;计算法则&lt;/h4&gt;
&lt;p&gt;采用补码的系统，减法转换成加法（减法等同于加上一个负数，所以不再有减法），忽略计算结果最高位的进位，不必加回到最低位上去。&lt;/p&gt;
&lt;h4&gt;优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;电路简单，从计算法则中可以看到，不用考虑 “循环进位” 的问题，所以，补码系统的电路是最简单的，这也是补码系统应用最广泛的原因&lt;/li&gt;
&lt;li&gt;0 的表示是唯一的，&lt;code&gt;0000_0000&lt;/code&gt;，不再有 -0 的困扰&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;补码中的数学原理&lt;/h4&gt;
&lt;p&gt;补码能将减法转化为加法，其数学原理就是 &lt;em&gt;模&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 如果有个手表的时间为6点，实际时间为4点，那么如何校准呢？&lt;/span&gt;

&lt;span class="c"&gt;# 答案有两种方法：&lt;/span&gt;

&lt;span class="c"&gt;#   1. 逆时针转动  2，也就是做 减法 6 - 2 = 4&lt;/span&gt;
&lt;span class="c"&gt;#   2. 顺时针转动 10, 也就是做 加法 (6 + 10) mod 12 = 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从这个例子中就可以很明白的看到 &lt;em&gt;减法&lt;/em&gt; 是如何转化为 &lt;em&gt;加法&lt;/em&gt; 的，也就是如何将一个 &lt;em&gt;负数&lt;/em&gt; 转化为 &lt;em&gt;正数&lt;/em&gt;的 。&lt;/p&gt;
&lt;p&gt;即有公式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A - B = A + (-B + M)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个式子中的 &lt;code&gt;-B + M&lt;/code&gt; 即为 &lt;code&gt;B&lt;/code&gt; 的 &lt;em&gt;补数&lt;/em&gt; （类似于几何中的&lt;em&gt;补角&lt;/em&gt;） 。&lt;/p&gt;
&lt;h4&gt;溢出问题（摘自 &lt;a href="http://baike.baidu.com/view/60437.htm"&gt;百度百科&lt;/a&gt;）&lt;/h4&gt;
&lt;p&gt;无论采用何种机器数，只要运算的结果大于数值设备所能表示数的范围，就会产生溢出。 溢出现象应当作一种故障来处理，因为它使结果数发生错误。异号两数相加时，实际是两数的绝对值相减，不可能产生溢出，但有可能出现正常进位；同号两数相加时，实际上是两数的绝对值相加，既可能产生溢出，也可能出现正常进位。&lt;/p&gt;
&lt;p&gt;由于补码运算存在符号位进位自然丢失而运算结果正确的问题，因此，应区分补码的溢出与正常进位。&lt;/p&gt;
&lt;p&gt;详细论证过程不再复制粘贴了...直接给出结论&lt;/p&gt;
&lt;p&gt;结论：在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。&lt;/p&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;由 &lt;em&gt;“减去一个数 = 加上一个负数”&lt;/em&gt;，计算机系统内部就不再有减法操作&lt;/p&gt;
&lt;p&gt;由 &lt;em&gt;“负数的表示由取模运算转变为补码表示”&lt;/em&gt;，计算机系统就可以用一个正数来表示负数&lt;/p&gt;
&lt;p&gt;所以，计算机内部只需要加法器就可以完成 加减法 和 正负数 的表示 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Two's complement is the easiest to implement in hardware, which may be the ultimate reason for its widespread popularity. Processors on the early mainframes often consisted of thousands of transistors – eliminating a significant number of transistors was a significant cost savings. Mainframes such as the IBM System/360, the GE-600 series, and the PDP-6 and PDP-10 used two's complement, as did minicomputers such as the PDP-5 and PDP-8 and the PDP-11 and VAX. The architects of the early integrated circuit-based CPUs (Intel 8080, etc.) chose to use two's complement math. As IC technology advanced, virtually all adopted two's complement technology. x86, m68k, Power Architecture, MIPS, SPARC, ARM, Itanium, PA-RISC, and DEC Alpha processors are all two's complement.&lt;/em&gt;(&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations#Two.27s_complement"&gt;Wiki&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;有符号数和无符号数（摘自 &lt;a href="http://learn.akae.cn/media/ch14s03.html"&gt;整数的加减运算&lt;/a&gt;）&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;如果把所有的位数都用来表示数值的大小，那么8 bit 二进制数可以表示的范围是 [0, 255] ，这种称为无符号数 。其实计算机做加法时并不区分操作数是有符号数还是无符号数，计算过程都一样 。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c"&gt;#   1000_0010              130                  -126&lt;/span&gt;
    &lt;span class="c"&gt;# + 1111_1000     =&amp;gt;   +   256          =&amp;gt;  +   -  8&lt;/span&gt;
    &lt;span class="c"&gt;# --------------      ---------------      -----------&lt;/span&gt;
    &lt;span class="c"&gt;# 1_0111_1010              122 + 256             122&lt;/span&gt;

    &lt;span class="c"&gt;#                        无符号数（ok）        有符号数（error）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;计算机的加法器在做完计算之后，根据最高位产生的进位设置 &lt;em&gt;进位标志&lt;/em&gt; ，同时根据最高位和次高位产生的进位的异或设置 &lt;em&gt;溢出标志&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;如果看作无符号数130和248相加，计算结果是122进1，也就是122+256，这个结果是对的; 如果把这两个操作数看作有符号数-126和-8相加，计算结果是错的，因为产生了溢出 。&lt;/p&gt;
&lt;p&gt;至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，下一步就要检查溢出标志，如果程序把它理解成无符号数加法，下一步就要检查进位标志。&lt;/p&gt;
&lt;p&gt;通常计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有bit都是零则设置零标志，如果计算结果的最高位是1则设置负数标志，如果程序把计算结果理解成有符号数，也可以检查负数标志判断结果是正是负。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;从 &lt;code&gt;原码&lt;/code&gt; 到 &lt;code&gt;反码&lt;/code&gt;，再到 &lt;code&gt;补码&lt;/code&gt;，可以清楚看到为了解决问题而改进的技术路线，虽然这些是非常基础知识，可能对我们对写程序没有很大的帮助，但是搞清楚这些不仅让你对计算机底层更加了解，更加关键的是 &lt;em&gt;这个学习过程&lt;/em&gt; 和 &lt;em&gt;解决编码问题的思路&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations"&gt;Signed number representations——Wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Ones'_complement"&gt;Ones' complement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Two's_complement"&gt;Two's complement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://learn.akae.cn/media/ch14s03.html"&gt;整数的加减运算&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://baike.baidu.com/view/60437.htm"&gt;机器数——百度百科&lt;/a&gt;&lt;/p&gt;</summary><category term="Code"></category></entry><entry><title>First Blood</title><link href="http://guqian110.github.io/pages/2014/03/17/first_blood.html" rel="alternate"></link><updated>2014-03-17T14:29:00+08:00</updated><author><name>Chien Gu</name></author><id>tag:guqian110.github.io,2014-03-17:pages/2014/03/17/first_blood.html</id><summary type="html">&lt;h2&gt;为什么要搭建自己的博客&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;首先，来看看各类门户博客的优缺点。&lt;/p&gt;
&lt;p&gt;国内大多数人的朋友圈都聚集在 QQ、微博、人人等社交平台上。但是这些社区并不适合写博客，面对满屏幕毫无营养的转载文章和五颜六色的广告，谁还有兴趣把自己的生活感悟写下来？其实，我们需要的仅仅是一方可以写字的净土。至于各大技术博客平台，它们明显不适合用来记录生活中的点滴琐事。CSDN 的博客系统一直是人们的吐槽对象，况且，CSDN 已经沦为学生求作业的地方，很多大神都转移阵地，去搭建自己的博客了。&lt;/p&gt;
&lt;p&gt;既然这些平台都不能满足我们的需求，为什么我们不搭建一个属于自己的博客呢？&lt;/p&gt;
&lt;p&gt;我们写博客是为了记录自己的学习、生活和成长，寻找志同道合的知己。个人博客也是一种身份，代表了博主的兴趣爱好和品味。我们自己是博客的主人，可以自己定制主题和内容，而无需经受别人的审核和莫名删除的烦恼。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;为什么选择 Markdown + Pelican + GitHub&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;不同于面向 &lt;em&gt;发布&lt;/em&gt; 的 &lt;code&gt;Html&lt;/code&gt; 语言，&lt;code&gt;Markdown&lt;/code&gt; 是一种面向 &lt;em&gt;书写&lt;/em&gt; 的语言，其目的就是让文档更容易写和读，让人们不再为 &lt;code&gt;Html&lt;/code&gt; 繁琐的标签烦恼。&lt;/p&gt;
&lt;p&gt;搭建个人博客最方便也最简易的方式就是采用 &lt;code&gt;WordPress&lt;/code&gt; 平台。但是，简易也意味着无脑、不能随行所欲地定制。我们只是需要一个写字的地方，显然 &lt;code&gt;WordPress&lt;/code&gt; 太臃肿，用来生成静态博客的 &lt;code&gt;Pelican&lt;/code&gt; 才是我们的最佳选择。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Github&lt;/code&gt; 是一个共享虚拟主机服务，用于存放使用 &lt;code&gt;Git&lt;/code&gt; 版本控制的软件代码和内容项目。——by &lt;a href="http://zh.wikipedia.org/wiki/GitHub"&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以我们只要采用 &lt;code&gt;Markdown&lt;/code&gt; 写下我们的博客内容，用 &lt;code&gt;Pelican&lt;/code&gt; 生成静态网页，然后将其托管到&lt;code&gt;GitHub&lt;/code&gt; 上，就大功告成了！&lt;/p&gt;
&lt;p&gt;折腾了几天，终于在 &lt;a href="https://www.google.com.hk"&gt;Google&lt;/a&gt; 和以下几篇博客的帮助下，初步搭建好了个人的小窝。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.lizherui.com/pages/2013/08/17/build_blog.html"&gt;一步一步打造Geek风格的技术博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.xycoding.com/articles/2013/11/21/blog-create/"&gt;使用Pelican和GitHub Pages搭建个人博客 —— 基础篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.dongxf.com/3_Build_Personal_Blog_With_Pelican_And_GitHub_Pages.html"&gt;用 Pelican 和 GitHub Pages 搭建免费的个人博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://frantic1048.com/bo-ke-dan-sheng-ji-ji-yu-githubpelicanchuang-jian-bo-ke-de-zheng-ge-guo-cheng.html"&gt;博客诞生记:基于GitHub+Pelican创建博客的整个过程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;如何搭建&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;本博客就是在参考以上 4篇博客的教程 + &lt;a href="https://www.google.com.hk"&gt;Google&lt;/a&gt; ，在 &lt;code&gt;Ubuntu 13.10&lt;/code&gt; 下完成的，十分感谢各位博主的分享。在搭建过程中遇到了不少问题，但是在万能的 Google 面前，都一切都不是问题，同时我也学习到了不少知识。&lt;/p&gt;
&lt;p&gt;详细的搭建过程参考以上4篇博客，不再赘述，下面总结一下自己安装过程中遇到的问题吧。&lt;/p&gt;
&lt;h3&gt;学习流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;学习 &lt;code&gt;Git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://gitref.org/"&gt;Git Refence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://git-scm.com/book"&gt;Pro Git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://help.github.com/"&gt;GitHub help&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装、学习使用 &lt;code&gt;Pelican&lt;/code&gt; 搭建博客骨架&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/getpelican/pelican"&gt;Pelican Source Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.getpelican.com/en/latest/"&gt;Pelican Doc&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习 &lt;code&gt;Markdown&lt;/code&gt; 语法，写博客内容&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wowubuntu.com/markdown/#hr"&gt;Markdown语法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sourceforge.net/projects/retext/"&gt;Markdown 编辑器 Retext&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pelican theme&lt;/code&gt; 修改&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.getpelican.com/en/latest/settings.html#themes"&gt;Pelican theme setting&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;问题总结&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一种安装方式不成功时，可以试试其他方法。使用命令行安装 &lt;code&gt;Pelican&lt;/code&gt; 时，由于学校的渣网速，我安装了好几遍都 &lt;em&gt;time_out&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须先安装 &lt;code&gt;Pelican&lt;/code&gt;，后安装 &lt;code&gt;Markdown&lt;/code&gt;，否则在生成网页时会报错，不能识别 &lt;code&gt;.md&lt;/code&gt; 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;pelican-quickstart&lt;/code&gt; 时，有些选项是可以在 &lt;code&gt;pelicanconf.py&lt;/code&gt; 中修改的，有些不行 。比如是否启用文章分页，是不能通过后期修改的，如果第一次没有启用，在 pelicanconf.py 中直接修改会报错，只能保存好文章、下载的主题和配置文件，重新用向导生成博客框架 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于薄弱的 &lt;code&gt;Html&lt;/code&gt; 知识， &lt;code&gt;Pelican theme&lt;/code&gt; 的修改花费了很多时间 (Orz...)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;总之，既然搭建好了博客，就要坚持认真写下去，记录下生活中的每一点一滴。&lt;/p&gt;</summary><category term="Build Blog"></category></entry></feed>